Привет! Сделай подробное описание проекта, сформируй чёткую структуру взаимозависимостей компонентов, переменных и функций для её дальнейшего предоставления в контекст моделей.  Сделай всё в таком формате, чтобы затем локальным LLM было удобно работать с этой информацией и они ознакамливались с проектом в кратчайшее время. Чтобы в своей работе они ориентировались на эту структуру и, к примеру, не меняли имена важных функций без весомой причины, что часто приводит к неработоспособности всего приложения. Вот вводные данные по проекту: <<Привет! Я пишу код проекта на Vue3. Имеющийся функционал не урезай! Осторожно убирай только дублирующие функции. Выстраивай чёткую логику приложения. Я работаю с Vue 3, Vite, Pinia и Vue Router. Мы с тобой создаём приложение на Vue3 Composition API c бекендом на Node.js v24.5.0. Python я использовать не умею. Помоги мне в дальнейшей разработке. В логике мы широко используем Pinia и Vue Router. Вся логика и функционал должны быть в Pinia Store, а в компонентах только отображение! ЭТО ОЧЕНЬ ВАЖНО! Моё железо: Xeon E5 2640v4, 64Gb ddr4 Quad channel Ram. Я использую Windows 10. Я также локально скачал модель llama3.1:latest для использования её функционала в приложении. Отвечай мне на русском. Если тебе нужно ознакомится с другими файлами из моего проекта - попроси и я их пришлю. У приложения есть функция загрузки PDF-файлов и распознавания в них текста. Далее распознанный текст передаётся для анализа в локальную LLM и в нём выделяется краткая суть и существенные параграфы. Всей этой информацией пополняется файл db.json 
Вот его структура: 1) дата поступления 2) дословный текст, предоставленный пользователем 3) ведомство на которое будет формироваться жалоба 4) краткая суть текста пользователя(не дословно) 5) дословно скопированные существенные параграфы (дословно - это очень важно для последующего составления жалоб) 6) расшифровка предоставленных им документов: а) Дата отправления документа б) Ведомство, отправившее документ в) краткая суть документа г) Полный текст документа д) Дословно скопированные существенные параграфы из расшифровки документа (дословно - это очень важно для последующего составления жалоб). После загрузки текста пользователя, вложенных документов и нажатия кнопки "Продолжить" на главной странице, открывается страница предпросмотра документа перед его сохранением с возможностью ручного редактирования (DocumentReview.vue). Также ниже следует добавить возможные недостающие поля из новой структуры базы данных db.json, чтобы вся информация из текущей карточки отображалась в этом компоненте. Третья страница - отображение списком всех актов записей из файла db.json в виде поля даты формирования, ведомства, на которое будет сформирована жалоба и краткой сути текста пользователя. В правой части каждой записи есть кнопка "Сформировать жалобу". После нажатия кнопки "Сформировать жалобу" локальная LLM анализирует всю информацию текущей записи базы данных, а также информацию остальных актов записей в db.json, внесённых туда ранее данной записи на предмет наличия сведений, существенных для составления жалобы на основе этого входящего документа,  и предлагает на выбор ведомства, в которые пользователь имеет право направить жалобу на ведомство, допустившее нарушение: ФССП, Прокуратура', Суд (административное исковое заявление, Уполномоченный по правам человека (омбудсмен). После выбора ведомства для направления жалобы, локальная LLM формирует жалобу и сохраняет её в файл db.json по аналогии с методом сохранения входящих документов, только в сформированных жалобах добавляется поле, в ответ на какой из входящих документ сформирована эта жалоба. Четвёртая страница - список сформированных жалоб, по аналогии с третьей страницей, но без кнопки "анализировать" в пределах каждой записи. Напротив каждой сформированной жалобы должна быть кнопка "Экспорт" с возможностью сохранения выбранной жалобы в формате .txt или .doc. Механика удаления входящих документов и сформированных жалоб уже сформирована - её менять не нужно, без моей прямой просьбы.>  Вот код компонентов проекта:
Это код файла FatherGuard\frontend\src\components\common\FileUpload.vue:
<template>
  <div class="file-upload">
    <input 
      type="file" 
      id="fileInput"
      ref="fileInput"
      :accept="allowedExtensions"
      @change="handleFileUpload"
      multiple
      hidden
    />
    <label for="fileInput" class="upload-button">
      {{ label }}
    </label>
    <div v-if="files.length > 0" class="file-list">
      <div v-for="(file, index) in files" :key="index" class="file-item">
        <span class="file-name">{{ file.name }}</span>
        <span class="file-size">{{ formatFileSize(file.size) }}</span>
        <button @click="removeFile(index)" class="remove-btn">×</button>
      </div>
    </div>
    <div v-if="error" class="error-message">{{ error }}</div>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const props = defineProps({
  label: {
    type: String,
    default: 'Выберите файлы'
  },
  maxSize: {
    type: Number,
    default: 10 * 1024 * 1024 // 10MB по умолчанию
  }
});

const emit = defineEmits(['files-selected', 'upload-error']);

const fileInput = ref(null);
const files = ref([]);
const error = ref(null);
const allowedExtensions = '.pdf,.txt,.doc,.docx';

const handleFileUpload = (event) => {
  error.value = null;
  const newFiles = Array.from(event.target.files);
  
  // Проверка каждого файла
  for (const file of newFiles) {
    // 1. Проверка расширения
    const extension = file.name.split('.').pop().toLowerCase();
    if (!['pdf', 'txt', 'doc', 'docx'].includes(extension)) {
      error.value = `Файл ${file.name}: недопустимое расширение`;
      emit('upload-error', error.value);
      return;
    }

    // 2. Проверка MIME-типа (клиентская проверка ненадежна, но лучше чем ничего)
    const allowedMimes = [
      'application/pdf',
      'text/plain',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
    
    if (file.type && !allowedMimes.includes(file.type)) {
      error.value = `Файл ${file.name}: недопустимый тип`;
      emit('upload-error', error.value);
      return;
    }

    // 3. Проверка размера
    if (file.size > props.maxSize) {
      error.value = `Файл ${file.name}: превышен максимальный размер (${props.maxSize / 1024 / 1024}MB)`;
      emit('upload-error', error.value);
      return;
    }
  }

  // Если все проверки пройдены
  files.value = [...files.value, ...newFiles];
  updateFileInput();
  emit('files-selected', files.value);
};

const removeFile = (index) => {
  files.value.splice(index, 1);
  updateFileInput();
  emit('files-selected', files.value);
};

const updateFileInput = () => {
  const dataTransfer = new DataTransfer();
  files.value.forEach(file => dataTransfer.items.add(file));
  fileInput.value.files = dataTransfer.files;
};

const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};
</script>

Это код файла FatherGuard\frontend\src\components\ui\NotificationToast.vue:
<template>
  <transition name="fade">
    <div v-if="show" class="notification-center">
      <div class="notification-content">
        {{ message }}
      </div>
    </div>
  </transition>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const props = defineProps({
  message: String,
  type: {
    type: String,
    default: 'success'
  },
  duration: {
    type: Number,
    default: 3000
  }
})

const show = ref(false)

onMounted(() => {
  show.value = true
  setTimeout(() => {
    show.value = false
  }, props.duration)
})
</script>

Это код файла FatherGuard\frontend\src\composables\useComplaintGenerator.js:
import { ref } from 'vue';
import { useAIStore } from '@/stores/aiStore';

export default function useComplaintGenerator() {
  const aiStore = useAIStore();
  const isGenerating = ref(false);
  const generationError = ref(null);

  const generateComplaint = async (text, agency) => {
    isGenerating.value = true;
    generationError.value = null;
    try {
      return await aiStore.generateComplaint(text, agency);
    } catch (error) {
      generationError.value = error.message;
      throw error;
    } finally {
      isGenerating.value = false;
    }
  }

  return {
    isGenerating,
    generationError,
    generateComplaint
  }
}

Это код файла FatherGuard\frontend\src\composables\useDocumentAnalysis.js:
import { useDocumentStore } from '@/stores/documentStore';
import { useAIStore } from '@/stores/aiStore';

export const useDocumentAnalysis = () => {
  const documentStore = useDocumentStore();
  const aiStore = useAIStore();

  const analyzeCurrentDocument = async () => {
    return await documentStore.analyzeDocument();
  }

  const analyzeTextWithLLM = async (text) => {
    return await aiStore.analyzeDocumentText(text);
  }

  return {
    analyzeCurrentDocument,
    analyzeTextWithLLM
  }
}

Это код файла FatherGuard\frontend\src\router\index.js:
import { createRouter, createWebHistory } from "vue-router";
import HomeView from "@/views/HomeView.vue"; // Импорт напрямую для главной страницы


const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: "/",
      name: "home",
      component: HomeView,
    },
    {
      path: "/review/:id", // Добавляем динамический сегмент
      name: "review",
      component: () => import("@/views/DocumentReview.vue"),
      props: true,
    },
    {
      path: "/documents",
      name: "documents",
      component: () => import("@/views/DocumentsList.vue"), // DocumentsList вместо DocumentsView
    },
    {
      path: "/complaints",
      name: "complaints",
      component: () => import("@/views/ComplaintsList.vue"), // ComplaintsList вместо ComplaintsView
    },
    {
      path: "/documents/:id",
      name: "DocumentDetail",
      component: () => import("@/views/DocumentDetail.vue"),
      props: true,
    },
    {
      path: '/documents/:id/complaint',
      name: 'ComplaintForm',
      component: () => import('@/views/ComplaintForm.vue'),
      props: true
    }

  ],
});

export default router;


Это код файла FatherGuard\frontend\src\stores\aiStore.js:
import { defineStore } from "pinia";
import axios from "axios";

export const useAIStore = defineStore("ai", {
  state: () => ({
    isLoading: false,
    error: null,
    apiStatus: "unknown", // 'ready', 'error', 'offline'
    apiUrl: "http://localhost:11434/api/generate",
    activeModel: "llama3.1:latest",
    
    agencies: ["ФССП", "Прокуратура", "Суд", "Омбудсмен"],
  }),

  actions: {
    /**
     * Фильтр для удаления предложений с латинскими символами (>15)
     */
    _filterLatinText(text) {
      if (!text) return text;

      return text
        .split(/(?<=[.!?])\s+/)
        .filter((sentence) => {
          const latinChars = (sentence.match(/[a-zA-Z]/g) || []).length;
          return latinChars <= 15;
        })
        .join(" ")
        .trim();
    },
    

    /**
     * Формат промптов
     */
    _formatPrompt(text, model, taskType = 'default') {
      
        const systemMessages = {
          summary: `<|begin_of_text|><|start_header_id|>system<|end_header_id|>
Ты — юридический ассистент. Сгенерируй краткую суть документа по правилам:
1. Только факты из текста (без рассуждений)
2. Объем: 3-5 предложений
3. Укажи ведомство-отправитель, если оно есть
4. Выдели дату документа, если указана
5. Формат: "Документ от [дата] от [ведомство]. [Суть]"
6. Без вступительных фраз

Текст:
${text.substring(0, 7000)}

Краткая суть:`,

          paragraphs: `<|begin_of_text|><|start_header_id|>system<|end_header_id|>
Выдели 3-5 УНИКАЛЬНЫХ ключевых цитат по правилам:
1. Только дословные цитаты в кавычках
2. Без повторов и похожих формулировок
3. Каждая с новой строки
4. Выделяй полные предложения (не обрезай)
5. Приоритет: цитаты с датами, номерами, ведомствами
6. Отвечай только на русском языке!
7. Без вступительных фраз!

Текст:
${text.substring(0, 7000)}

Ключевые цитаты:`,

          documentAnalysis: `<|begin_of_text|><|start_header_id|>system<|end_header_id|>
Проанализируй вложенный документ и верни JSON:
{
  "documentType": "тип (приказ, постановление и т.д.)",
  "sentDate": "дата в формате ДД.ММ.ГГГГ",
  "senderAgency": "ведомство-отправитель",
  "summary": "краткая суть (3-5 предложений)",
  "keyParagraphs": ["дословные цитаты"]
}

Текст:
${text.substring(0, 7000)}

Анализ:`,

          violations: `<|begin_of_text|><|start_header_id|>system<|end_header_id|>
Найди юридические нарушения в тексте. Формат:
- Закон: [название]
- Статья: [номер]
- Описание: [текст]
- Доказательство: [цитата (предложение полностью)]
<</SYS>>

Текст:
${text.substring(0, 7000)}

Выявленные нарушения:`
        };
        return systemMessages[taskType] || text;
      
      
    },

    /**
     * Проверка доступности AI сервера
     */
    async checkServerStatus() {
      try {
        const response = await axios.get("http://localhost:11434", {
          timeout: 3000,
        });
        this.apiStatus = response.status === 200 ? "ready" : "error";
        return this.apiStatus;
      } catch (error) {
        this.apiStatus = "offline";
        throw new Error("AI сервер недоступен");
      }
    },

    /**
     * Универсальный метод запроса к AI
     */
    async _makeAIRequest(prompt, model = this.activeModel, customOptions = {}, taskType = null) {
      const currentModel = model;
      const modelConfig = this.availableModels.find(m => m.name === currentModel)?.parameters || {};
      
      const payload = {
        model: currentModel,
        prompt: this._formatPrompt(prompt, currentModel, taskType),
        stream: false,
        options: {
          temperature: customOptions.temperature ?? modelConfig.temperature ?? 0.3,
          top_p: customOptions.top_p ?? modelConfig.top_p ?? 0.9,
          num_ctx: customOptions.num_ctx ?? modelConfig.num_ctx ?? 8192
        }
      };

      try {
        const response = await axios.post(
          this.apiUrl,
          payload,
          {
            timeout: 500000,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );

        if (!response.data?.response) {
          throw new Error("Некорректный ответ от сервера AI");
        }

        return response.data.response;
      } catch (error) {
        console.error("AI Request Error:", {
          config: error.config,
          response: error.response?.data,
          error: error.message
        });

        
      
      } finally {
        this.isLoading = false;
      }
    },

    /**
     * Генерация краткой сводки
     */
    async generateSummary(text) {
      try {
        const response = await this._makeAIRequest(
          text,
          this.activeModel,
          { temperature: 0.3 },
          'summary'
        );
        
        return response.split("\n")[0].replace(/^"|"$/g, "") ||
               "Не удалось сгенерировать краткую суть";
      } catch (error) {
        console.error("Ошибка генерации сводки:", error);
        return "Ошибка генерации краткой сводки";
      }
    },

    /**
     * Извлечение ключевых параграфов
     */
    async extractKeyParagraphs(text) {
      try {
        const response = await this._makeAIRequest(
          text,
          this.activeModel,
          { temperature: 0.3 },
          'paragraphs'
        );

        const paragraphs = (response || '').split('\n')
          .map(p => p.trim().replace(/^["']|["']$/g, ''))
          .filter(p => p.length > 10)
          .slice(0, 5);

        return paragraphs.length > 0 
          ? paragraphs 
          : ['Не удалось извлечь значимые цитаты'];
      } catch (error) {
        console.error('Ошибка extractKeyParagraphs:', error);
        return ['Ошибка обработки документа'];
      }
    },

    /**
     * Поиск юридических нарушений
     */
    async detectViolations(text) {
      try {
        return await this._makeAIRequest(
          text,
          this.activeModel,
          { temperature: 0.5 },
          'violations'
        );
      } catch (error) {
        console.error("Ошибка анализа нарушений:", error);
        return "Не удалось проанализировать нарушения. Проверьте текст документа.";
      }
    },

    /**
     * Анализ вложенного документа
     */
    async analyzeAttachment(text) {
      try {
        const response = await this._makeAIRequest(
          text,
          this.activeModel,
          { temperature: 0.2 },
          'documentAnalysis'
        );
        
        return typeof response === 'string' ? JSON.parse(response) : response;
      } catch (error) {
        console.error("Ошибка анализа вложения:", error);
        return {
          documentType: "Неизвестный тип",
          sentDate: "",
          senderAgency: "",
          summary: "Ошибка анализа документа",
          keyParagraphs: []
        };
      }
    },

    /**
     * Полный анализ документа
     */
    async analyzeDocument(text) {
      try {
        const [summary, paragraphs, violations] = await Promise.all([
          this.generateSummary(text),
          this.extractKeyParagraphs(text),
          this.detectViolations(text)
        ]);

        return {
          summary: summary || "Не удалось сгенерировать сводку",
          paragraphs: Array.isArray(paragraphs) ? paragraphs : ['Ошибка извлечения цитат'],
          violations: violations || 'Ошибка анализа нарушений',
          status: "complete"
        };
      } catch (error) {
        console.error("Ошибка анализа документа:", error);
        return {
          summary: "Системная ошибка анализа",
          paragraphs: ["Системная ошибка"],
          violations: "Системная ошибка",
          status: "error"
        };
      }
    },

    /**
     * Генерация жалобы
     */
    async generateComplaint(text, agency, violation = "") {
      if (!this.agencies.includes(agency)) {
        throw new Error("Указано недопустимое ведомство");
      }

      try {
        const prompt = `Сгенерируй официальную жалобу в ${agency} на основе документа.
                      ${violation ? `Выявленное нарушение:\n${violation}\n` : ""}
                      Текст документа:\n${text.substring(0, 3000)}`;

        return await this._makeAIRequest(
          prompt,
          this.activeModel,
          { temperature: 0.5 }
        );
      } catch (error) {
        console.error("Ошибка генерации жалобы:", error);
        return `В ${agency}\n\nЗаявитель: [ФИО]\n\nЖалоба на документ:\n${text.substring(0, 500)}\n\nТребования: Провести проверку\n\nДата: ${new Date().toLocaleDateString()}`;
      }
    },

    /**
     * Обработка параграфов
     */
    _postProcessParagraphs(text) {
      if (!text) return ["Не найдено значимых цитат"];
      
      return (text || '').split('\n')
        .map(p => {
          let cleaned = p.replace(/<\|.*?\|\>|```/g, '')
                       .replace(/^["']+|["']+$/g, '')
                       .trim();
          return cleaned.length > 15 ? cleaned : null;
        })
        .filter(Boolean)
        .filter((item, index, arr) => 
          index === arr.findIndex(i => i.substring(0, 50) === item.substring(0, 50))
        )
        .slice(0, 5);
    }
  },

  getters: {
    isServerOnline: (state) => state.apiStatus === "ready",
    activeModelName: (state) => {
      const model = state.activeModel
      
      return model ? model.description : "Неизвестная модель";
    },
  },
});

export default useAIStore


Это код файла FatherGuard\frontend\src\stores\complaintStore.js:
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import { v4 as uuidv4 } from "uuid";
import { saveAs } from "file-saver";
import { useDocumentStore } from "./documentStore";
import aiService from "../../../backend/services/aiService";
import { Packer } from "docx";
import { Document, Paragraph, TextRun } from "docx";

export const useComplaintStore = defineStore("complaint", () => {
  const documentStore = useDocumentStore();

  // Состояние
  const complaints = ref([]);
  const isLoading = ref(false);
  const error = ref(null);
  const isGenerating = ref(false);
  const isExporting = ref(false);
  const generatedComplaint = ref(null);

  // Геттеры
  const agenciesOptions = computed(() => [
    "Федеральная служба судебных приставов (ФССП)",
    "Прокуратура",
    "Суд (административное исковое заявление)",
    "Уполномоченный по правам человека (омбудсмен)",
  ]);

  const getComplaintsByDocument = computed(() => (documentId) => {
    return complaints.value.filter((c) => c.documentId === documentId);
  });

  // Действия
  const fetchComplaints = async () => {
    isLoading.value = true;
    try {
      // В реальном приложении здесь будет запрос к API
      // Для примера используем локальные данные
      complaints.value = JSON.parse(localStorage.getItem("complaints") || "[]");
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const generateComplaint = async (payload) => {
    isGenerating.value = true;
    error.value = null;

    try {
      const { documentId, agency, instructions } = payload;

      // Получаем документ и связанные документы
      const doc = await documentStore.fetchDocumentById(documentId);
      const relatedDocs = documentStore.documents.filter(
        (d) => d.date <= doc.date && d.id !== documentId
      );

      // Генерируем жалобу через AI сервис
      const result = await aiService.generateComplaint(
        doc.originalText,
        agency,
        relatedDocs.map((d) => d.originalText),
        instructions
      );

      // Формируем объект жалобы
      const newComplaint = {
        id: uuidv4(),
        documentId,
        agency,
        summary: complaintContent.summary, // Краткая суть (п.4)
        verbatimSections: complaintContent.verbatimSections, // Дословные параграфы (п.5)
        relatedDocuments: relatedDocs.map((d) => ({
          id: d.id,
          date: d.date, // Дата отправления (п.6а)
          agency: d.senderAgency, // Ведомство-отправитель (п.6б)
          summary: d.documentSummary, // Краткая суть документа (п.6в)
          text: d.fullText, // Полный текст (п.6г)
          verbatimSections: d.verbatimSections, // Дословные параграфы (п.6д)
        })),
        status: "draft",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Сохраняем в хранилище
      complaints.value.unshift(newComplaint);
      generatedComplaint.value = newComplaint;

      // Сохраняем в локальное хранилище (в реальном приложении - API запрос)
      localStorage.setItem("complaints", JSON.stringify(complaints.value));

      return newComplaint;
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isGenerating.value = false;
    }
  };

  const saveComplaint = async (complaintData) => {
    isLoading.value = true;
    try {
      const index = complaints.value.findIndex(
        (c) => c.id === complaintData.id
      );
      if (index !== -1) {
        complaints.value[index] = {
          ...complaints.value[index],
          ...complaintData,
          updatedAt: new Date().toISOString(),
        };
      } else {
        complaints.value.unshift({
          ...complaintData,
          id: uuidv4(),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        });
      }

      localStorage.setItem("complaints", JSON.stringify(complaints.value));
      return complaints.value[index !== -1 ? index : 0];
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const exportComplaint = async (complaintId, format = "txt") => {
    isExporting.value = true;
    try {
      const complaint = complaints.value.find((c) => c.id === complaintId);
      if (!complaint) throw new Error("Жалоба не найдена");

      if (format === "txt") {
        const blob = new Blob([complaint.content], { type: "text/plain" });
        saveAs(
          blob,
          `Жалоба_${complaint.agency}_${formatDate(complaint.createdAt)}.txt`
        );
        return blob;
      }

      if (format === "doc") {
        const doc = new Document({
          sections: [
            {
              properties: {},
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: complaint.content,
                      size: 24,
                    }),
                  ],
                }),
              ],
            },
          ],
        });

        const buffer = await Packer.toBuffer(doc);
        const blob = new Blob([buffer], {
          type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        });

        saveAs(
          blob,
          `Жалоба_${complaint.agency}_${formatDate(complaint.createdAt)}.docx`
        );
        return blob;
      }

      throw new Error("Неподдерживаемый формат экспорта");
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isExporting.value = false;
    }
  };

  const deleteComplaint = async (id) => {
    isLoading.value = true;
    try {
      complaints.value = complaints.value.filter((c) => c.id !== id);
      localStorage.setItem("complaints", JSON.stringify(complaints.value));
      return true;
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const updateComplaintStatus = async (id, status) => {
    try {
      const index = complaints.value.findIndex((c) => c.id === id);
      if (index !== -1) {
        complaints.value[index].status = status;
        complaints.value[index].updatedAt = new Date().toISOString();
        localStorage.setItem("complaints", JSON.stringify(complaints.value));
      }
      return complaints.value[index];
    } catch (err) {
      error.value = err.message;
      throw err;
    }
  };

  // Вспомогательные функции
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString("ru-RU");
  };

  return {
    // Состояние
    complaints,
    isLoading,
    error,
    isGenerating,
    isExporting,
    generatedComplaint,

    // Геттеры
    agenciesOptions,
    getComplaintsByDocument,

    // Действия
    fetchComplaints,
    generateComplaint,
    saveComplaint,
    exportComplaint,
    deleteComplaint,
    updateComplaintStatus,
  }
})

Это код файла FatherGuard\frontend\src\stores\documentStore.js:
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import axios from "axios";
import { useRouter } from "vue-router";
import { v4 as uuidv4 } from "uuid";
import { useAIStore } from "@/stores/aiStore";

export const useDocumentStore = defineStore("document", () => {
  const router = useRouter();
  const aiStore = useAIStore();
  const API_BASE = "http://localhost:3001";

  // Состояние хранилища

  const documents = ref([]);
  const isLoading = ref(false);
  const error = ref(null);
  const isAnalyzing = ref(false);


  const currentDocument = ref({
    id: uuidv4(),
    date: new Date().toISOString(), // Дата поступления (п.1)
    originalText: "", // Дословный текст (п.2)
    agencyTarget: "", // Ведомство (п.3)
    summary: "", // Краткая суть (п.4)
    keyParagraphs: [], // Существенные параграфы (п.5)
    // Расшифровка документа (п.6)
    documentDate: "",
    senderAgency: "",
    documentSummary: "",
    fullText: "",
    attachments: [],
    complaints: [],
    analysisStatus: "pending",
    lastAnalyzedAt: null,
    violations: [],
  });

  // Геттеры
  const agenciesList = computed(() => {
    const agencies = new Set(["ФССП", "Прокуратура", "Суд", "Омбудсмен"]);
    documents.value.forEach((doc) => {
      if (doc.agency) agencies.add(doc.agency);
      if (doc.senderAgency) agencies.add(doc.senderAgency);
    });
    return Array.from(agencies).sort();
  });

  const hasAttachments = computed(() => {
    return currentDocument.value.attachments?.length > 0;
  });

  const analyzedDocuments = computed(() => {
    return documents.value.filter((doc) => doc.analysisStatus === "completed");
  });

  // Действия
  const fetchDocuments = async () => {
    return handleApiCall(async () => {
      const { data } = await axios.get(`${API_BASE}/api/documents`);
      documents.value = data.items || data;
    });
  };

  const fetchDocumentById = async (id) => {
    return handleApiCall(async () => {
      const { data } = await axios.get(`${API_BASE}/api/documents/${id}`);
      currentDocument.value = normalizeDocumentData(data);
      return data;
    });
  };

  const uploadFiles = async (files) => {
    return handleApiCall(async () => {
      const formData = new FormData();
      if (currentDocument.value.originalText) {
        formData.append("text", currentDocument.value.originalText);
      }

      Array.from(files).forEach((file) => formData.append("files", file));

      const { data } = await axios.post(
        `${API_BASE}/api/documents/upload`,
        formData,
        { headers: { "Content-Type": "multipart/form-data" } }
      );

      currentDocument.value = {
        ...normalizeDocumentData(data),
        originalText: data.originalText || currentDocument.value.originalText,
      };
      return data;
    });
  };

  const saveDocument = async () => {
    return handleApiCall(async () => {
      const docToSave = prepareDocumentForSave(currentDocument.value);
      let savedDocument;

      if (docToSave.id) {
        const { data } = await axios.put(
          `${API_BASE}/api/documents/${docToSave.id}`,
          docToSave
        );
        savedDocument = data;
      } else {
        const { data } = await axios.post(
          `${API_BASE}/api/documents`,
          docToSave
        );
        savedDocument = data;
      }

      updateDocumentsList(savedDocument);
      currentDocument.value = normalizeDocumentData(savedDocument);
      return savedDocument;
    });
  };

  const deleteDocument = async (id) => {
    return handleApiCall(async () => {
      await axios.delete(`${API_BASE}/api/documents/${id}`);
      documents.value = documents.value.filter((doc) => doc.id !== id);

      if (currentDocument.value.id === id) {
        resetCurrentDocument();
      }
    });
  };

  const analyzeDocument = async () => {
    isAnalyzing.value = true;
    error.value = null;

    try {
      
      currentDocument.value.analysisStatus = "processing";
      await saveDocument();

      const analysis = await analyzeDocumentContent();
      const attachmentsAnalysis = await analyzeAttachments();

      currentDocument.value = {
        ...currentDocument.value,
        ...analysis,
        attachments: attachmentsAnalysis,
        analysisStatus: "completed",
        lastAnalyzedAt: new Date().toISOString(),
      };

      await saveDocument();
      return analysis;
    } catch (err) {
      currentDocument.value.analysisStatus = "failed";
      await saveDocument();
      throw err;
    } finally {
      isAnalyzing.value = false;
    }
  };

  // Вспомогательные функции

  const normalizeDocumentData = (data) => ({
    id: data.id || null,
    date: data.date || new Date().toISOString().split("T")[0],
    agency: data.agency || "", // старое поле (оставляем для обратной совместимости)
    agencyTarget: data.agencyTarget || "", // новое поле (п.3)
    originalText: data.originalText || "", // п.2
    summary: data.summary || "", // п.4
    keyParagraphs: data.keyParagraphs || [], // п.5
    // Поля для расшифровки документа (п.6)
    documentDate: data.documentDate || "",
    senderAgency: data.senderAgency || "",
    documentSummary: data.documentSummary || data.summary || "", // п.6в (используем summary если нет отдельного поля)
    fullText: data.fullText || data.originalText || "", // п.6г
    attachments:
      data.attachments?.map((att) => ({
        id: att.id || uuidv4(),
        name: att.name,
        type: att.type,
        size: att.size,
        path: att.path,
        text: att.text || "",
        analysis: att.analysis || null,
        // Добавляем поля для анализа вложений (п.6 для вложений)
        documentDate: att.documentDate || "",
        senderAgency: att.senderAgency || "",
        documentSummary: att.documentSummary || "",
        fullText: att.fullText || att.text || "",
        keyParagraphs: att.keyParagraphs || [],
      })) || [],
    complaints: data.complaints || [],
    analysisStatus: data.analysisStatus || "pending",
    lastAnalyzedAt: data.lastAnalyzedAt || null,
    violations: data.violations || [],
  });

  const prepareDocumentForSave = (doc) => ({
    ...doc,
    keyParagraphs: doc.keyParagraphs.filter((p) => p.trim()),
    attachments: doc.attachments.map((att) => ({
      id: att.id || uuidv4(),
      name: att.name,
      type: att.type,
      size: att.size,
      path: att.path,
      text: att.text || "",
      analysis: att.analysis || null,
    })),
  });

  const updateDocumentsList = (savedDocument) => {
    const index = documents.value.findIndex((d) => d.id === savedDocument.id);
    if (index !== -1) {
      documents.value[index] = savedDocument;
    } else {
      documents.value.unshift(savedDocument);
    }
  };

  const handleApiCall = async (apiFunction) => {
    isLoading.value = true;
    error.value = null;
    try {
      return await apiFunction();
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const analyzeDocumentContent = async () => {
    const docText = currentDocument.value.originalText;
    const [summary, paragraphs, violations, documentSummary] =
      await Promise.all([
        aiStore.generateSummary(docText),
        aiStore.extractKeyParagraphs(docText),
        aiStore.detectViolations(docText),
        aiStore.generateDocumentSummary(docText),
      ]);

    return {
      summary,
      keyParagraphs: paragraphs,
      violations,
      documentDate: extractDate(docText),
      senderAgency: extractAgency(docText),
      documentSummary,
      fullText: docText,
      agencyTarget: determineTargetAgency(docText),
    };
  };

  const determineTargetAgency = (text) => {
    const violations = text.match(/нарушен[ия]|незаконн|жалоб[аы]/gi);
    if (!violations) return "";

    if (text.includes("ФССП") || text.includes("судебн")) return "ФССП";
    if (text.includes("прокурор")) return "Прокуратура";
    if (text.includes("суд")) return "Суд";
    if (text.includes("омбудсмен")) return "Омбудсмен";

    return "ФССП"; // По умолчанию
  };

  const analyzeAttachments = async () => {
  if (!currentDocument.value.attachments?.length) return [];

  isAnalyzing.value = true;
  try {
    const updatedAttachments = await Promise.all(
      currentDocument.value.attachments.map(async (att) => {
        if (!att.text) return att;
        
        const analysis = await aiStore.analyzeAttachment(att.text);
        return {
          ...att,
          analysis,
          documentDate: extractDate(att.text),
          senderAgency: extractAgency(att.text),
          documentSummary: analysis.summary || "",
          fullText: att.text,
          keyParagraphs: analysis.paragraphs || []
        };
      })
    );

    currentDocument.value.attachments = updatedAttachments;
    return updatedAttachments;
  } catch (err) {
    error.value = 'Ошибка анализа вложений: ' + err.message;
    throw err;
  } finally {
    isAnalyzing.value = false;
  }
};

  const extractDate = (text) => {
    const dateRegex = /(\d{2}\.\d{2}\.\d{4})|(\d{4}-\d{2}-\d{2})/;
    const match = text.match(dateRegex);
    return match ? match[0] : "";
  };

  const extractAgency = (text) => {
    const agencies = ["ФССП", "Прокуратура", "Суд", "Омбудсмен"];
    return agencies.find((agency) => text.includes(agency)) || "";
  };

  const resetCurrentDocument = () => {
    currentDocument.value = createEmptyDocument();
  };

  const viewDocument = async (id) => {
    await fetchDocumentById(id);
    router.push(`/documents/${id}`);
  };

  const regenerateAttachmentAnalysis = async (attachmentId) => {
    const attachment = currentDocument.value.attachments.find(
      (a) => a.id === attachmentId
    );
    if (!attachment) return;

    try {
      const analysis = await aiStore.analyzeAttachment(attachment.text);
      const updatedAttachment = {
        ...attachment,
        analysis,
        documentDate: extractDate(attachment.text),
        senderAgency: extractAgency(attachment.text),
        documentSummary: analysis.summary || "",
        fullText: attachment.text,
        keyParagraphs: analysis.paragraphs || [],
      };

      const index = currentDocument.value.attachments.findIndex(
        (a) => a.id === attachmentId
      );
      currentDocument.value.attachments[index] = updatedAttachment;
      await saveDocument();

      return updatedAttachment;
    } catch (err) {
      error.value = "Ошибка перегенерации анализа вложения: " + err.message;
      throw err;
    }
  };

  const generateComplaint = async (documentId, agency) => {
    return handleApiCall(async () => {
      const doc = documents.value.find((d) => d.id === documentId);
      if (!doc) throw new Error("Документ не найден");

      const relatedDocs = documents.value.filter(
        (d) => d.date <= doc.date && d.id !== documentId
      );

      const { data } = await axios.post(`${API_BASE}/api/complaints`, {
        documentId,
        agency,
        relatedDocuments: relatedDocs.map((d) => d.id),
      });

      if (currentDocument.value.id === documentId) {
        currentDocument.value.complaints = [
          ...(currentDocument.value.complaints || []),
          data,
        ];
        await saveDocument();
      }

      return data;
    });
  };

  const fetchComplaints = async (documentId) => {
      return handleApiCall(async () => {
        const { data } = await axios.get(
          `${API_BASE}/api/documents/${documentId}/complaints`
        );

        if (currentDocument.value.id === documentId) {
          currentDocument.value.complaints = data;
        }

        return data;
      });
    }

  return {
    currentDocument,
    documents,
    isLoading,
    error,
    isAnalyzing,
    agenciesList,
    hasAttachments,
    analyzedDocuments,
    fetchDocuments,
    fetchDocumentById,
    uploadFiles,
    saveDocument,
    deleteDocument,
    analyzeDocument,
    regenerateAttachmentAnalysis,
    generateComplaint,
    fetchComplaints,
    resetCurrentDocument,
    viewDocument,
  }
})

Это код файла FatherGuard\frontend\src\views\ComplaintForm.vue: 
<!-- src/components/complaints/ComplaintForm.vue -->
<template>
  <div class="complaint-form">
    <div class="header">
      <button @click="goBack" class="back-button">← Назад</button>
      <h1>Создание жалобы</h1>
    </div>

    <div v-if="loading" class="loading">
      <p>Загрузка данных...</p>
    </div>
    
    <div v-else-if="error" class="error">
      <p>Ошибка: {{ error }}</p>
    </div>
    
    <div v-else class="complaint-form-content">
      <div class="document-preview">
        <h2>Документ для жалобы</h2>
        <div class="document-info">
          <div class="info-row">
            <span class="label">Дата поступления:</span>
            <span class="value">{{ formatDate(document.date) }}</span>
          </div>
          <div class="info-row">
            <span class="label">Ведомство:</span>
            <span class="value">{{ document.agency || 'Не указано' }}</span>
          </div>
          <div class="info-row">
            <span class="label">Дата документа:</span>
            <span class="value">{{ document.documentDate || 'Не указана' }}</span>
          </div>
          <div class="info-row">
            <span class="label">Краткая суть:</span>
            <span class="value">{{ document.summary || 'Нет краткой сводки' }}</span>
          </div>
        </div>
      </div>

      <div class="agency-selection">
        <h2>Выберите ведомство</h2>
        <select v-model="selectedAgency" @change="onAgencyChange" class="agency-select">
          <option value="">-- Выберите ведомство --</option>
          <option 
            v-for="agency in agenciesOptions" 
            :key="agency" 
            :value="agency"
          >
            {{ agency }}
          </option>
        </select>
      </div>

      <div class="instructions-section">
        <h2>Дополнительные инструкции</h2>
        <textarea 
          v-model="customInstructions" 
          placeholder="Введите дополнительные инструкции для нейросети (необязательно)"
          class="instructions-input"
          rows="4"
        ></textarea>
      </div>

      <div class="actions">
        <button 
          @click="generateComplaint" 
          :disabled="isGenerating || !selectedAgency"
          class="generate-btn"
        >
          {{ isGenerating ? 'Генерация...' : 'Создать жалобу' }}
        </button>
        <button @click="goBack" class="cancel-btn">Отмена</button>
      </div>

      <div v-if="generatedComplaint" class="complaint-result">
        <h2>Сгенерированная жалоба</h2>
        <div class="complaint-content">
          <pre>{{ generatedComplaint }}</pre>
        </div>
        <div class="result-actions">
          <button @click="copyToClipboard" class="copy-btn">Копировать</button>
          <button @click="saveComplaint" class="save-btn">Сохранить в документ</button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="2000"
      @close="showNotification = false"
    />
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'
import NotificationToast from '@/components/ui/NotificationToast.vue'

const route = useRoute()
const router = useRouter()
const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()

// Состояния (все в Pinia store)
const selectedAgency = ref('')
const customInstructions = ref('')
const generatedComplaint = ref(null)

// Геттеры из store
const agenciesOptions = computed(() => complaintStore.agenciesOptions)
const isGenerating = computed(() => complaintStore.isGenerating)
const loading = computed(() => documentStore.loading)
const error = computed(() => documentStore.error)

// Методы из store
const formatDate = (dateString) => {
  return dateString ? new Date(dateString).toLocaleDateString('ru-RU') : 'Дата не указана'
}

const onAgencyChange = () => {
  // Логика при изменении выбора ведомства
}

const generateComplaint = async () => {
  if (!selectedAgency.value) return
  
  try {
    const payload = {
      documentId: route.params.id,
      agency: selectedAgency.value,
      instructions: customInstructions.value
    }
    
    // Используем метод из store
    await complaintStore.generateComplaint(payload)
    generatedComplaint.value = complaintStore.generatedComplaint
    
    // Сбросим состояние после успешной генерации
    selectedAgency.value = ''
    customInstructions.value = ''
  } catch (err) {
    console.error('Ошибка генерации жалобы:', err)
    // Обработка ошибки через store или уведомления
  }
}

const copyToClipboard = () => {
  if (generatedComplaint.value) {
    navigator.clipboard.writeText(generatedComplaint.value)
    // Уведомление через store
  }
}

const saveComplaint = async () => {
  if (!generatedComplaint.value) return
  
  try {
    const complaintData = {
      documentId: route.params.id,
      agency: selectedAgency.value,
      content: generatedComplaint.value,
      status: 'draft'
    }
    
    await complaintStore.saveComplaintToDocument(complaintData)
    
    // После сохранения обновляем документ
    await documentStore.fetchDocumentById(route.params.id)
    router.push(`/documents/${route.params.id}`)
  } catch (err) {
    console.error('Ошибка сохранения жалобы:', err)
  }
}

const goBack = () => {
  router.push(`/documents/${route.params.id}`)
}

// Загрузка данных документа
onMounted(async () => {
  try {
    await documentStore.fetchDocumentById(route.params.id)
  } catch (err) {
    console.error('Ошибка загрузки документа:', err)
  }
})
</script>

Это код файла FatherGuard\frontend\src\views\ComplaintsList.vue:
<template>
  <div class="complaints-list">
    <div class="header">
      <h1>Сформированные жалобы</h1>
      <router-link to="/documents" class="back-btn">← К документам</router-link>
    </div>

    <!-- Отладочная информация -->
    <div v-if="debugMode" class="debug-info">
      <pre>Store state: {{ JSON.stringify(complaintStore.$state, null, 2) }}</pre>
    </div>

    <div v-if="isLoading" class="loading">
      <p>Загрузка жалоб...</p>
      <progress indeterminate></progress>
    </div>

    <div v-else-if="!complaints.length" class="empty">
      <p>Нет сформированных жалоб</p>
      <router-link to="/" class="create-link">Создать первую жалобу</router-link>
    </div>

    <ul v-else class="complaints">
      <li v-for="complaint in complaints" :key="complaint.id" class="complaint-item">
        <div class="complaint-card">
          <h3>{{ complaint.agency }}</h3>
          <p class="date">{{ formatDate(complaint.createdAt) }}</p>
          <p class="preview">{{ complaint.content.substring(0, 100) }}...</p>
          <div class="actions">
            <button @click="exportComplaint(complaint.id, 'txt')" class="export-btn">
              TXT
            </button>
            <button @click="exportComplaint(complaint.id, 'doc')" class="export-btn">
              DOC
            </button>
            <button 
              @click.stop="confirmDelete(complaint)" 
              class="delete-btn"
            >
              Удалить
            </button>
          </div>
        </div>
      </li>
    </ul>

    <!-- Модальное окно подтверждения удаления -->
    <div v-if="showDeleteModal" class="modal-overlay">
      <div class="modal-content">
        <h3>Подтверждение удаления</h3>
        <p>Вы уверены, что хотите удалить жалобу в "{{ complaintToDelete?.agency }}"?</p>
        <div class="modal-actions">
          <button @click="deleteComplaint" class="confirm-btn">Да, удалить</button>
          <button @click="showDeleteModal = false" class="cancel-btn">Отмена</button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="1500"
      @close="showNotification = false"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useComplaintStore } from '@/stores/complaintStore'
import { saveAs } from 'file-saver'
import NotificationToast from '@/components/ui/NotificationToast.vue'


const analyzeBailiffAction = async (text) => {
  try {
    const analysis = await complaintStore.analyzeLegalText(text);
    
    if (analysis.violations.some(v => v.side === 'пристав')) {
      useToast().show({
        title: "Нарушение ФЗ 'О судебных приставах'",
        message: `Статья ${analysis.violations[0].article}`,
        variant: "warning"
      });
    }
    
    return {
      payerTips: analysis.recommendations.payer,
      bailiffWarnings: analysis.violations
        .filter(v => v.side === 'пристав')
    };
  } catch (error) {
    useToast().error("Ошибка анализа алиментного дела");
    throw error;
  }
};


// Debug
const debugMode = ref(false)

// Store
const complaintStore = useComplaintStore()
const isLoading = ref(false)
const complaints = computed(() => complaintStore.complaints || [])

// Удаление жалоб
const showDeleteModal = ref(false)
const complaintToDelete = ref(null)
const showNotification = ref(false)
const notificationMessage = ref('')
const notificationType = ref('success')

const confirmDelete = (complaint) => {
  complaintToDelete.value = complaint
  showDeleteModal.value = true
}

const deleteComplaint = async () => {
  if (complaintToDelete.value) {
    try {
      await complaintStore.deleteComplaint(complaintToDelete.value.id)
      notificationMessage.value = 'Жалоба успешно удалена'
      notificationType.value = 'success'
    } catch (error) {
      notificationMessage.value = 'Ошибка при удалении жалобы'
      notificationType.value = 'error'
      console.error('Ошибка удаления:', error)
    } finally {
      showNotification.value = true
      showDeleteModal.value = false
    }
  }
}

// Методы


const analyzeDocument = async (documentId) => {
  try {
    const doc = await fetchDocument(documentId); // Ваш метод загрузки документа
    const analysis = await complaintStore.analyzeLegalText(doc.content);
    
    useToast().show({
      title: "Анализ завершен",
      message: `Найдено нарушений: ${analysis.violations.length}`,
      variant: analysis.violations.length ? "danger" : "success"
    });

    return analysis;
  } catch (error) {
    useToast().show({
      title: "Ошибка анализа",
      message: error.message,
      variant: "error"
    });
  }
};



const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const exportComplaint = async (complaintId, format) => {
  try {
    const blob = await complaintStore.exportComplaint(complaintId, format)
    const complaint = complaints.value.find(c => c.id === complaintId)
    const filename = `Жалоба_${complaint.agency}_${formatDate(complaint.createdAt)}.${format}`
    saveAs(blob, filename)
  } catch (error) {
    console.error('Export error:', error)
    notificationMessage.value = 'Ошибка при экспорте'
    notificationType.value = 'error'
    showNotification.value = true
  }
}

// Lifecycle
onMounted(async () => {
  isLoading.value = true
  try {
    await complaintStore.fetchComplaints()
  } catch (error) {
    console.error('Failed to load complaints:', error)
    notificationMessage.value = 'Ошибка загрузки жалоб'
    notificationType.value = 'error'
    showNotification.value = true
  } finally {
    isLoading.value = false
  }
})
</script>

Это код файла FatherGuard\frontend\src\views\DocumentDetail.vue:
<!-- src/views/DocumentDetail.vue -->
<template>
  <div class="document-detail">
    <button @click="goBack" class="back-button">← Назад к списку</button>
    
    <div v-if="loading" class="loading-state">
      <p>Загрузка документа...</p>
    </div>
    <div v-else-if="error" class="error-state">
      <p>Ошибка загрузки: {{ error }}</p>
    </div>
    <div v-else-if="!document" class="empty-state">
      <p>Документ не найден</p>
    </div>
    <div v-else class="document-content">
      <div class="document-header">
        <h1>Документ #{{ document.id }}</h1>
        <span class="document-date">{{ formatDate(document.date) }}</span>
      </div>
      <div class="document-meta">
        <div v-if="document.agency" class="meta-field">
          <span class="meta-label">Ведомство:</span>
          <span class="meta-value">{{ document.agency }}</span>
        </div>
        
        <div class="meta-field">
          <span class="meta-label">Дата создания:</span>
          <span class="meta-value">{{ formatDateTime(document.createdAt) }}</span>
        </div>
      </div>
      
      <!-- Кнопка создания жалобы -->
      <div class="complaint-action">
        <button @click="createComplaint" class="create-complaint-btn">
          Создать жалобу
        </button>
      </div>
      
      <div class="document-section">
        <h2>Исходный текст</h2>
        <pre class="original-text">{{ document.originalText }}</pre>
      </div>
      <div v-if="document.summary" class="document-section">
        <h2>Краткое содержание</h2>
        <p class="summary-text">{{ document.summary }}</p>
      </div>
      <div v-if="document.keyParagraphs?.length" class="document-section">
        <h2>Ключевые параграфы</h2>
        <ul class="paragraphs-list">
          <li v-for="(para, index) in document.keyParagraphs" :key="index">
            {{ para }}
          </li>
        </ul>
      </div>
      <div v-if="document.attachments?.length" class="document-section">
        <h2>Прикрепленные файлы</h2>
        <div class="attachments-list">
          <div v-for="file in document.attachments" :key="file.id" class="attachment-item">
            <div class="attachment-info">
              <span class="attachment-name">{{ file.name }}</span>
              <span class="attachment-size">{{ formatFileSize(file.size) }}</span>
            </div>
            <a 
              :href="getFileUrl(file.path)" 
              target="_blank"
              class="download-button"
            >
              Скачать
            </a>
          </div>
        </div>
      </div>
      <div v-if="document.comments" class="document-section">
        <h2>Комментарии</h2>
        <p class="comments-text">{{ document.comments }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/documentStore'

const route = useRoute()
const router = useRouter()
const documentStore = useDocumentStore()

const document = ref(null)
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    loading.value = true
    error.value = null
    await documentStore.fetchDocumentById(route.params.id)
    document.value = { ...documentStore.currentDocument }
  } catch (err) {
    error.value = err.message || 'Не удалось загрузить документ'
    console.error('Ошибка загрузки документа:', err)
  } finally {
    loading.value = false
  }
})

const formatDate = (dateString) => {
  return dateString ? new Date(dateString).toLocaleDateString('ru-RU') : 'Дата не указана'
}

const formatDateTime = (dateString) => {
  if (!dateString) return 'Дата не указана'
  const options = {
    day: 'numeric',
    month: 'numeric',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  }
  return new Date(dateString).toLocaleString('ru-RU', options)
}

const formatFileSize = (bytes) => {
  if (!bytes) return '0 KB'
  return `${(bytes / 1024).toFixed(2)} KB`
}

const getFileUrl = (path) => {
  return path.startsWith('http') ? path : `http://localhost:3001${path}`
}

const goBack = () => {
  router.push('/documents')
}

const createComplaint = () => {
  router.push(`/documents/${route.params.id}/complaint`)
}
</script>

Это код файла FatherGuard\frontend\src\views\DocumentReview.vue:
<template>
  <div class="document-review">
    <div class="header">
      <h1>Предпросмотр документа</h1>
      <button @click="goBack" class="back-button">← Назад</button>
    </div>

    <div v-if="isLoading" class="loading-state">
      <div class="spinner"></div>
      <p>Загрузка данных...</p>
    </div>

    <div v-else class="review-container">
      <form @submit.prevent="handleSubmit" class="review-form">
        <!-- Основные поля -->
        <div class="form-section">
          <h2>Основная информация</h2>
          <div class="form-group">
            <label for="date">Дата поступления:</label>
            <input type="date" id="date" v-model="document.date" required class="form-input" />
          </div>

          <div class="form-group">
            <label for="agency">Ведомство, допустившее нарушение:</label>
            <input type="text" id="agency" v-model="document.agency" list="agencies" required class="form-input"
              placeholder="Выберите ведомство" />
            <datalist id="agencies">
              <option v-for="agency in agenciesList" :key="agency">{{ agency }}</option>
            </datalist>
          </div>

          <div class="form-group">
            <label for="originalText">Текст документа:</label>
            <textarea id="originalText" v-model="document.originalText" required class="form-textarea" rows="8"
              placeholder="Введите текст документа"></textarea>
          </div>
        </div>

        <div class="form-group">
          <label for="agencyTarget">Ведомство для жалобы:</label>
          <input type="text" id="agencyTarget" v-model="document.agencyTarget" list="agencies" required
            class="form-input" placeholder="Выберите ведомство" />
        </div>

        <!-- Анализ документа -->
        <div class="form-section" v-if="document.analysisStatus !== 'pending'">
          <h2>Анализ документа</h2>

          <div class="form-group" v-if="document.analysisStatus === 'completed'">
            <label>Краткая суть:</label>
            <div class="summary-container">
              <textarea v-model="document.summary" required class="form-textarea" rows="3"
                placeholder="Анализ выполняется..."></textarea>
              <button type="button" @click="regenerateSummary" class="refresh-btn" :disabled="aiStore.isLoading"
                title="Перегенерировать краткую суть">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                  <path d="M3 3v5h5" />
                  <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
                  <path d="M16 16h5v5" />
                </svg>
              </button>
            </div>
          </div>

          <div class="form-group">
            <label>Дата отправления документа:</label>
            <input v-model="document.documentDate" type="date" class="form-input" />
          </div>

          <div class="form-group">
            <label>Ведомство-отправитель:</label>
            <input v-model="document.senderAgency" class="form-input" list="agencies" />
          </div>

          <!-- Ключевые параграфы -->
          <div class="form-group" v-if="document.keyParagraphs?.length">
            <label>Существенные параграфы:</label>
            <div v-for="(paragraph, index) in document.keyParagraphs" :key="index" class="paragraph-item">
              <textarea v-model="document.keyParagraphs[index]" required class="form-textarea" rows="3"></textarea>
              <button type="button" @click="removeParagraph(index)" class="remove-btn" title="Удалить параграф">
                ×
              </button>
            </div>
            <button type="button" @click="addParagraph" class="add-btn" title="Добавить параграф">
              + Добавить параграф
            </button>
          </div>
        </div>

        <!-- Вложения -->
        <div class="form-section" v-if="document.attachments?.length">
          <h2>Вложенные документы</h2>
          <div v-for="(attachment, idx) in document.attachments" :key="attachment.id || idx"
            class="attachment-analysis">
            <div class="attachment-header">
              <h3>{{ attachment.name }}</h3>
              <span class="file-size">{{ formatFileSize(attachment.size) }}</span>
              <button @click="regenerateAttachmentAnalysis(attachment.id)" class="refresh-btn" :disabled="isAnalyzing"
                title="Переанализировать документ">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                  <path d="M3 3v5h5" />
                  <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
                  <path d="M16 16h5v5" />
                </svg>
              </button>
            </div>

            <div v-if="attachment.analysis" class="attachment-details">
              <div class="detail-row">
                <span class="detail-label">Тип документа:</span>
                <span>{{ attachment.analysis.documentType || 'Не указан' }}</span>
              </div>
              <div class="detail-row">
                <span class="detail-label">Дата отправления:</span>
                <input type="date" v-model="attachment.documentDate" class="form-input small">
              </div>
              <div class="detail-row">
                <span class="detail-label">Ведомство-отправитель:</span>
                <input v-model="attachment.senderAgency" class="form-input small" list="agencies">
              </div>
              <div class="detail-row full-width">
                <span class="detail-label">Краткая суть:</span>
                <textarea v-model="attachment.documentSummary" class="form-textarea" rows="3"></textarea>
              </div>
              <div class="detail-row full-width">
                <span class="detail-label">Полный текст:</span>
                <textarea v-model="attachment.fullText" class="form-textarea" rows="6" readonly></textarea>
              </div>

              <div class="key-paragraphs">
                <h4>Ключевые параграфы:</h4>
                <div v-for="(paragraph, index) in attachment.keyParagraphs" :key="index" class="paragraph-item">
                  <textarea v-model="attachment.keyParagraphs[index]" class="form-textarea" rows="2"></textarea>
                  <button type="button" @click="removeAttachmentParagraph(attachment.id, index)" class="remove-btn"
                    title="Удалить параграф">
                    ×
                  </button>
                </div>
                <button type="button" @click="addAttachmentParagraph(attachment.id)" class="add-btn"
                  title="Добавить параграф">
                  + Добавить параграф
                </button>
              </div>
            </div>
            <div v-else class="no-analysis">
              <p>Анализ не выполнен</p>
              <button @click="analyzeAttachment(attachment)" class="analyze-btn" :disabled="isAnalyzing">
                Анализировать
              </button>
            </div>
          </div>
        </div>



        <!-- Кнопки действий -->
        <div class="form-actions">
          <button type="button" @click="analyzeDocument" class="analyze-btn"
            :disabled="isAnalyzing || !document.originalText">
            <span v-if="isAnalyzing" class="button-loader"></span>
            {{ isAnalyzing ? 'Анализ...' : 'Анализировать документ' }}
          </button>

          <button type="submit" class="save-btn" :disabled="isSaving">
            {{ isSaving ? 'Сохранение...' : 'Сохранить документ' }}
          </button>
        </div>
      </form>

      <!-- Блок статуса -->
      <div class="status-section">
        <div class="status-indicator" :class="document.analysisStatus">
          Статус анализа:
          <span>{{ getStatusText(document.analysisStatus) }}</span>
        </div>
        <div v-if="document.lastAnalyzedAt" class="last-analyzed">
          Последний анализ: {{ formatDate(document.lastAnalyzedAt) }}
        </div>
      </div>

      <!-- Уведомления об ошибках -->
      <div v-if="error" class="error-message">
        <div class="error-content">
          <span class="error-icon">!</span>
          <span>{{ error }}</span>
          <button @click="error = null" class="close-error" title="Закрыть">×</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAIStore } from '@/stores/aiStore'
import { useDocumentStore } from '@/stores/documentStore'

const router = useRouter()
const aiStore = useAIStore()
const documentStore = useDocumentStore()

const isLoading = ref(true)
const isSaving = ref(false)
const isAnalyzing = ref(false)
const error = ref(null)

const document = ref({
  ...documentStore.currentDocument
})

const agenciesList = computed(() => documentStore.agenciesList)

onMounted(async () => {
  try {
    await aiStore.checkServerStatus()

    if (!document.value.id && !document.value.originalText) {
      router.push('/')
      return
    }

    if (document.value.id) {
      await documentStore.fetchDocumentById(document.value.id)
      document.value = {
        ...documentStore.currentDocument,
        attachments: documentStore.currentDocument.attachments?.map(att => ({
          ...att,
          analysis: att.analysis || null
        })) || []
      }
    }
  } catch (err) {
    error.value = 'Ошибка загрузки: ' + err.message
  } finally {
    isLoading.value = false
  }
})

const addAttachmentParagraph = (attachmentId) => {
  const attachment = document.value.attachments.find(a => a.id === attachmentId);
  if (attachment) {
    if (!attachment.keyParagraphs) {
      attachment.keyParagraphs = [];
    }
    attachment.keyParagraphs.push('');
  }
};

const removeAttachmentParagraph = (attachmentId, index) => {
  const attachment = document.value.attachments.find(a => a.id === attachmentId);
  if (attachment && attachment.keyParagraphs) {
    attachment.keyParagraphs.splice(index, 1);
  }
};

// Обновленный метод анализа вложения
const analyzeAttachment = async (attachment) => {
  if (!attachment.text) return;
  
  isAnalyzing.value = true;
  try {
    const analysis = await documentStore.analyzeAttachment(attachment);
    const index = document.value.attachments.findIndex(a => a.id === attachment.id);
    if (index !== -1) {
      document.value.attachments[index] = {
        ...document.value.attachments[index],
        ...analysis
      };
    }
  } catch (err) {
    error.value = 'Ошибка анализа вложения: ' + err.message;
  } finally {
    isAnalyzing.value = false;
  }
};

// Метод для перегенерации анализа
const regenerateAttachmentAnalysis = async (attachmentId) => {
  isAnalyzing.value = true;
  try {
    const updatedAttachment = await documentStore.regenerateAttachmentAnalysis(attachmentId);
    const index = document.value.attachments.findIndex(a => a.id === attachmentId);
    if (index !== -1) {
      document.value.attachments[index] = updatedAttachment;
    }
  } catch (err) {
    error.value = 'Ошибка перегенерации анализа: ' + err.message;
  } finally {
    isAnalyzing.value = false;
  }
}

const addParagraph = () => {
  document.value.keyParagraphs.push('')
}

const removeParagraph = (index) => {
  document.value.keyParagraphs.splice(index, 1)
}

const analyzeDocument = async () => {
  isAnalyzing.value = true
  error.value = null

  try {
    const analysis = await documentStore.analyzeDocument()

    document.value = {
      ...document.value,
      summary: analysis.summary,
      keyParagraphs: analysis.paragraphs,
      documentDate: analysis.documentDate || '',
      senderAgency: analysis.senderAgency || '',
      analysisStatus: 'completed',
      lastAnalyzedAt: new Date().toISOString()
    }
  } catch (err) {
    error.value = 'Ошибка анализа: ' + err.message
  } finally {
    isAnalyzing.value = false
  }
}


const regenerateSummary = async () => {
  isAnalyzing.value = true
  try {
    document.value.summary = await aiStore.generateSummary(document.value.originalText)
  } catch (err) {
    error.value = 'Ошибка перегенерации: ' + err.message
  } finally {
    isAnalyzing.value = false
  }
}

const handleSubmit = async () => {
  isSaving.value = true
  error.value = null

  try {
    documentStore.currentDocument = document.value
    await documentStore.saveDocument()
    router.push('/documents')
  } catch (err) {
    error.value = 'Ошибка сохранения: ' + err.message
  } finally {
    isSaving.value = false
  }
}

const goBack = () => {
  router.push('/')
}

const formatDate = (dateString) => {
  if (!dateString) return ''
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const formatFileSize = (bytes) => {
  if (!bytes) return '0 KB'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i]
  )
}

const getStatusText = (status) => {
  const statusMap = {
    pending: 'Ожидает анализа',
    processing: 'В процессе',
    completed: 'Завершён',
    failed: 'Ошибка'
  }
  return statusMap[status] || status
}
</script>

Это код файла FatherGuard\frontend\src\views\DocumentsList.vue:
<template>
  <div class="documents-list">
    <div class="header">
      <h1>Архив входящих документов</h1>
      <router-link to="/" class="new-doc-btn">+ Новый документ</router-link>
    </div>

    <div class="filters">
      <input v-model="searchQuery" type="text" placeholder="Поиск по тексту" class="search-input" />
      <select v-model="selectedAgency" class="agency-select">
        <option value="">Все ведомства</option>
        <option v-for="agency in agenciesList" :key="agency" :value="agency">
          {{ agency }}
        </option>
      </select>
      <button @click="applyFilters" class="filter-btn">Применить</button>
      <button @click="resetFilters" class="filter-btn">Сбросить</button>
    </div>

    <div v-if="isLoading" class="loading">Загрузка документов...</div>
    <div v-else-if="filteredDocuments.length === 0" class="empty">
      Нет документов, соответствующих фильтрам
    </div>


    <ul v-else class="documents">
      <li 
        v-for="doc in filteredDocuments" 
        :key="doc.id" 
        class="document-item"
      >
        <div class="document-main" @click="viewDocument(doc.id)">
          <div class="document-meta">
            <span class="document-date">{{ formatDate(doc.date) }}</span>
            <span class="document-agency">{{ doc.agency }}</span>
          </div>
          <p class="document-summary">
            {{ doc.summary || doc.originalText.substring(0, 100) + '...' }}
          </p>
        </div>
        <div class="document-actions">
          <button 
            @click.stop="analyzeDocument(doc.id)" 
            class="analyze-btn" 
            :disabled="isAnalyzing"
          >
            {{ isAnalyzing ? 'Анализ...' : 'Проверить законность' }}
          </button>
          <button 
            @click.stop="confirmDelete(doc.id)" 
            class="delete-btn"
          >
            Удалить
          </button>
        </div>
      </li>
    </ul>


    <!-- Модальное окно подтверждения удаления -->
    <div v-if="showDeleteModal" class="modal-overlay">
      <div class="modal-content">
        <h3>Подтверждение удаления</h3>
        <p>Вы уверены, что хотите удалить этот документ?</p>
        <div class="modal-actions">
          <button @click="deleteDocument" class="confirm-btn">Да, удалить</button>
          <button @click="showDeleteModal = false" class="cancel-btn">Отмена</button>
        </div>
      </div>
    </div>



    <div v-if="showComplaintDialog" class="complaint-dialog">
      <div class="dialog-content">
        <h3>Выберите ведомство для жалобы</h3>
        <select v-model="selectedComplaintAgency" class="agency-select">
          <option v-for="agency in complaintAgencies" :key="agency" :value="agency">
            {{ agency }}
          </option>
        </select>
        <div class="dialog-actions">
          <button @click="generateComplaint" class="action-btn primary">
            Сформировать жалобу
          </button>
          <button @click="showComplaintDialog = false" class="action-btn">
            Отмена
          </button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="1500"
      @close="showNotification = false"
    />

  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'
import { useRouter } from 'vue-router'
import NotificationToast from '@/components/ui/NotificationToast.vue'

const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()
const router = useRouter()
const showNotification = ref(false)
const notificationMessage = ref('')
const notificationType = ref('success')

const isLoading = ref(false)
const isAnalyzing = ref(false)
const searchQuery = ref('')
const selectedAgency = ref('')
const showComplaintDialog = ref(false)
const selectedComplaintAgency = ref('')
const currentDocumentId = ref(null)

// Для удаления документов
const showDeleteModal = ref(false)
const documentToDelete = ref(null)

const confirmDelete = (id) => {
  documentToDelete.value = id
  showDeleteModal.value = true
}

const deleteDocument = async () => {
  if (documentToDelete.value) {
    try {
      await documentStore.deleteDocument(documentToDelete.value)
      await documentStore.fetchDocuments()
      
      // Показываем уведомление
      notificationMessage.value = 'Документ успешно удалён'
      notificationType.value = 'success'
      showNotification.value = true
    } catch (error) {
      console.error('Ошибка удаления:', error)
      
      // Уведомление об ошибке
      notificationMessage.value = 'Ошибка при удалении документа'
      notificationType.value = 'error'
      showNotification.value = true
    }
  }
  showDeleteModal.value = false
}


const viewDocument = (id) => {
  router.push(`/documents/${id}`)
}

// Загружаем документы при монтировании
onMounted(async () => {
  isLoading.value = true
  try {
    await documentStore.fetchDocuments()
  } finally {
    isLoading.value = false
  }
})

// Получаем список ведомств
const agenciesList = computed(() => documentStore.agenciesList)

// Фильтрация документов
const filteredDocuments = computed(() => {
  return documentStore.documents.filter((doc) => {
    const matchesSearch =
      searchQuery.value === '' ||
      doc.summary.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
      doc.originalText.toLowerCase().includes(searchQuery.value.toLowerCase())

    const matchesAgency =
      selectedAgency.value === '' || doc.agency === selectedAgency.value

    return matchesSearch && matchesAgency
  })
})

// Варианты ведомств для жалоб
const complaintAgencies = computed(() => complaintStore.agenciesOptions)

const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const applyFilters = () => {
  // Фильтрация происходит автоматически через computed свойство
}

const resetFilters = () => {
  searchQuery.value = ''
  selectedAgency.value = ''
}

const analyzeDocument = async (docId) => {
  isAnalyzing.value = true
  currentDocumentId.value = docId
  try {
    // Здесь будет вызов API к нейросети для анализа нарушений
    // После анализа показываем диалог выбора ведомства
    showComplaintDialog.value = true
  } catch (error) {
    console.error('Ошибка анализа:', error)
  } finally {
    isAnalyzing.value = false
  }
}

const generateComplaint = async () => {
  if (!selectedComplaintAgency.value || !currentDocumentId.value) return

  try {
    await complaintStore.generateAIComplaint(
      currentDocumentId.value,
      selectedComplaintAgency.value
    )
    router.push('/complaints')
  } catch (error) {
    console.error('Ошибка генерации жалобы:', error)
  } finally {
    showComplaintDialog.value = false
  }
}
</script>


Это код файла FatherGuard\frontend\src\views\HomeView.vue: 
<template>
  <div class="home-view">
    <h1>Изложите суть Вашей ситуации:</h1>
    <textarea 
      v-model="userText" 
      placeholder="Подробно опишите вашу ситуацию..."
      class="text-input"
    ></textarea>
    
    <div class="upload-section">
      <p>Приложите входящие документы (.txt / .pdf)</p>
      <FileUpload 
        label="Загрузить документы"
        @files-selected="handleFilesSelected"
        accept=".txt,.pdf"
      />
      <div v-if="files.length > 0" class="files-preview">
        <p>Выбранные файлы: {{ files.map(f => f.name).join(', ') }}</p>
      </div>
    </div>

    <button 
      @click="submitData"
      :disabled="!isFormValid || isLoading"
      class="submit-btn"
    >
      <span v-if="!isLoading">Продолжить</span>
      <span v-else>Обработка...</span>
    </button>

    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useRouter } from 'vue-router';
import FileUpload from '@/components/common/FileUpload.vue';
import { useDocumentStore } from '@/stores/documentStore';

const documentStore = useDocumentStore();
const router = useRouter();
const userText = ref('');
const files = ref([]);
const isLoading = ref(false);
const errorMessage = ref('');

const handleFilesSelected = (selectedFiles) => {
  files.value = selectedFiles;
  errorMessage.value = '';
};

const isFormValid = computed(() => {
  return userText.value.trim() !== '' || files.value.length > 0;
});

const submitData = async () => {
  if (!isFormValid.value || isLoading.value) return;

  isLoading.value = true;
  errorMessage.value = '';

  try {
    // Инициализируем новый документ с полной структурой
    const newDocument = {
      id: null, // Будет установлен при сохранении
      dateReceived: new Date().toISOString().split('T')[0],
      agency: '',
      originalText: userText.value,
      summary: '',
      documentDate: '',
      senderAgency: '',
      keyParagraphs: [],
      attachments: [],
      comments: userText.value,
      complaints: [],
      analysisStatus: 'pending',
      lastAnalyzedAt: null
    };

    // Обновляем документ в хранилище
    documentStore.currentDocument = newDocument;

    // Загружаем файлы (если есть)
    if (files.value.length > 0) {
      await documentStore.uploadFiles(files.value);
      // Предполагаем, что uploadFiles обновляет currentDocument.attachments
    }

    // Сохраняем документ
    const savedDoc = await documentStore.saveDocument();
    
    if (savedDoc?.id) {
      router.push({ 
        name: 'review', 
        params: { id: savedDoc.id },
        query: { new: 'true' }  
      });
    } else {
      throw new Error('Документ не был сохранен: отсутствует ID');
    }
  } catch (error) {
    console.error('Ошибка при создании документа:', error);
    errorMessage.value = error.response?.data?.message || 
                         error.message || 
                         'Произошла ошибка при сохранении документа';
    
    // Сбрасываем статус анализа в случае ошибки
    documentStore.currentDocument.analysisStatus = 'failed';
  } finally {
    isLoading.value = false;
  }
};
</script>

Это код файла FatherGuard\frontend\src\App.vue:
<template>
  <div class="app">
    <header class="app-header">
      <nav class="nav-container">
        <router-link to="/" class="nav-logo">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" class="logo-icon">
            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
          </svg>
          <span class="logo-text">Юридическая Защита Отцов</span>
        </router-link>
        <div class="nav-links">
          <router-link to="/" class="nav-link" exact-active-class="active">Главная</router-link>
          <router-link to="/documents" class="nav-link" exact-active-class="active">Документы</router-link>
          <router-link to="/complaints" class="nav-link" exact-active-class="active">Жалобы</router-link>
        </div>
      </nav>
    </header>

    <main class="app-main">
      <router-view v-slot="{ Component }">
        <transition name="fade" mode="out-in">
          <component :is="Component" />
        </transition>
      </router-view>
    </main>

    <footer class="app-footer">
      <div class="footer-content">
        <p>© 2025 Юридический сервис "Защита Отцов".</p>
      </div>
    </footer>
  </div>
</template>

<script setup>
import { watch } from 'vue'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'

const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()

// Загружаем данные при первом открытии соответствующих страниц
watch(
  () => documentStore.documents,
  (newVal) => {
    if (newVal.length === 0) { 
      documentStore.fetchDocuments()
    }
  },
  { immediate: true }
)
watch(
  () => documentStore.documents,
  (newVal) => {
    if (newVal.length === 0) { 
      documentStore.fetchComplaints()
    }
  },
  { immediate: true }
)
</script>

Это код файла FatherGuard\frontend\src\main.js:
import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'


const app = createApp(App)

const pinia = createPinia()
app.use(pinia)


app.use(router)
console.log('API Base:', import.meta.env.VITE_API_BASE)
console.log('Model URL:', import.meta.env.VITE_LOCAL_MODEL_URL)

app.mount('#app')

Это код файла FatherGuard\frontend\package.json:
{
  "name": "legal-assistant",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.10.0",
    "docx": "^9.5.1",
    "file-saver": "^2.0.5",
    "latest": "^0.2.0",
    "lowdb": "^7.0.1",
    "pdf-lib": "^1.17.1",
    "pinia": "^3.0.3",
    "vue": "^3.5.17",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.0",
    "nodemon": "^3.1.10",
    "vite": "^7.1.1",
    "vite-plugin-vue-devtools": "^8.0.0"
  }
}


Это код файла FatherGuard\frontend\index.html:
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>


Это код файла FatherGuard\frontend\vite.config.js:
import { fileURLToPath, URL } from 'node:url'
import { defineConfig, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

export default defineConfig(({ mode }) => {
  // Загружаем env переменные
  const env = loadEnv(mode, process.cwd(), ['VITE_'])

  return {
    server: {
      host: '0.0.0.0',
      port: parseInt(env.VITE_PORT || 5173), // Используем порт из env
      proxy: {
        '/ollama': {
          target: env.VITE_LOCAL_MODEL_URL,
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/ollama/, '')
        },
        '/api': {
          target: env.VITE_API_BASE,
          changeOrigin: true
        }
      }
    },
    plugins: [
      vue(),
      vueDevTools(),
    ],
    resolve: {
      alias: {
        '@': fileURLToPath(new URL('./src', import.meta.url))
      }
    },
    define: {
      'process.env': {},
      '__APP_ENV__': JSON.stringify(env)
    },
    optimizeDeps: {
      include: ['uuid']
    }
  }
})

Далее файлы Бэкенда:

Это код файла FatherGuard\backend\controllers\aiController.js:
import aiService from '../services/aiService.js';

const analyzeText = async (req, res) => {
  try {
    const result = await aiService.analyzeText(req.body.text);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

const generateComplaint = async (req, res) => {
  try {
    const result = await aiService.generateComplaint(req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export default { analyzeText, generateComplaint };

Это код файла FatherGuard\backend\controllers\analysisController.js:
//Кода нет

Это код файла FatherGuard\backend\controllers\complaintController.js:
export default {
  async createAIComplaint(req, res) {
    try {
      const { text, agency, documentId } = req.body;
      const files = req.files?.attachments || [];

      // Анализ текста и файлов
      const fileContents = await Promise.all(
        files.map(file => parseFileContent(file.path))
      );
      
      const fullText = [text, ...fileContents].join('\n\n');
      const result = await aiService.generateComplaint(fullText, files, agency);

      // Сохранение жалобы
      const complaint = await Complaint.create({
        content: result.content,
        agency,
        documentId,
        analysis: result.analysis
      });

      res.json(complaint);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
};

Это код файла FatherGuard\backend\controllers\documentController.js:
import Document from '../models/Document.js';
import aiService from '../services/aiService.js';
import pdfService from '../services/pdfService.js';

export default {
  async createDocument(req, res) {
    try {
      const { text, files = [] } = req.body;
      const document = new Document({ text });
      
      if (files.length) {
        const fileContents = await Promise.all(
          files.map(file => pdfService.extractTextFromPdf(file.buffer))
        );
        document.text += '\n\n' + fileContents.join('\n\n');
      }

      const analysis = await aiService.analyzeWithDeepSeek(document.text);
      document.summary = analysis.summary;
      document.keyParagraphs = analysis.keyParagraphs;

      await document.save();
      res.status(201).json(document);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  },

  async analyzeDocument(req, res) {
    try {
      const document = await Document.findById(req.params.id);
      const analysis = await aiService.analyzeWithDeepSeek(
        document.originalText,
        req.body.instructions
      );
      
      document.analysis = analysis;
      await document.save();
      
      res.json(analysis);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
};

Это код файла FatherGuard\backend\middleware\aiErrorHandler.js:
export default (err, req, res, next) => {
  if (err.message.includes('Ollama')) {
    console.error('AI Error:', {
      endpoint: req.originalUrl,
      input: req.body.text?.substring(0, 100),
      error: err.stack
    });
    
    return res.status(503).json({
      error: "Сервис анализа временно недоступен",
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
  next(err);
};

Это код файла FatherGuard\backend\models\Complaint.js:
//Кода нет

Это код файла FatherGuard\backend\models\Document.js:
export default class Document {
  constructor(data) {
    this.id = data.id || uuidv4();
    this.dateReceived = data.dateReceived || new Date().toISOString().split('T')[0];
    this.agency = data.agency || '';
    this.originalText = data.originalText || '';
    this.summary = data.summary || '';
    this.keyParagraphs = data.keyParagraphs || [];
    this.attachments = data.attachments || [];
    this.complaints = data.complaints || [];
    this.analysisStatus = data.analysisStatus || 'pending';
    this.lastAnalyzedAt = data.lastAnalyzedAt || null;
    this.createdAt = data.createdAt || new Date().toISOString();
    this.updatedAt = data.updatedAt || new Date().toISOString();
    
    // Поля для вложенных документов
    this.attachments = this.attachments.map(att => ({
      id: att.id || uuidv4(),
      name: att.name,
      type: att.type,
      size: att.size,
      path: att.path,
      text: att.text || '',
      analysis: att.analysis || {
        documentType: '',
        sentDate: '',
        senderAgency: '',
        summary: '',
        keyParagraphs: []
      }
    }));
  }

  validate() {
    if (!this.originalText && this.attachments.length === 0) {
      throw new Error('Документ должен содержать текст или вложения');
    }
    
    if (this.attachments.some(att => !att.text && !att.analysis)) {
      throw new Error('Все вложения должны содержать текст или анализ');
    }
  }
}

Это код файла FatherGuard\backend\routes\aiRoutes.js:
import express from 'express';
const router = express.Router();
import aiController from '../controllers/aiController.js';

router.post('/analyze', aiController.analyzeText);
router.post('/generate-complaint', aiController.generateComplaint);

export default router;

Это код файла FatherGuard\backend\routes\analysisRoutes.js:
//Кода нет

Это код файла FatherGuard\backend\routes\complaintRoutes.js:
import { Router } from 'express';
import { v4 as uuidv4 } from 'uuid';
import * as docx from 'docx';
import { Document, Paragraph, TextRun, Packer } from 'docx';

export default function complaintRoutes({ db }) {
  const router = Router();

  // Генерация жалобы (обновлённая версия)
  router.post('/generate', async (req, res) => {
    try {
      const { documentId, agency, instructions } = req.body;
      
      // Проверка обязательных полей
      if (!agency || !documentId) {
        return res.status(400).json({ message: 'Не указаны обязательные параметры' });
      }

      // Поиск документа
      const doc = db.data.documents.find(d => d.id === documentId);
      if (!doc) {
        return res.status(404).json({ message: 'Document not found' });
      }

      // Поиск связанных документов
      const relatedDocs = db.data.documents.filter(d => 
        d.id !== documentId && d.date <= doc.date
      );

      // Генерация жалобы
      const complaintContent = await this.generateComplaintContent(
        doc,
        agency,
        relatedDocs,
        instructions
      );

      // Создание объекта жалобы
      const complaint = {
        id: uuidv4(),
        documentId,
        agency,
        content: complaintContent,
        relatedDocuments: relatedDocs.map(d => d.id),
        status: 'draft',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      // Сохранение в БД
      if (!db.data.complaints) {
        db.data.complaints = [];
      }
      db.data.complaints.push(complaint);
      await db.write();

      // Обновление документа
      if (!doc.complaints) {
        doc.complaints = [];
      }
      doc.complaints.push(complaint.id);
      await db.write();

      res.status(201).json(complaint);
    } catch (err) {
      console.error('Ошибка генерации жалобы:', err);
      res.status(500).json({ message: err.message });
    }
  });

  // Экспорт жалобы
  router.get('/:id/export', async (req, res) => {
    try {
      const { format = 'txt' } = req.query;
      const complaint = db.data.complaints.find(c => c.id === req.params.id);
      
      if (!complaint) {
        return res.status(404).json({ message: 'Complaint not found' });
      }

      if (format === 'txt') {
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Content-Disposition', `attachment; filename=complaint_${complaint.agency}.txt`);
        res.send(complaint.content);
      } 
      else if (format === 'doc') {
        const doc = new Document({
          sections: [{
            children: [
              new Paragraph({
                children: [
                  new TextRun({
                    text: complaint.content,
                    size: 24
                  })
                ]
              })
            ]
          }]
        });

        const buffer = await Packer.toBuffer(doc);
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
        res.setHeader('Content-Disposition', `attachment; filename=complaint_${complaint.agency}.docx`);
        res.send(buffer);
      }
      else {
        res.status(400).json({ message: 'Unsupported format' });
      }
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Получение всех жалоб
  router.get('/', async (req, res) => {
    try {
      await db.read();
      
      // Сортировка по дате создания (новые сначала)
      const complaints = db.data.complaints?.sort((a, b) => 
        new Date(b.createdAt) - new Date(a.createdAt)
      ) || [];
      
      res.json(complaints);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Удаление жалобы
  router.delete('/:id', async (req, res) => {
    try {
      await db.read();
      const initialLength = db.data.complaints.length;
      
      // Удаление жалобы
      db.data.complaints = db.data.complaints.filter(c => c.id !== req.params.id);
      
      if (db.data.complaints.length === initialLength) {
        return res.status(404).json({ message: 'Complaint not found' });
      }
      
      // Удаление ссылки из документа
      for (const doc of db.data.documents) {
        if (doc.complaints) {
          doc.complaints = doc.complaints.filter(id => id !== req.params.id);
        }
      }
      
      await db.write();
      res.status(204).end();
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Вспомогательный метод для генерации содержания жалобы
  async function generateComplaintContent(doc, agency, relatedDocs, instructions) {
    try {
      // Здесь должна быть логика обращения к AI сервису
      // Временная реализация:
      let content = `Жалоба в ${agency}\n\n`;
      content += `Основание: ${doc.summary || "Не указано"}\n\n`;
      content += `Дата документа: ${doc.documentDate || "Не указана"}\n`;
      content += `Ведомство: ${doc.agency || "Не указано"}\n\n`;
      
      if (doc.keyParagraphs?.length) {
        content += `Существенные моменты:\n${doc.keyParagraphs.join('\n')}\n\n`;
      }
      
      if (relatedDocs.length) {
        content += `Связанные документы:\n`;
        content += relatedDocs.map(d => `- ${d.date}: ${d.summary || "Без описания"}`).join('\n');
      }
      
      if (instructions) {
        content += `\n\nДополнительные указания: ${instructions}`;
      }
      
      content += `\n\nДата составления: ${new Date().toLocaleDateString()}`;
      
      return content;
    } catch (err) {
      console.error('Ошибка генерации содержания жалобы:', err);
      return `Жалоба в ${agency}\n\nТекст документа: ${doc.originalText.substring(0, 500)}...`;
    }
  }

  return router;
}

Это код файла FatherGuard\backend\routes\documentRoutes.js:
import { Router } from 'express';
import express from 'express';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import Document from '../models/Document.js';
import aiService from '../services/aiService.js';
import pdfService from '../services/pdfService.js';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default function documentRoutes({ db, upload }) {
  const router = Router();

  // Middleware для проверки JSON
  router.use(express.json({
    verify: (req, res, buf, encoding) => {
      try {
        JSON.parse(buf.toString());
      } catch (e) {
        console.error('Invalid JSON:', buf.toString());
        res.status(400).json({ message: 'Invalid JSON' });
        throw new Error('Invalid JSON');
      }
    }
  }));

  // Вспомогательные функции
  const normalizeDocument = (data) => {
    return {
      id: data.id || uuidv4(),
      date: data.date || new Date().toISOString().split('T')[0],
      agency: data.agency || '',
      originalText: data.originalText || '',
      summary: data.summary || '',
      documentDate: data.documentDate || '',
      senderAgency: data.senderAgency || '',
      keyParagraphs: data.keyParagraphs || [],
      attachments: (data.attachments || []).map(att => ({
        id: att.id || uuidv4(),
        name: att.name,
        type: att.type,
        size: att.size,
        path: att.path,
        text: att.text || '',
        analysis: att.analysis || null
      })),
      complaints: data.complaints || [],
      analysisStatus: data.analysisStatus || 'pending',
      lastAnalyzedAt: data.lastAnalyzedAt || null,
      createdAt: data.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  };

  const validateDocument = (doc) => {
    if (!doc.originalText && (!doc.attachments || doc.attachments.length === 0)) {
      throw new Error('Документ должен содержать текст или вложения');
    }
  };

  // Загрузка документа (текст + файлы)
  router.post('/upload', upload.array('files'), async (req, res) => {
    try {
      const userText = req.body.text || "";
      const userComments = req.body.comments || "";

      // Обработка только текста
      if (userText && (!req.files || req.files.length === 0)) {
        const newDocument = normalizeDocument({
          originalText: userText,
          comments: userComments
        });
        
        db.data.documents.push(newDocument);
        await db.write();
        return res.status(201).json(newDocument);
      }

      // Обработка файлов
      const filesData = await processUploadedFiles(req.files, userText, userComments);
      res.status(201).json(filesData[0]);
    } catch (err) {
      console.error('Ошибка загрузки:', err);
      res.status(500).json({ 
        message: err.message || 'Ошибка сервера при обработке документа'
      });
    }
  });

  // Обработка загруженных файлов
  const processUploadedFiles = async (files, userText, userComments) => {
    if (!files || files.length === 0) {
      throw new Error('Нет файлов для загрузки');
    }

    const filesData = [];
    
    for (const file of files) {
      try {
        const fileContent = await extractFileContent(file);
        const combinedText = [userText, fileContent].filter(Boolean).join('\n\n');

        const newDocument = normalizeDocument({
          originalText: combinedText,
          comments: userComments,
          attachments: [{
            name: file.originalname,
            type: file.mimetype,
            size: file.size,
            path: `/uploads/${file.filename}`,
            text: fileContent
          }]
        });

        db.data.documents.push(newDocument);
        await db.write();
        filesData.push(newDocument);
        await fs.unlink(file.path);
      } catch (fileError) {
        console.error(`Ошибка обработки файла ${file.originalname}:`, fileError);
        continue;
      }
    }

    return filesData;
  };

  // Извлечение текста из файла
  const extractFileContent = async (file) => {
    if (file.mimetype === 'application/pdf') {
      const dataBuffer = await fs.readFile(file.path);
      const pdfData = await pdfService.extractTextFromPdf(dataBuffer);
      return pdfData.text;
    } else if (file.mimetype === 'text/plain') {
      return await fs.readFile(file.path, 'utf-8');
    }
    throw new Error('Неподдерживаемый тип файла');
  };

  // Создание документа
  router.post('/', async (req, res) => {
    try {
      const doc = normalizeDocument(req.body);
      validateDocument(doc);
      
      db.data.documents.push(doc);
      await db.write();
      res.status(201).json(doc);
    } catch (err) {
      res.status(400).json({ message: err.message });
    }
  });

  // Получение списка документов
  router.get('/', async (req, res) => {
    try {
      await db.read();
      const { limit = 50, offset = 0 } = req.query;
      
      const documents = db.data.documents
        .slice(parseInt(offset), parseInt(offset) + parseInt(limit))
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      res.json({
        total: db.data.documents.length,
        items: documents
      });
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Получение документа по ID
  router.get('/:id', async (req, res) => {
    try {
      const doc = db.data.documents.find(d => d.id === req.params.id);
      if (!doc) return res.status(404).json({ message: 'Документ не найден' });
      res.json(doc);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Анализ документа
  router.post('/:id/analyze', async (req, res) => {
    try {
      const { model, instructions, strictMode } = req.body;
      const doc = db.data.documents.find(d => d.id === req.params.id);
      
      if (!doc) {
        return res.status(404).json({ 
          message: 'Документ не найден',
          documentId: req.params.id
        });
      }

      // Обновление статуса
      doc.analysisStatus = 'processing';
      doc.updatedAt = new Date().toISOString();
      await db.write();

      const analysis = await analyzeDocumentContent(doc, instructions, strictMode);
      await analyzeAttachments(doc);

      // Обновление документа
      updateDocumentAnalysis(doc, analysis);
      await db.write();

      res.json({
        ...analysis,
        modelUsed: model,
        analyzedAt: doc.lastAnalyzedAt
      });

    } catch (err) {
      console.error(`Ошибка анализа документа ${req.params.id}:`, err);
      
      // Обновление статуса в случае ошибки
      const doc = db.data.documents.find(d => d.id === req.params.id);
      if (doc) {
        doc.analysisStatus = 'failed';
        doc.updatedAt = new Date().toISOString();
        await db.write();
      }
      
      res.status(500).json({
        message: 'Ошибка при анализе документа',
        error: err.message,
        documentId: req.params.id,
        stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
      });
    }
  });

  // Анализ содержимого документа
  const analyzeDocumentContent = async (doc, instructions, strictMode) => {
    return await aiService.analyzeLegalText(
      doc.originalText,
      instructions,
      strictMode
    );
  };

  // Анализ вложений
  const analyzeAttachments = async (doc) => {
    if (!doc.attachments?.length) return;

    for (const attachment of doc.attachments) {
      if (attachment.text) {
        attachment.analysis = await aiService.analyzeLegalText(
          attachment.text,
          'Определи тип документа, дату отправления и ведомство',
          true
        );
      }
    }
  };

  // Обновление данных анализа
  const updateDocumentAnalysis = (doc, analysis) => {
    doc.summary = analysis.summary;
    doc.documentDate = analysis.documentDate || "";
    doc.senderAgency = analysis.senderAgency || "";
    doc.keyParagraphs = analysis.keyParagraphs;
    doc.analysisStatus = 'completed';
    doc.lastAnalyzedAt = new Date().toISOString();
    doc.updatedAt = new Date().toISOString();
  };

  // Удаление документа
  router.delete('/:id', async (req, res) => {
    try {
      await db.read();
      const initialLength = db.data.documents.length;
      db.data.documents = db.data.documents.filter(d => d.id !== req.params.id);
      
      if (db.data.documents.length === initialLength) {
        return res.status(404).json({ message: 'Document not found' });
      }
      
      await db.write();
      res.status(204).end();
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Жалобы для документа
  router.post('/:id/complaints', async (req, res) => {
    try {
      const { agency } = req.body;
      if (!agency) return res.status(400).json({ message: 'Не указано ведомство' });

      const doc = db.data.documents.find(d => d.id === req.params.id);
      if (!doc) return res.status(404).json({ message: 'Документ не найден' });

      const relatedDocs = db.data.documents.filter(d => 
        d.date <= doc.date && d.id !== req.params.id
      );

      const complaint = await generateComplaint(doc, agency, relatedDocs);
      saveComplaint(doc, complaint);

      res.status(201).json(complaint);
    } catch (err) {
      res.status(500).json({ 
        message: err.message || 'Ошибка генерации жалобы',
        details: err.response?.data
      });
    }
  });

  // Генерация жалобы
  const generateComplaint = async (doc, agency, relatedDocs) => {
    const complaint = await aiService.generateComplaintV2(
      doc.originalText,
      agency,
      relatedDocs.map(d => d.originalText)
    );

    return {
      id: uuidv4(),
      documentId: doc.id,
      agency,
      content: complaint.content,
      violations: complaint.violations || [],
      status: 'draft',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  };

  // Сохранение жалобы
  const saveComplaint = (doc, complaint) => {
    if (!db.data.complaints) {
      db.data.complaints = [];
    }
    db.data.complaints.push(complaint);

    if (!doc.complaints) {
      doc.complaints = [];
    }
    doc.complaints.push(complaint.id);
    doc.updatedAt = new Date().toISOString();
  };

  // Получение жалоб для документа
  router.get('/:id/complaints', async (req, res) => {
    try {
      const complaints = db.data.complaints?.filter(c => c.documentId === req.params.id) || [];
      res.json(complaints);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Обновление документа
  router.put('/:id', async (req, res) => {
    try {
      const docIndex = db.data.documents.findIndex(d => d.id === req.params.id);
      if (docIndex === -1) return res.status(404).json({ message: 'Document not found' });
      
      db.data.documents[docIndex] = {
        ...db.data.documents[docIndex],
        ...req.body,
        updatedAt: new Date().toISOString()
      };
      
      await db.write();
      res.json(db.data.documents[docIndex]);
    } catch (err) {
      res.status(400).json({ message: err.message });
    }
  });

  return router;
}


Это код файла FatherGuard\backend\services\aiService.js:
import axios from "axios";
import useAIStore from '@/stores/aiStore'
import pinia from 'pinia'

app.use(pinia)

class AIService {
  constructor() {
    this.aiStore = useAIStore();
    this.localModelUrl = import.meta.env.VITE_LOCAL_MODEL_URL;
    this.defaultOptions = {
      temperature: 0.3,
      max_tokens: 6000,
      repeat_penalty: 1.2,
      format: "json",
    };
    this.analysisCache = new Map();
    this.maxRetries = 2;
  }

  /**
   * Основной метод для запросов к AI
   */
  async queryLocalModel(prompt, customOptions = {}) {
    const options = {
      ...this.defaultOptions,
      ...customOptions,
      prompt: this.preparePrompt(prompt, customOptions.taskType),
    };

    let retries = 0;
    let lastError = null;

    while (retries <= this.maxRetries) {
      try {
        const response = await axios.post(
          this.aiStore.apiUrl,
          {
            model: this.aiStore.activeModel, // Используем активную модель из хранилища
            prompt,
            stream: false,
            format: "json",
            ...options,
          },
          {
            timeout: 500000,
          }
        );

        return this.parseModelResponse(response.data);
      } catch (error) {
        lastError = error;
        console.error(`Attempt ${retries + 1} failed:`, error.message);

        if (retries < this.maxRetries) {
          await new Promise((resolve) =>
            setTimeout(resolve, 1000 * (retries + 1))
          );
          retries++;
          continue;
        }

        throw this.normalizeError(error);
      }
    }
  }

  /**
   * Анализ юридического текста с улучшенной обработкой
   */
  async analyzeLegalText(text, instructions = "", strictMode = false) {
    const cacheKey = this.generateCacheKey(text, instructions);
    if (this.analysisCache.has(cacheKey)) {
      return this.analysisCache.get(cacheKey);
    }

    const prompt = this.buildAnalysisPrompt(text, instructions, strictMode);
    const result = await this.queryLocalModel(prompt, {
      temperature: strictMode ? 0.1 : 0.3,
    });

    if (!result.summary) {
      console.error("Invalid model response format:", result);
      throw new Error("Отсутствует поле summary в ответе модели");
    }

    const enhancedResult = this.enhanceAnalysisResult(result, text);
    this.analysisCache.set(cacheKey, enhancedResult);
    return enhancedResult;
  }

  /**
   * Генерация жалобы (версия 2)
   */
  async generateComplaintV2(documentText, agency, relatedDocuments = []) {
    const prompt = this.buildComplaintPromptV2(
      documentText,
      agency,
      relatedDocuments
    );
    const response = await this.queryLocalModel(prompt, {
      temperature: 0.5,
      max_tokens: 7000,
    });

    return {
      content:
        response.content || this.generateDefaultComplaint(documentText, agency),
      violations: response.identifiedViolations || [],
      analysis: response.legalAnalysis || "",
      relatedDocuments: response.relatedDocuments || [],
    };
  }

  /**
   * Анализ вложенного документа
   */
  async analyzeAttachment(text) {
    const prompt = this.buildAttachmentPrompt(text);
    const response = await this.queryLocalModel(prompt, {
      temperature: 0.2,
      format: "json",
    });

    return this.parseAttachmentAnalysis(response);
  }

  // ========== Вспомогательные методы ==========

  preparePrompt(text, taskType = "default") {
    const prompts = {
      summary: `[SYSTEM] Ты - юридический ассистент. Сгенерируй краткую суть документа:
1. Только факты
2. 3-5 предложений
3. Укажи ведомство и дату если есть
4. Без вводных фраз, сразу к сути дела
5. Повествование от имени клиента в первом лице
[TEXT]: ${text.substring(0, 8000)}
[SUMMARY]:`,

      violations: `[SYSTEM] Найди нарушения в тексте. Формат:
- Закон: [название]
- Статья: [номер]
- Описание: [текст]
- Доказательство: [цитата]
[TEXT]: ${text.substring(0, 7000)}
[VIOLATIONS]:`,

      attachment: `[SYSTEM] Проанализируй вложение. Верни JSON:
{
  "documentType": "тип",
  "sentDate": "дата",
  "senderAgency": "ведомство",
  "summary": "суть",
  "keyParagraphs": []
}
[TEXT]: ${text.substring(0, 7000)}
[ANALYSIS]:`,

      default: `[SYSTEM] Проанализируй текст как юридический документ
[TEXT]: ${text.substring(0, 7000)}
[RESULT]:`,
    };

    return prompts[taskType] || prompts.default;
  }

  buildAnalysisPrompt(text, instructions, strictMode) {
    return JSON.stringify({
      task: "ANALYZE_LEGAL_DOCUMENT",
      text: text.substring(0, 10000),
      requirements: {
        summaryLength: "3-5 предложений",
        keyParagraphs: {
          count: 3,
          exactQuotes: true,
        },
        extractDates: true,
        identifyAgencies: true,
        strictAnalysis: strictMode,
        additionalInstructions: instructions,
      },
      lawsToCheck: [
        "Федеральный закон 'Об исполнительном производстве' №229-ФЗ",
        "Семейный кодекс РФ",
        "КоАП РФ",
      ],
    });
  }

  buildComplaintPromptV2(text, agency, relatedDocuments) {
    return JSON.stringify({
      task: "GENERATE_COMPLAINT_V2",
      agency,
      sourceText: text.substring(0, 5000),
      relatedDocuments: relatedDocuments.map((doc) => doc.substring(0, 2000)),
      requirements: {
        style: "Официальный",
        sections: [
          "Шапка (кому/от кого)",
          "Описание ситуации",
          "Ссылки на документы",
          "Нарушения",
          "Требования",
          "Приложения",
        ],
        includeReferences: true,
        citeLaws: true,
      },
    });
  }

  buildAttachmentPrompt(text) {
    return this.preparePrompt(text, "attachment");
  }

  enhanceAnalysisResult(result, text) {
    return {
      ...result,
      documentDate: this.extractDate(text) || result.documentDate || "",
      senderAgency: this.extractAgency(text) || result.senderAgency || "",
      keyParagraphs: result.keyParagraphs || [],
    };
  }

  parseAttachmentAnalysis(response) {
    try {
      const parsed =
        typeof response === "string" ? JSON.parse(response) : response;
      return {
        documentType: parsed.documentType || "Неизвестный тип",
        sentDate: parsed.sentDate || "",
        senderAgency: parsed.senderAgency || "",
        summary: parsed.summary || "Не удалось сгенерировать краткую суть",
        keyParagraphs: parsed.keyParagraphs || [],
      };
    } catch (e) {
      console.error("Ошибка парсинга анализа вложения:", e);
      return {
        documentType: "Неизвестный тип",
        sentDate: "",
        senderAgency: "",
        summary: "Ошибка анализа вложения",
        keyParagraphs: [],
      };
    }
  }

  parseModelResponse(data) {
    try {
      const rawResponse = data.response || data;

      if (typeof rawResponse === "string") {
        // Пытаемся извлечь JSON из строки если есть
        const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          return JSON.parse(jsonMatch[0]);
        }
        return { response: rawResponse };
      }

      return rawResponse;
    } catch (e) {
      console.error("Ошибка парсинга ответа модели:", e);
      throw new Error("Неверный формат ответа от модели");
    }
  }

  normalizeError(error) {
    const serverError = error.response?.data?.error;
    if (serverError) {
      return new Error(`Ошибка модели: ${serverError}`);
    }
    return error;
  }

  generateCacheKey(text, instructions = "") {
    const str = text.substring(0, 200) + instructions;
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = (hash << 5) - hash + str.charCodeAt(i);
      hash |= 0;
    }
    return hash.toString(36);
  }

  extractDate(text) {
    const dateRegex = /(\d{2}\.\d{2}\.\d{4})|(\d{4}-\d{2}-\d{2})/;
    const match = text.match(dateRegex);
    return match ? match[0] : null;
  }

  extractAgency(text) {
    const agencies = [
      "ФССП",
      "Прокуратура",
      "Суд",
      "Омбудсмен",
      "МВД",
      "Росреестр",
    ];
    return agencies.find((agency) => text.includes(agency)) || null;
  }

  generateDefaultComplaint(text, agency) {
    return `В ${agency}\n\nЗаявитель: [ФИО]\n\nЖалоба на документ:\n${text.substring(
      0,
      500
    )}\n\nТребования: Провести проверку\n\nДата: ${new Date().toLocaleDateString()}`;
  }
}

export default new AIService();


Это код файла FatherGuard\backend\services\documentService.js:
//Кода нет

Это код файла FatherGuard\backend\services\FileService.js:
//Кода нет

Это код файла FatherGuard\backend\services\legal_references.json:
{}
Это код файла FatherGuard\backend\services\modelHealthCheck.js:
import axios from 'axios';

export async function checkModelAvailability() {
  try {
    const response = await axios.get('http://localhost:11434', {
      timeout: 10000
    });
    return response.status === 200;
  } catch (error) {
    console.error('Модель недоступна:', error.message);
    return false;
  }
}

Это код файла FatherGuard\backend\services\nlpService.js:
//Кода нет

Это код файла FatherGuard\backend\services\pdfService.js:
import pdf from 'pdf-parse';

export default {
  async extractTextFromPdf(buffer) {
    try {
      const data = await pdf(buffer);
      return {
        text: data.text,
        metadata: data.metadata,
        numPages: data.numpages
      };
    } catch (error) {
      console.error('PDF parsing error:', error);
      throw new Error('Не удалось обработать PDF файл');
    }
  }
}

Это код файла FatherGuard\backend\.env:
OLLAMA_URL=http://localhost:11434
VITE_LOCAL_MODEL_URL=http://localhost:11434
VITE_API_BASE=http://localhost:3001
MODEL_NAME=llama3.1:latest
PORT=3001

Это код файла FatherGuard\backend\app.mjs:
import express from 'express';
import cors from 'cors';
import path from 'path';
import "dotenv/config";
import { fileURLToPath } from "url";
import { dirname, join } from "path";
import { Low } from "lowdb";
import { JSONFile } from "lowdb/node";
import multer from "multer";
import { v4 as uuidv4 } from "uuid";
import fs from "fs/promises";
import aiRoutes from './routes/aiRoutes.js'

const app = express();

const __dirname = dirname(fileURLToPath(import.meta.url));

// 1. Инициализация файла базы данных
const dbPath = join(__dirname, "db.json");

// 2. Функция для гарантированной инициализации DB
async function initDB() {
  try {
    // Проверяем существует ли файл
    try {
      await fs.access(dbPath);
      console.log("DB file exists");
    } catch {
      // Если файла нет - создаем с начальной структурой
      await fs.writeFile(
        dbPath,
        JSON.stringify({ documents: [], complaints: [] }, null, 2)
      );
      console.log("Created new DB file");
    }

    // Читаем данные
    const data = await fs.readFile(dbPath, "utf-8");
    const parsedData = JSON.parse(data);

    // Проверяем структуру
    if (!parsedData.documents || !parsedData.complaints) {
      throw new Error("Invalid DB structure");
    }

    return parsedData;
  } catch (err) {
    console.error("DB init failed:", err);
    throw err;
  }
}

// 3. Инициализация приложения
async function startServer() {
  try {
    // Загружаем данные
    const initialData = await initDB();

    // Создаем экземпляр lowdb с гарантированными данными
    const adapter = new JSONFile(dbPath);
    const db = new Low(adapter, initialData);
    await db.read();

    // Инициализация multer
    const uploadDir = join(__dirname, "uploads");
    await fs.mkdir(uploadDir, { recursive: true });
    const upload = multer({ dest: uploadDir });

    // Создаем Express приложение
    const app = express();
    app.use(
      cors({
        origin: "http://localhost:5173", // или ваш фронтенд URL
        methods: ["GET", "POST", "PUT", "DELETE"], // добавьте PUT
      })
    );
    app.use(express.json());
    app.use("/uploads", express.static(uploadDir));

    // Middleware для обработки новых записей
    app.use((req, res, next) => {
      if (req.method === "POST") {
        if (req.path.includes("/documents")) {
          req.body = {
            id: uuidv4(),
            date: new Date().toISOString().split("T")[0],
            agency: "",
            originalText: "",
            summary: "",
            keyParagraphs: [],
            attachments: [],
            createdAt: new Date().toISOString(),
            ...req.body,
          };
        } else if (req.path.includes("/complaints")) {
          req.body = {
            id: uuidv4(),
            documentId: "",
            agency: "",
            content: "",
            status: "draft",
            createdAt: new Date().toISOString(),
            ...req.body,
          };
        }
      }
      next();
    });

    app.locals.db = db; // Делаем db доступной в роутах

    // Подключение роутов (убедитесь, что они экспортируют router)
    import("./routes/documentRoutes.js").then(({ default: documentRoutes }) => {
      app.use("/api/documents", documentRoutes({ db, upload }));
    });

    import("./routes/complaintRoutes.js").then(
      ({ default: complaintRoutes }) => {
        app.use("/api/complaints", complaintRoutes({ db }));
      }
    );
    app.use("/api/ai", aiRoutes);

    // Запуск сервера
    const PORT = process.env.PORT || 3001;
    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (err) {
    console.error("Server startup failed:", err);
    process.exit(1);
  }
}

startServer();


Это код файла FatherGuard\backend\db.json:
{
  "documents": [
    {
      "id": "74c98d0f-a00a-46f5-8815-8ab8b7afbc28",
      "date": "2025-08-11",
      "agency": "",
      "originalText": "Здравствуйте!\nЯ обратился в Заводской РОСП с жалобой по факту незаконного начисления мне долга по алиментам 17.11.2022г. но ответа не получил. Далее, 11.04.2023г., я обратился в ГУФССП по Саратовской Области по факту не рассмотрения моей жалобы Заводским РОСП, и в ответ на это обращение, 11.05.2023г., мне пришло письмо от начальника Заводского РОСП Мушатова Давида Ишангалиевича, в котором он сообщил мне следующее: \"Сообщаем, что на исполнении находится сводное исполнительное производство, а также имеется задолженность в виду алиментных платежей, необходимо придти в Заводское РОСП г. Саратова для дачи объяснения\" (орфографические ошибки сохранены).",
      "summary": "Документ от 11.05.2023г. от Заводского РОСП. В ответ на жалобу, обращение в ГУФССП по Саратовской Области, указано, что на исполнении находится сводное исполнительное производство и имеется задолженность по алиментным платежам, необходимо дать объяснение в Заводском РОСП г. Саратова.",
      "documentDate": "17.11.2022",
      "senderAgency": "ФССП",
      "keyParagraphs": [
        "Сообщаем, что на исполнении находится сводное исполнительное производство, а также имеется задолженность в виду алиментных платежей, необходимо придти в Заводское РОСП г. Саратова для дачи объяснения"
      ],
      "attachments": [],
      "complaints": [],
      "analysisStatus": "completed",
      "lastAnalyzedAt": "2025-08-11T17:26:56.000Z",
      "createdAt": "2025-08-11T17:23:04.265Z",
      "updatedAt": "2025-08-11T17:26:56.038Z",
      "violations": "- Закон: Федеральный закон \"О судебной власти и статусе судей\"\n- Статья: 17\n- Описание: Неисполнение судебного решения или не рассмотрение жалобы в установленные сроки\n- Доказательство: \"но ответа не получил\" (не было предоставлено ответа на жалобу Заводским РОСП в установленный срок)\n\n- Закон: Федеральный закон \"О судебной власти и статусе судей\"\n- Статья: 17\n- Описание: Неисполнение судебного решения или не рассмотрение жалобы в установленные сроки\n- Доказательство: \"11.04.2023г., я обратился в ГУФССП по Саратовской Области по факту не рассмотрения моей жалобы Заводским РОСП, и в ответ на это обращение...\" (не было рассмотрено обращение в установленный срок)\n\n- Закон: Федеральный закон \"Об исполнительном производстве\"\n- Статья: 11\n- Описание: Неправильное уведомление лица об исполнении судебного решения или исполнительного производства\n- Доказательство: \"Сообщаем, что на исполнении находится сводное исполнительное производство...\" (не было указано, какие конкретно действия планируются по исполнению судебного решения или исполнительного производства)"
    },
    
    }
  ],
  "complaints": []
}

Это код файла FatherGuard\backend\package.json:
//Могу предоставить при необходимости

Это код файла FatherGuard\package.json:
//Могу предоставить при необходимости



























