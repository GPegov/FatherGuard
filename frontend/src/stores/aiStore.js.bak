import { defineStore } from "pinia";
import axios from "axios";

export const useAIStore = defineStore("ai", {
  state: () => ({
    isLoading: false,
    error: null,
    apiStatus: "unknown",
    apiUrl: "http://localhost:11434/api/generate",
    model: "llama3.1/18/8192",
    availableModels: [
      {
        name: "llama3.1/18/8192",
        description: "using 18 treads with 8192 num_ctx",
        parameters: {
          temperature: 0.3,
          top_p: 0.9,
          // num_ctx: 16384,
        },
      },
    ],
    agencies: ["ФССП", "Прокуратура", "Суд", "Омбудсмен"],
  }),

  actions: {
    // Инициализация AI сервиса
    _initAIService() {
      // Возвращаем объект с настройками для прямых вызовов API
      return {
        apiUrl: this.apiUrl,
        model: this.model
      };
    },

    // Подготовка промта для различных типов задач
    _preparePrompt(text, taskType = "default") {
      const baseSystemPrompt = `
    [SYSTEM] Ты - юридический ассистент. 
    Проанализируй текст как юридический документ.
     
`;

      const taskSpecificPrompts = {
        summary: `${baseSystemPrompt}
Сгенерируй краткую суть документа объемом от трёх до пяти предложений: 
1. Повествование о клиенте в следующем стиле: 'Вы оспорили... Вы подали прошение...'
2. Без вступительных фраз вроде 'Документ:' или 'Краткая суть текста:' - сразу сгенерированная краткая суть!
3. Верни только краткую суть, без дополнительных пояснений
[TEXT]: ${text.substring(0, 12000)}
[SUMMARY]:`,
        paragraphs: `${baseSystemPrompt}
Выбери из текста несколько самых важных предложений и передай их 
в своём ответе полностью, дословно, без редактирования.
Верни каждое предложение с новой строки, без нумерации:
[TEXT]: ${text.substring(0, 12000)}
[keySentences]:`,

        violations: `${baseSystemPrompt}
Найди нарушения в тексте. Формат:
- Закон: [название]
- Статья: [номер]
- Описание: [текст]
- Доказательство: [цитата]
[TEXT]: ${text.substring(0, 9000)}
[VIOLATIONS]:`,
        attachment: `${baseSystemPrompt}
Проанализируй вложение. Верни JSON:
{
  "documentType": "тип",
  "sentDate": "дата",
  "senderAgency": "ведомство",
  "summary": "суть",
  "keySentences": ["важные предложения документа во вложении"]
}
[TEXT]: ${text.substring(0, 9000)}
[ANALYSIS]:`,
        default: `${baseSystemPrompt}
[TEXT]: ${text.substring(0, 9000)}
[RESULT]:`,
      };

      return taskSpecificPrompts[taskType] || taskSpecificPrompts.default;
    },

    // Безопасный парсинг ответа от модели
    _safeParseResponse(response) {
      try {
        if (typeof response === "string") {
          // Попытка найти JSON в строке
          const jsonMatch = response.match(/\{[\s\S]*\}/);
          return jsonMatch ? JSON.parse(jsonMatch[0]) : null;
        }
        return response;
      } catch (e) {
        console.error("Ошибка парсинга ответа:", e);
        return null;
      }
    },

    async checkServerStatus() {
      try {
        const response = await axios.get("http://localhost:11434/api/tags", {
          timeout: 3000,
        });
        this.apiStatus = response.status === 200 ? "ready" : "error";
        return this.apiStatus;
      } catch (error) {
        this.apiStatus = "offline";
        throw new Error("AI сервер недоступен");
      }
    },

    async generateSummary(text) {\n      this.isLoading = true;\n      this.error = null;\n\n      try {\n        // Подготавливаем промт для генерации краткой сводки\n        const prompt = this._preparePrompt(text, \"summary\");\n        \n        // Выполняем запрос к API напрямую\n        const response = await axios.post(this.apiUrl, {\n          model: this.model,\n          prompt: prompt,\n          stream: false,\n          // Убираем format: \"json\", так как промт не требует JSON ответ\n          temperature: 0.3,\n          max_tokens: 16384,\n          repeat_penalty: 1.2\n        }, { timeout: 500000 });\n\n        // Получаем ответ от модели\n        const result = response.data?.response || response.data || \"\";\n        \n        console.log(\"Сгенерированная краткая суть:\", result);\n        \n        // Проверяем, является ли результат строкой JSON\n        let summary = result;\n        if (typeof result === \"string\") {\n          // Попытка распарсить как JSON\n          try {\n            const parsed = JSON.parse(result);\n            // Если успешно, используем поле response или summary\n            summary = parsed.response || parsed.summary || parsed.content || result;\n          } catch (e) {\n            // Если не удалось распарсить как JSON, используем результат как есть\n            summary = result;\n          }\n        }\n        \n        // Очищаем результат от лишних символов\n        summary = summary\n          .replace(/\\r/g, '') // Убираем символы возврата каретки\n          .replace(/^[\\[\\{\\(].*?[\\]\\}\\)]\\s*/g, '') // Убираем начальные скобки с содержимым (если это JSON-фрагменты)\n          .trim();\n        \n        return summary || \"Не удалось сгенерировать краткую суть\";\n      } catch (error) {\n        console.error(\"Ошибка генерации сводки:\", error);\n        this.error = error.message;\n        return \"Ошибка генерации краткой сводки\";\n      } finally {\n        this.isLoading = false;\n      }\n    },

    async extractKeySentences(text) {
      this.isLoading = true;
      this.error = null;

      try {
        // Подготавливаем промт для извлечения важных предложений
        const prompt = this._preparePrompt(text, "paragraphs");
        
        // Выполняем запрос к API напрямую
        const response = await axios.post(this.apiUrl, {
          model: this.model,
          prompt: prompt,
          stream: false,
          // Убираем format: "json", так как промт не требует JSON ответ
          temperature: 0.3,
          max_tokens: 16384,
          repeat_penalty: 1.2
        }, { timeout: 500000 });

        // Получаем ответ от модели
        let result = response.data?.response || response.data || "";
        
        // Если результат пустой, возвращаем пустой массив
        if (!result.trim()) {
          return [];
        }
        
        // Очищаем результат от лишних символов и разбиваем на предложения
        result = result
          .replace(/\\\r/g, '') // Убираем символы возврата каретки
          .replace(/^\s*[0-9]+\.\s*/gm, '') // Убираем нумерацию в начале строк
          .trim();
        
        // Разбиваем текст на предложения по точкам, восклицательным и вопросительным знакам
        // при условии, что после них идет пробел и заглавная буква
        const sentences = result
          .split(/(?<=[.!?])\s+(?=[A-ZА-Я])/)
          .map(sentence => sentence.trim())
          .filter(sentence => sentence.length > 10); // Фильтруем очень короткие "предложения"
          
        // Возвращаем первые 10 предложений
        return sentences.slice(0, 10);
      } catch (error) {
        console.error("Ошибка extractKeySentences:", error);
        this.error = error.message;
        return ["Не удалось извлечь важные предложения"];
      } finally {
        this.isLoading = false;
      }
    },

    async detectViolations(text) {
      this.isLoading = true;
      this.error = null;

      try {
        // Подготавливаем промт для анализа нарушений
        const prompt = this._preparePrompt(text, "violations");
        
        // Выполняем запрос к API напрямую
        const response = await axios.post(this.apiUrl, {
          model: this.model,
          prompt: prompt,
          stream: false,
          format: "json",
          temperature: 0.5,
          max_tokens: 16384,
          repeat_penalty: 1.2
        }, { timeout: 500000 });

        const result = this._safeParseResponse(response.data);
        return result?.response || result || "Не удалось проанализировать нарушения";
      } catch (error) {
        console.error("Ошибка анализа нарушений:", error);
        this.error = error.message;
        return "Не удалось проанализировать нарушения. Проверьте текст документа.";
      } finally {
        this.isLoading = false;
      }
    },

    async analyzeAttachment(text) {
      this.isLoading = true;
      this.error = null;

      try {
        // Подготавливаем промт для анализа вложения
        const prompt = this._preparePrompt(text, "attachment");
        
        // Выполняем запрос к API напрямую
        const response = await axios.post(this.apiUrl, {
          model: this.model,
          prompt: prompt,
          stream: false,
          format: "json",
          temperature: 0.3,
          max_tokens: 16384,
          repeat_penalty: 1.2
        }, { timeout: 500000 });

        const result = this._safeParseResponse(response.data);
        
        // Парсим результат анализа вложения
        return {
          documentType: result?.documentType || "Неизвестный тип",
          sentDate: result?.sentDate || "",
          senderAgency: result?.senderAgency || "",
          summary: result?.summary || "Не удалось сгенерировать краткую суть",
          keySentences: result?.keySentences || [],
        };
      } catch (error) {
        console.error("Ошибка анализа вложения:", error);
        this.error = error.message;
        return {
          documentType: "Неизвестный тип",
          sentDate: "",
          senderAgency: "",
          summary: "Ошибка анализа документа",
          keySentences: [],
        };
      } finally {
        this.isLoading = false;
      }
    },

    async analyzeDocument(text) {
      this.isLoading = true;
      this.error = null;

      try {
        const [summary, sentences, violations] = await Promise.all([
          this.generateSummary(text),
          this.extractKeySentences(text),
          this.detectViolations(text),
        ]);

        return {
          summary: summary || "Не удалось сгенерировать сводку",
          keySentences: Array.isArray(sentences)
            ? sentences
            : ["Ошибка извлечения предложений"],
          violations: violations || "Ошибка анализа нарушений",
          status: "complete",
        };
        
      } catch (error) {
        console.error("Ошибка анализа документа:", error);
        this.error = error.message;
        return {
          summary: "Системная ошибка анализа",
          paragraphs: ["Системная ошибка"],
          violations: "Системная ошибка",
          status: "error",
        };
      } finally {
        this.isLoading = false;
      }
    },

    async generateAttachmentSummary(text) {
      try {
        // Подготавливаем промт для генерации краткой сводки вложения
        const prompt = this._preparePrompt(text, "attachment");
        
        // Выполняем запрос к API напрямую
        const response = await axios.post(this.apiUrl, {
          model: this.model,
          prompt: prompt,
          stream: false,
          format: "json",
          temperature: 0,
          max_tokens: 16384,
          repeat_penalty: 1.2
        }, { timeout: 500000 });

        return this._safeParseResponse(response.data);
      } catch (error) {
        console.error("Ошибка генерации краткой сводки вложения:", error);
        return null;
      }
    },

    async generateComplaint(text, agency, violation = "") {
      this.isLoading = true;
      this.error = null;

      if (!this.agencies.includes(agency)) {
        this.error = "Указано недопустимое ведомство";
        throw new Error(this.error);
      }

      try {
        const prompt = `Сгенерируй официальную жалобу в ${agency} на основе документа.
                      ${violation ? `Выявленное нарушение:\n${violation}\n` : ""}
                      Текст документа:\n${text.substring(0, 3000)}`;

        // Выполняем запрос к API напрямую
        const response = await axios.post(this.apiUrl, {
          model: this.model,
          prompt: prompt,
          stream: false,
          format: "json",
          temperature: 0.5,
          max_tokens: 7000,
          repeat_penalty: 1.2
        }, { timeout: 500000 });

        const result = this._safeParseResponse(response.data);
        return (
          result?.response || result || this._generateFallbackComplaint(text, agency)
        );
      } catch (error) {
        console.error("Ошибка генерации жалобы:", error);
        this.error = error.message;
        return this._generateFallbackComplaint(text, agency);
      } finally {
        this.isLoading = false;
      }
    },

    _generateFallbackComplaint(text, agency) {
      return `В ${agency}\n\nЗаявитель: [ФИО]\n\nЖалоба на документ:\n${text.substring(
        0,
        500
      )}\n\nТребования: Провести проверку\n\nДата: ${new Date().toLocaleDateString()}`;
    },
  },

  getters: {
    isServerOnline: (state) => state.apiStatus === "ready",
    activeModelName: (state) => {
      const model = state.availableModels.find(
        (m) => m.name === state.model
      );
      return model ? model.description : "Неизвестная модель";
    },
  },
});









// import { defineStore } from "pinia";
// import axios from "axios";
// import AIService from "../../../backend/services/aiService";

// export const useAIStore = defineStore("ai", {
//   state: () => ({
//     isLoading: false,
//     error: null,
//     apiStatus: "unknown", // 'ready', 'error', 'offline'
//     apiUrl: "http://localhost:11434/api/generate",
//     model: "llama3.1:latest",
//     availableModels: [
//       {
//         name: "llama3.1:latest",
//         description: "Llama 3.1 (latest)",
//         parameters: {
//           temperature: 0.3,
//           top_p: 0.9,
//           num_ctx: 16384,
//         },
//       },
//     ],
//     agencies: ["ФССП", "Прокуратура", "Суд", "Омбудсмен"],
//   }),

//   actions: {
//     /**
//      * Инициализация AI сервиса
//      */
//     _initAIService() {
//       return new AIService(this.apiUrl, this.activeModel);
//     },

//     /**
//      * Фильтр для удаления предложений с латинскими символами (>15)
//      */
//     _filterLatinText(text) {
//       if (!text) return text;

//       return text
//         .split(/(?<=[.!?])\s+/)
//         .filter((sentence) => {
//           const latinChars = (sentence.match(/[a-zA-Z]/g) || []).length;
//           return latinChars <= 15;
//         })
//         .join(" ")
//         .trim();
//     },

//     /**
//      * Проверка доступности AI сервера
//      */
//     async checkServerStatus() {
//       try {
//         const response = await axios.get("http://localhost:11434/api/tags", {
//           timeout: 3000,
//         });
//         this.apiStatus = response.status === 200 ? "ready" : "error";
//         return this.apiStatus;
//       } catch (error) {
//         this.apiStatus = "offline";
//         throw new Error("AI сервер недоступен");
//       }
//     },

//     /**
//      * Генерация краткой сводки
//      */
//     async generateSummary(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const filteredText = this._filterLatinText(text);
//         const summary = await aiService.queryLocalModel(filteredText, {
//           taskType: "summary",
//         });

//         return summary?.response || "Не удалось сгенерировать краткую суть";
//       } catch (error) {
//         console.error("Ошибка генерации сводки:", error);
//         this.error = error.message;
//         return "Ошибка генерации краткой сводки";
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Извлечение ключевых параграфов
//      */
//     async extractKeyParagraphs(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const response = await aiService.analyzeLegalText(text);

//         // Возвращаем нормализованные параграфы
//         return response.keyParagraphs || [];
//       } catch (error) {
//         console.error("Ошибка extractKeyParagraphs:", error);
//         this.error = error.message;
//         return ["Не удалось извлечь ключевые параграфы"];
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Поиск юридических нарушений
//      */
//     async detectViolations(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const filteredText = this._filterLatinText(text);
//         const response = await aiService.queryLocalModel(filteredText, {
//           taskType: "violations",
//           temperature: 0.5,
//         });

//         return response?.response || "Не удалось проанализировать нарушения";
//       } catch (error) {
//         console.error("Ошибка анализа нарушений:", error);
//         this.error = error.message;
//         return "Не удалось проанализировать нарушения. Проверьте текст документа.";
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Анализ вложенного документа
//      */
//     async analyzeAttachment(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const filteredText = this._filterLatinText(text);
//         const response = await aiService.queryLocalModel(filteredText, {
//           taskType: "attachment",
//           temperature: 0.2,
//           format: "json",
//         });

//         return aiService.parseAttachmentAnalysis(response);
//       } catch (error) {
//         console.error("Ошибка анализа вложения:", error);
//         this.error = error.message;
//         return {
//           documentType: "Неизвестный тип",
//           sentDate: "",
//           senderAgency: "",
//           summary: "Ошибка анализа документа",
//           keyParagraphs: [],
//         };
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Полный анализ документа
//      */
//     async analyzeDocument(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const [summary, paragraphs, violations] = await Promise.all([
//           this.generateSummary(text),
//           this.extractKeyParagraphs(text),
//           this.detectViolations(text),
//         ]);

//         return {
//           summary: summary || "Не удалось сгенерировать сводку",
//           paragraphs: Array.isArray(paragraphs)
//             ? paragraphs
//             : ["Ошибка извлечения цитат"],
//           violations: violations || "Ошибка анализа нарушений",
//           status: "complete",
//         };
//       } catch (error) {
//         console.error("Ошибка анализа документа:", error);
//         this.error = error.message;
//         return {
//           summary: "Системная ошибка анализа",
//           paragraphs: ["Системная ошибка"],
//           violations: "Системная ошибка",
//           status: "error",
//         };
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     async generateAttachmentSummary(text) {
//       return this.queryLocalModel(text, {
//         taskType: "attachment",
//         temperature: 0,
//         format: "json",
//       });
//     },

//     /**
//      * Генерация жалобы
//      */
//     async generateComplaint(text, agency, violation = "") {
//       this.isLoading = true;
//       this.error = null;

//       if (!this.agencies.includes(agency)) {
//         this.error = "Указано недопустимое ведомство";
//         throw new Error(this.error);
//       }

//       try {
//         const aiService = this._initAIService();
//         const prompt = `Сгенерируй официальную жалобу в ${agency} на основе документа.
//                       ${
//                         violation ? `Выявленное нарушение:\n${violation}\n` : ""
//                       }
//                       Текст документа:\n${text.substring(0, 3000)}`;

//         const response = await aiService.queryLocalModel(prompt, {
//           temperature: 0.5,
//           max_tokens: 7000,
//         });

//         return (
//           response?.response || this._generateFallbackComplaint(text, agency)
//         );
//       } catch (error) {
//         console.error("Ошибка генерации жалобы:", error);
//         this.error = error.message;
//         return this._generateFallbackComplaint(text, agency);
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Обработка параграфов
//      */
//     _postProcessParagraphs(text) {
//       if (!text) return ["Не найдено значимых цитат"];

//       // Обрабатываем как строку, если text не объект
//       const textToProcess =
//         typeof text === "string" ? text : text.response || text.content || "";

//       return textToProcess
//         .split(/(?<=[.!?])\s+/)
//         .map((p) => {
//           let cleaned = p
//             .replace(/<\|.*?\|\>|```/g, "")
//             .replace(/^["']+|["']+$/g, "")
//             .trim();
//           return cleaned.length > 15 ? cleaned : null;
//         })
//         .filter(Boolean)
//         .filter(
//           (item, index, arr) =>
//             index ===
//             arr.findIndex((i) => i.substring(0, 50) === item.substring(0, 50))
//         )
//         .slice(0, 5);
//     },

//     /**
//      * Генерация резервной жалобы при ошибке
//      */
//     _generateFallbackComplaint(text, agency) {
//       return `В ${agency}\n\nЗаявитель: [ФИО]\n\nЖалоба на документ:\n${text.substring(
//         0,
//         500
//       )}\n\nТребования: Провести проверку\n\nДата: ${new Date().toLocaleDateString()}`;
//     },
//   },

//   getters: {
//     isServerOnline: (state) => state.apiStatus === "ready",
//     activeModelName: (state) => {
//       const model = state.availableModels.find(
//         (m) => m.name === state.activeModel
//       );
//       return model ? model.description : "Неизвестная модель";
//     },
//   },
// });

// export default useAIStore;
