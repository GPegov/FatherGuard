// Файл: vite.config.js
import { fileURLToPath, URL } from 'node:url'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

// https://vite.dev/config/
export default defineConfig({
  server: {
    host: '0.0.0.0',
    proxy: {
      '/api': {
        target: 'http://localhost:11434',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },
  plugins: [
    vue(),
    vueDevTools(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  define: {
    // Решаем проблему с process is not defined
    'process.env': {},
    // Альтернативный вариант, если нужно передать конкретные переменные
    // 'process.env': {
    //   NODE_ENV: JSON.stringify(process.env.NODE_ENV)
    // }
  },
  optimizeDeps: {
    include: ['uuid'],
    exclude: ['@llama-node/core'] // Исключаем проблемные зависимости, если есть
  }
})

====================

// Файл: frontend\vite.config.js
import { fileURLToPath, URL } from 'node:url'
import { defineConfig, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

export default defineConfig(({ mode }) => {
  // Загружаем env переменные
  const env = loadEnv(mode, process.cwd(), ['VITE_'])

  return {
    server: {
      host: '0.0.0.0',
      port: parseInt(env.VITE_PORT || 5173), // Используем порт из env
      proxy: {
        '/ollama': {
          target: 'http://localhost:11434',
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/ollama/, '')
        },
        '/api': {
          target: env.VITE_API_BASE,
          changeOrigin: true
        }
      }
    },
    plugins: [
      vue(),
      vueDevTools(),
    ],
    resolve: {
      alias: {
        '@': fileURLToPath(new URL('./src', import.meta.url))
      }
    },
    define: {
      'process.env': {},
      '__APP_ENV__': JSON.stringify(env)
    },
    optimizeDeps: {
      include: ['uuid']
    }
  }
})

====================

// Файл: frontend\index.html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>


====================

// Файл: backend\test-analyze-text.js
import axios from 'axios';

// Тестовый текст для анализа
const testText = `
Уведомление о взыскании задолженности
Федеральная служба судебных приставов по Омской области
Отдел судебных приставов по Московскому району г. Омска

Взыскатель: Иванов И.И.
Адрес: г. Омск, ул. Ленина, д. 10, кв. 5

Должник: Петров П.П.
Адрес: г. Омск, ул. Советская, д. 15, кв. 20

На основании исполнительного листа от 15.03.2024 года № 1234567890
о взыскании с Петрова П.П. в пользу Иванова И.И. задолженности 
в размере 50 000 рублей плюс 3% годовых и судебные расходы 5 000 рублей.

Взыскано: 55 000 рублей
Остаток долга: 0 рублей

Дата взыскания: 20.04.2024
Подпись: ___________
Печать: Федеральная служба судебных приставов
`;

// Дополнительные инструкции
const instructions = "Обрати особое внимание на дату взыскания и сумму. Проверь, соответствует ли она законодательству.";

// Строгий режим анализа
const strictMode = true;

// URL для тестирования
const url = 'http://localhost:3000/api/documents/analyze-text';

async function testAnalyzeText() {
  try {
    console.log('Отправка запроса на анализ текста...');
    
    const response = await axios.post(url, {
      text: testText,
      instructions: instructions,
      strictMode: strictMode
    }, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    console.log('Ответ от сервера:');
    console.log(JSON.stringify(response.data, null, 2));
  } catch (error) {
    console.error('Ошибка при тестировании:');
    if (error.response) {
      console.error('Статус:', error.response.status);
      console.error('Данные:', error.response.data);
    } else {
      console.error('Сообщение:', error.message);
    }
  }
}

// Запуск теста
testAnalyzeText();

====================

// Файл: backend\test-ai.js
import aiService from './services/aiService.js';

async function test() {
  try {
    console.log("Testing AI connection...");
    const result = await aiService.analyzeLegalText(
      "Арендодатель запрещает держать животных в квартире"
    );
    console.log("✅ Success:", JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("❌ Error:", error.message);
    if (error.response) {
      console.error("Response data:", error.response.data);
    }
  } finally {
    process.exit();
  }
}

test();

====================

// Файл: backend\ai-test-cases.js
import AIService from './services/aiService.js';

// Создаем экземпляр AIService
const aiService = new AIService();

const testCases = [
  {
    input: "Арендодатель запрещает держать кошек в квартире"
    // Убираем expected, так как мы не используем Jest
  },
  {
    input: "Договор запрещает возврат товара в течение 14 дней"
    // Убираем expected, так как мы не используем Jest
  }
];

async function runTests() {
  for (const test of testCases) {
    try {
      console.log(`\nTesting: "${test.input.substring(0, 30)}..."`);
      const result = await aiService.analyzeLegalText(test.input);
      
      console.log("Result:", {
        violations: result.violations.map(v => v.article),
        summary: result.summary
      });

      if (!result.violations.length) {
        console.warn("⚠️ No violations detected for:", test.input);
      }
    } catch (error) {
      console.error(`❌ Failed on: "${test.input}"`, error.message);
    }
  }
}

runTests();

====================

// Файл: backend\ai-bailiff-test.js
import aiService from './services/aiService.js';

const bailiffTestCases = [
  {
    description: "Сокрытие доходов от алиментов",
    text: "Плательщик алиментов не указал доходы от сдачи квартиры в аренду",
    expected: { article: "ст. 115 СК РФ" }
  },
  {
    description: "Нарушение сроков уведомления",
    text: "Судебный пристав не направил постановление в течение 3 дней",
    expected: { article: "ст. 30 229-ФЗ" }
  }
];

async function runBailiffTests() {
  let passed = 0;
  
  for (const test of bailiffTestCases) {
    try {
      console.log(`\nТест: ${test.description}`);
      const result = await aiService.analyzeLegalText(test.text);
      
      const foundViolation = result.violations.some(v => 
        v.article.includes(test.expected.article)
      );
      
      if (foundViolation) {
        passed++;
        console.log(`✅ Найдено нарушение: ${test.expected.article}`);
      } else {
        console.warn(`❌ Не обнаружено: ${test.expected.article}`);
        console.log("Полный ответ:", result);
      }
    } catch (error) {
      console.error(`Ошибка в тесте "${test.description}":`, error.message);
    }
  }
  
  console.log(`\nРезультат: ${passed}/${bailiffTestCases.length} тестов пройдено`);
}

runBailiffTests();

====================

// Файл: frontend\src\main.js
import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'


const app = createApp(App)

const pinia = createPinia()
app.use(pinia)


app.use(router)


app.mount('#app')

====================

// Файл: frontend\src\App.vue
<template>
  <div class="app">
    <header class="app-header">
      <nav class="nav-container">
        <router-link to="/" class="nav-logo">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" class="logo-icon">
            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
          </svg>
          <span class="logo-text">Юридическая Защита Отцов</span>
        </router-link>
        <div class="nav-links">
          <router-link to="/" class="nav-link" exact-active-class="active">Главная</router-link>
          <router-link to="/documents" class="nav-link" exact-active-class="active">Документы</router-link>
          <router-link to="/complaints" class="nav-link" exact-active-class="active">Жалобы</router-link>
        </div>
      </nav>
    </header>

    <main class="app-main">
      <router-view v-slot="{ Component }">
        <transition name="fade" mode="out-in">
          <component :is="Component" />
        </transition>
      </router-view>
    </main>

    <footer class="app-footer">
      <div class="footer-content">
        <p>© 2025 Юридический сервис "Защита Отцов".</p>
      </div>
    </footer>
  </div>
</template>

<script setup>
import { watch } from 'vue'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'

const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()

// Загружаем данные при первом открытии соответствующих страниц
watch(
  () => documentStore.documents,
  (newVal) => {
    if (newVal.length === 0) { 
      documentStore.fetchDocuments()
    }
  },
  { immediate: true }
)
watch(
  () => complaintStore.complaints,
  (newVal) => {
    if (newVal.length === 0) { 
      complaintStore.fetchComplaints()
    }
  },
  { immediate: true }
)
</script>



====================

// Файл: backend\services\pdfService.js
import pdf from 'pdf-parse';

export default {
  async extractTextFromPdf(buffer) {
    try {
      console.log('Извлечение текста из PDF буфера размером:', buffer.length);
      const data = await pdf(buffer);
      console.log('Извлеченный текст из PDF:', data.text ? data.text.substring(0, 100) + '...' : 'null');
      
      // Проверка типа текста из PDF
      let validText = "";
      if (data.text !== undefined && data.text !== null) {
        if (typeof data.text === 'string') {
          validText = data.text;
        } else {
          console.log("Предупреждение: текст из PDF не является строкой:", typeof data.text);
          validText = String(data.text);
        }
      }
      
      return {
        text: validText,
        metadata: data.metadata,
        numPages: data.numpages
      };
    } catch (error) {
      console.error('PDF parsing error:', error);
      throw new Error('Не удалось обработать PDF файл');
    }
  }
}

====================

// Файл: backend\services\modelHealthCheck.js
import axios from 'axios';

export async function checkModelAvailability() {
  try {
    const response = await axios.get('http://localhost:11434', {
      timeout: 10000
    });
    return response.status === 200;
  } catch (error) {
    console.error('Модель недоступна:', error.message);
    return false;
  }
}

====================

// Файл: backend\services\FileService.js


====================

// Файл: backend\services\documentService.js
import AIService from './aiService.js';

// Создаем экземпляр AIService
const aiService = new AIService();

class DocumentService {
  constructor() {
    // Привязка методов
    this.analyzeText = this.analyzeText.bind(this);
    this.analyzeDocument = this.analyzeDocument.bind(this);
    this.analyzeAttachment = this.analyzeAttachment.bind(this);
  }

  /**
   * Анализ произвольного текста
   * @param {string} text - Текст для анализа
   * @param {string} instructions - Дополнительные инструкции для анализа
   * @param {boolean} strictMode - Режим строгого анализа
   * @returns {Promise<Object>} Результат анализа
   */
  async analyzeText(text, instructions = "", strictMode = false) {
    try {
      console.log('Анализ текста, длина текста:', text ? text.length : 0);
      
      // Проверка входных данных
      if (!text || typeof text !== 'string') {
        console.log('Предупреждение: текст не является строкой или отсутствует');
        return {
          success: true,
          data: {
            summary: "Текст не содержит данных для анализа",
            keySentences: [],
            violations: [],
            documentDate: "",
            senderAgency: ""
          },
          timestamp: new Date().toISOString()
        };
      }
      
      // Удаляем пробельные символы по краям
      const trimmedText = text.trim();
      console.log('Текст после trim, длина:', trimmedText.length);
      
      if (trimmedText.length === 0) {
        console.log('Предупреждение: текст пуст после обрезки пробелов');
        return {
          success: true,
          data: {
            summary: "Текст не содержит данных для анализа",
            keySentences: [],
            violations: [],
            documentDate: "",
            senderAgency: ""
          },
          timestamp: new Date().toISOString()
        };
      }

      console.log('Анализ текста (первые 100 символов):', trimmedText.substring(0, 100) + '...');
      
      // Проверяем доступность Ollama перед вызовом
      try {
        console.log('Проверка доступности Ollama API:', aiService.apiUrl);
        const response = await fetch(aiService.apiUrl.replace('/api/generate', '/api/tags'), { 
          method: 'GET',
          timeout: 5000
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        console.log('Ollama API доступен');
      } catch (ollamaError) {
        console.error('Ollama API недоступен:', olлamaError.message);
        console.error('Stack trace:', olлamaError.stack);
        return {
          success: true,
          data: {
            summary: "Сервис анализа временно недоступен. Пожалуйста, убедитесь, что Ollama запущена.",
            keySentences: [],
            violations: [],
            documentDate: "",
            senderAgency: ""
          },
          timestamp: new Date().toISOString()
        };
      }
      
      // Анализируем текст через AI-сервис
      console.log('Вызов aiService.analyzeLegalText');
      const analysisResult = await aiService.analyzeLegalText(
        trimmedText,
        instructions,
        strictMode
      );
      console.log('Результат анализа текста:', analysisResult);
      
      // Убедимся, что все поля присутствуют
      const cleanResult = {
        summary: analysisResult.summary || "Не удалось сгенерировать краткую суть",
        keySentences: Array.isArray(analysisResult.keySentences) ? analysisResult.keySentences : [],
        violations: Array.isArray(analysisResult.violations) ? analysisResult.violations : [],
        documentDate: analysisResult.documentDate || "",
        senderAgency: analysisResult.senderAgency || ""
      };
      
      console.log('Возвращаем результат анализа:', cleanResult);
      return {
        success: true,
        data: cleanResult,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Ошибка анализа текста:', error);
      console.error('Стек ошибки:', error.stack);
      return {
        success: true,
        data: {
          summary: "Ошибка анализа текста: " + error.message,
          keySentences: [],
          violations: [],
          documentDate: "",
          senderAgency: ""
        },
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Комплексный анализ документа с вложениями
   * @param {Object} document - Объект документа
   * @param {string} instructions - Дополнительные инструкции для анализа
   * @param {boolean} strictMode - Режим строгого анализа
   * @returns {Promise<Object>} Результат анализа документа
   */
  async analyzeDocument(document, instructions = "", strictMode = false) {
    try {
      console.log('Анализ документа, ID:', document.id);
      
      // Проверка входных данных
      if (!document || typeof document !== 'object') {
        console.log('Предупреждение: документ не является объектом или отсутствует');
        return {
          success: true,
          data: {
            summary: "Документ не содержит данных для анализа",
            keySentences: [],
            violations: [],
            documentDate: "",
            senderAgency: ""
          },
          timestamp: new Date().toISOString()
        };
      }
      
      // Анализ основного текста документа
      let mainAnalysis = {
        summary: "Документ не содержит текста для анализа",
        keySentences: [],
        violations: [],
        documentDate: "",
        senderAgency: ""
      };
      
      if (document.originalText && typeof document.originalText === 'string' && document.originalText.trim()) {
        console.log('Анализ основного текста документа, длина:', document.originalText.length);
        console.log('Текст (первые 200 символов):', document.originalText.substring(0, 200));
        const result = await this.analyzeText(document.originalText, instructions, strictMode);
        console.log('Результат анализа основного текста:', result);
        if (result.success) {
          mainAnalysis = result.data;
        }
      } else {
        console.log('Основной текст документа отсутствует или пуст');
      }
      
      // Анализ вложений
      const attachmentsAnalysis = [];
      if (Array.isArray(document.attachments) && document.attachments.length > 0) {
        console.log('Анализ вложений документа, количество:', document.attachments.length);
        
        for (const attachment of document.attachments) {
          if (attachment.text && typeof attachment.text === 'string' && attachment.text.trim()) {
            console.log('Анализ вложения:', attachment.id, 'длина текста:', attachment.text.length);
            console.log('Текст вложения (первые 200 символов):', attachment.text.substring(0, 200));
            const result = await this.analyzeAttachment(attachment.text, instructions);
            console.log('Результат анализа вложения:', result);
            if (result.success) {
              attachmentsAnalysis.push({
                id: attachment.id,
                ...result.data
              });
            }
          } else {
            console.log('Вложение', attachment.id, 'не содержит текста для анализа');
          }
        }
      } else {
        console.log('Вложения отсутствуют');
      }
      
      // Комбинируем результаты
      const combinedResult = {
        summary: mainAnalysis.summary,
        keySentences: mainAnalysis.keySentences,
        violations: mainAnalysis.violations,
        documentDate: mainAnalysis.documentDate || "",
        senderAgency: mainAnalysis.senderAgency || "",
        attachments: attachmentsAnalysis
      };
      
      console.log('Возвращаем результат анализа документа:', JSON.stringify(combinedResult, null, 2));
      return {
        success: true,
        data: combinedResult,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Ошибка анализа документа:', error);
      console.error('Стек ошибки:', error.stack);
      return {
        success: true,
        data: {
          summary: "Ошибка анализа документа: " + error.message,
          keySentences: [],
          violations: [],
          documentDate: "",
          senderAgency: ""
        },
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Анализ вложения
   * @param {string} text - Текст вложения
   * @param {string} instructions - Дополнительные инструкции для анализа
   * @returns {Promise<Object>} Результат анализа вложения
   */
  async analyzeAttachment(text, instructions = "") {
    try {
      console.log('Анализ вложения, длина текста:', text ? text.length : 0);
      
      // Проверка входных данных
      if (!text || typeof text !== 'string') {
        console.log('Предупреждение: текст вложения не является строкой или отсутствует');
        return {
          success: true,
          data: {
            documentType: "Пустой документ",
            sentDate: "",
            senderAgency: "",
            summary: "Вложение не содержит текста для анализа",
            keySentences: []
          },
          timestamp: new Date().toISOString()
        };
      }
      
      // Удаляем пробельные символы по краям
      const trimmedText = text.trim();
      
      if (trimmedText.length === 0) {
        console.log('Предупреждение: текст вложения пуст после обрезки пробелов');
        return {
          success: true,
          data: {
            documentType: "Пустой документ",
            sentDate: "",
            senderAgency: "",
            summary: "Вложение не содержит текста для анализа",
            keySentences: []
          },
          timestamp: new Date().toISOString()
        };
      }

      console.log('Анализ вложения (первые 100 символов):', trimmedText.substring(0, 100) + '...');
      
      // Анализируем вложение через AI-сервис
      console.log('Вызов aiService.analyzeAttachment');
      const analysisResult = await aiService.analyzeAttachment(trimmedText, instructions);
      console.log('Результат анализа вложения:', analysisResult);

      // Убедимся, что все поля присутствуют
      const cleanResult = {
        documentType: analysisResult.documentType || "Неизвестный тип",
        sentDate: analysisResult.sentDate || "",
        senderAgency: analysisResult.senderAgency || "",
        summary: analysisResult.summary || "Не удалось сгенерировать краткую суть",
        keySentences: Array.isArray(analysisResult.keySentences) ? analysisResult.keySentences : []
      };
      
      console.log('Возвращаем результат анализа вложения:', cleanResult);
      return {
        success: true,
        data: cleanResult,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Ошибка анализа вложения:', error);
      return {
        success: true,
        data: {
          documentType: "Неизвестный тип",
          sentDate: "",
          senderAgency: "",
          summary: "Ошибка анализа вложения: " + error.message,
          keySentences: []
        },
        timestamp: new Date().toISOString()
      };
    }
  }
}

// Создаем экземпляр сервиса
const documentService = new DocumentService();

// Экспортируем методы
export const analyzeText = documentService.analyzeText.bind(documentService);
export const analyzeDocument = documentService.analyzeDocument.bind(documentService);
export const analyzeAttachment = documentService.analyzeAttachment.bind(documentService);

// Экспортируем класс для тестирования
export { DocumentService };

// Экспортируем экземпляр сервиса для прямого использования
export default documentService;

====================

// Файл: backend\services\complaintService.js
import { v4 as uuidv4 } from 'uuid';
import AIService from './aiService.js';

// Создаем экземпляр AIService
const aiService = new AIService();

class ComplaintService {
  constructor() {
    this.generateComplaint = this.generateComplaint.bind(this);
    this.generateUnifiedComplaint = this.generateUnifiedComplaint.bind(this);
  }

  // ЕДИНСТВЕННЫЙ унифицированный метод для генерации жалоб
  async generateUnifiedComplaint(db, requestData) {
    try {
      console.log('Генерация жалобы из данных:', requestData);
      
      const { documentId, agency, currentDocument, relatedDocuments } = requestData;
      
      // Проверка обязательных полей
      if (!agency) {
        throw new Error('Не указано ведомство');
      }

      // Получаем данные основного документа
      const mainDocData = await this.getMainDocumentData(db, documentId, currentDocument);
      
      // Получаем данные связанных документов
      const relatedDocsData = await this.getRelatedDocumentsData(db, documentId, mainDocData, relatedDocuments);
      
      // Генерируем жалобу через AI
      const complaintResult = await this.generateWithAI(mainDocData, relatedDocsData, agency);
      
      // Создаем и сохраняем объект жалобы
      const complaint = this.createComplaintObject(mainDocData, agency, relatedDocsData, complaintResult, documentId);
      
      // Сохраняем в БД
      await this.saveComplaintToDB(db, complaint, mainDocData);
      
      console.log('Жалоба успешно создана и сохранена');
      return complaint;

    } catch (error) {
      console.error('Ошибка в generateUnifiedComplaint:', error);
      throw error;
    }
  }

  // Получение данных основного документа
  async getMainDocumentData(db, documentId, currentDocument) {
    if (currentDocument && currentDocument.originalText) {
      console.log('Используем переданные данные документа');
      return this.normalizeDocumentData(currentDocument);
    }

    if (documentId) {
      console.log('Ищем документ в БД по ID:', documentId);
      const doc = db.data.documents.find(d => d.id === documentId);
      if (!doc) {
        throw new Error('Document not found');
      }
      return this.normalizeDocumentData(doc);
    }

    throw new Error('Не указан documentId и не переданы данные документа');
  }

  // Получение данных связанных документов
  async getRelatedDocumentsData(db, documentId, mainDocData, relatedDocuments) {
    if (relatedDocuments && relatedDocuments.length > 0) {
      console.log('Используем переданные связанные документы');
      return relatedDocuments.map(doc => this.normalizeDocumentData(doc));
    }

    if (documentId && db.data.documents) {
      console.log('Ищем связанные документы в БД');
      return db.data.documents.filter(d => 
        d.id !== documentId && 
        d.date && 
        mainDocData.date && 
        d.date <= mainDocData.date
      ).map(doc => this.normalizeDocumentData(doc));
    }

    return [];
  }

  // Нормализация данных документа
  normalizeDocumentData(doc) {
    return {
      id: doc.id || uuidv4(),
      originalText: doc.originalText || '',
      summary: doc.summary || '',
      keySentences: Array.isArray(doc.keySentences) ? doc.keySentences : [],
      violations: Array.isArray(doc.violations) ? doc.violations : [],
      documentDate: doc.documentDate || doc.date || '',
      senderAgency: doc.senderAgency || doc.agency || '',
      date: doc.date || new Date().toISOString().split('T')[0],
      agency: doc.agency || ''
    };
  }

  // Генерация жалобы через AI
  async generateWithAI(mainDocData, relatedDocsData, agency) {
    try {
      const prompt = this.buildAIPrompt(mainDocData, relatedDocsData, agency);
      console.log('Отправка запроса к AI с промптом:', prompt.substring(0, 200) + '...');
      
      // Проверим наличие текста в документе
      if (!mainDocData.originalText || mainDocData.originalText.trim().length === 0) {
        console.log('Внимание: основной документ не содержит текста');
        if (mainDocData.summary) {
          console.log('Используется summary документа:', mainDocData.summary.substring(0, 100) + '...');
        }
      } else {
        console.log('Текст основного документа (первые 200 символов):', mainDocData.originalText.substring(0, 200) + '...');
      }
      
      const response = await aiService.queryLocalModel(prompt, {
        temperature: 0.6,
        taskType: "complaint",
        format: "json"
      });
      
      console.log('Ответ от AI получен:', typeof response);
      if (typeof response === 'string') {
        console.log('Ответ от AI (первые 200 символов):', response.substring(0, 200));
      } else {
        console.log('Ответ от AI (объект):', JSON.stringify(response).substring(0, 200));
      }
      
      return this.parseAIResponse(response);
      
    } catch (aiError) {
      console.error('Ошибка AI генерации:', aiError);
      console.error('Стек ошибки:', aiError.stack);
      // Возвращаем запасной вариант
      return {
        content: this.generateFallbackComplaint(mainDocData, agency)
      };
    }
  }

  // Построение промпта для AI
  buildAIPrompt(mainDocData, relatedDocsData, agency) {
    // Создаем структурированные данные для AI
    const analysisData = {
      task: "GENERATE_COMPLAINT",
      agency: agency,
      mainDocument: {
        summary: mainDocData.summary,
        keySentences: mainDocData.keySentences.slice(0, 10), // Ограничиваем количество
        violations: mainDocData.violations,
        documentDate: mainDocData.documentDate,
        senderAgency: mainDocData.senderAgency
      },
      hasRelatedDocuments: relatedDocsData.length > 0,
      relatedDocumentsCount: relatedDocsData.length
    };

    return `Ты - профессиональный юрист. Создай официальную жалобу в ${agency} от первого лица заявителя.

ОСНОВНЫЕ ДАННЫЕ:
${JSON.stringify(analysisData, null, 2)}

ИНСТРУКЦИИ:
1. Создай структурированную жалобу в формате делового письма от первого лица
2. Используй деловой стиль, строго по существу
3. Укажи конкретные нарушения законов
4. Сделай ссылки на статьи законов
5. Предложи конкретные требования
6. Не включай полный текст документа

Верни результат в формате JSON:
{
  "content": "текст жалобы"
}`;
  }

  // Парсинг ответа AI
  parseAIResponse(response) {
    try {
      if (typeof response === 'string') {
        // Пытаемся найти JSON в строке
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          const parsed = JSON.parse(jsonMatch[0]);
          return {
            content: parsed.content || parsed.complaint || response
          };
        }
        return { content: response };
      }
      
      if (typeof response === 'object') {
        return {
          content: response.content || response.complaint || JSON.stringify(response)
        };
      }
      
      return { content: 'Не удалось сгенерировать жалобу' };
      
    } catch (e) {
      console.error('Ошибка парсинга ответа AI:', e);
      return { content: response || 'Не удалось сгенерировать жалобу' };
    }
  }

  // Запасной вариант генерации жалобы
  generateFallbackComplaint(documentData, agency) {
    return `Жалоба в ${agency}

Основание: ${documentData.summary || 'Нарушение прав заявителя'}

Дата документа: ${documentData.documentDate || 'не указана'}
Ведомство-отправитель: ${documentData.senderAgency || 'не указано'}

Уважаемые сотрудники ${agency}!

На основании полученного документа сообщаю о нарушении моих прав. 

Прошу:
1. Провести проверку по изложенным фактам
2. Принять меры по устранению нарушений
3. Уведомить меня о результатах рассмотрения

Приложение: копия документа от ${documentData.documentDate}

Дата: ${new Date().toLocaleDateString('ru-RU')}
Подпись: _________________`;
  }

  // Создание объекта жалобы
  createComplaintObject(mainDocData, agency, relatedDocsData, complaintResult, documentId) {
    return {
      id: uuidv4(),
      documentId: documentId || mainDocData.id,
      agency: agency,
      content: complaintResult.content,
      relatedDocuments: relatedDocsData.map(d => d.id),
      status: 'draft',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      analysis: {
        violations: mainDocData.violations || []
      }
    };
  }

  // Сохранение жалобы в БД
  async saveComplaintToDB(db, complaint, mainDocData) {
    try {
      // Инициализируем коллекцию жалоб если нет
      if (!db.data.complaints) {
        db.data.complaints = [];
      }
      
      // Добавляем жалобу
      db.data.complaints.push(complaint);
      
      // Обновляем документ если он есть в БД
      if (mainDocData.id && db.data.documents) {
        const doc = db.data.documents.find(d => d.id === mainDocData.id);
        if (doc) {
          if (!doc.complaints) {
            doc.complaints = [];
          }
          doc.complaints.push(complaint.id);
        }
      }
      
      // Сохраняем изменения
      await db.write();
      
    } catch (dbError) {
      console.error('Ошибка сохранения в БД:', dbError);
      throw new Error('Не удалось сохранить жалобу в базу данных');
    }
  }

  // Старый метод для обратной совместимости
  async generateComplaint(complaintData) {
    console.log("Использование старого метода generateComplaint");
    
    // Адаптируем старый формат к новому
    const requestData = {
      agency: complaintData.agency || "ФССП",
      currentDocument: complaintData.currentDocument || complaintData,
      relatedDocuments: complaintData.relatedDocuments || []
    };
    
    // Создаем mock db объекта для совместимости
    const mockDB = {
      data: {
        documents: [],
        complaints: []
      },
      write: () => Promise.resolve()
    };
    
    try {
      const result = await this.generateUnifiedComplaint(mockDB, requestData);
      return result;
    } catch (error) {
      console.error('Ошибка в generateComplaint:', error);
      return {
        content: this.generateFallbackComplaint(
          complaintData.currentDocument || complaintData, 
          complaintData.agency || "ФССП"
        )
      };
    }
  }
}

// Создаем экземпляр сервиса
const complaintService = new ComplaintService();

// Экспортируем методы для обратной совместимости
export const generateUnifiedComplaint = complaintService.generateUnifiedComplaint.bind(complaintService);
export const generateComplaint = complaintService.generateComplaint.bind(complaintService);

// Экспортируем класс для тестирования
export { ComplaintService };

====================

// Файл: backend\services\aiService.js
import axios from "axios";

class AIService {
  constructor(apiUrl, activeModel) {
    this.apiUrl = apiUrl || "http://localhost:11434/api/generate";
    this.activeModel = activeModel || "llama3.1/18/8192";
    this.defaultOptions = {
      temperature: 0.3,
      repeat_penalty: 1.2,
      format: "json",
    };
    this.analysisCache = new Map();
    this.cacheTimestamps = new Map(); // Stores timestamps for cache entries
    this.maxCacheSize = 100; // Cache size limit
    this.cacheTTL = 30 * 60 * 1000; // 30 minutes TTL in milliseconds
    this.maxRetries = 2;
    // Explicit method binding
    this.queryLocalModel = this.queryLocalModel.bind(this);
    this.analyzeLegalText = this.analyzeLegalText.bind(this);
    this.safeParseResponse = this.safeParseResponse.bind(this);
    this.analyzeAttachment = this.analyzeAttachment.bind(this);
  }

  async queryLocalModel(prompt, customOptions = {}) {
    try {
      console.log("queryLocalModel called");
      console.log("API URL:", this.apiUrl);
      console.log("Model:", this.activeModel);
      console.log("Prompt type:", typeof prompt);
      console.log("Custom options:", customOptions);
      
      // Limit prompt length
      let processedPrompt = prompt;
      if (typeof prompt === 'string' && prompt.length > 25000) {
        processedPrompt = prompt.substring(0, 25000);
        console.log("Prompt truncated to 25000 characters");
      } else if (typeof prompt === 'object' && JSON.stringify(prompt).length > 25000) {
        // For objects, limit JSON string length
        processedPrompt = JSON.stringify(prompt).substring(0, 25000);
        console.log("Prompt object truncated to 25000 characters");
      }

      // Prepare parameters for Ollama API
      const ollamaOptions = {
        temperature: customOptions.temperature || this.defaultOptions.temperature,
        repeat_penalty: customOptions.repeat_penalty || this.defaultOptions.repeat_penalty,
        // max_tokens is not used in Ollama API, there are other parameters instead
      };

      // Prepare prompt with strictMode consideration
      const promptOptions = {
        ...customOptions,
        strictMode: customOptions.strictMode || false
      };
      const preparedPrompt = this.preparePrompt(processedPrompt, customOptions.taskType, promptOptions);

      console.log("Sending request to AI model:", {
        url: this.apiUrl,
        model: this.activeModel,
        prompt: typeof preparedPrompt === 'object' ? JSON.stringify(preparedPrompt, null, 2) : preparedPrompt.substring(0, 200) + '...',
        options: ollamaOptions
      });

      try {
        const requestData = {
          model: this.activeModel,
          prompt: typeof preparedPrompt === 'object' ? JSON.stringify(preparedPrompt, null, 2) : preparedPrompt,
          stream: false,
          options: ollamaOptions,
        };

        // If format=json, add format to options
        if (customOptions.format === "json") {
          requestData.options.format = "json";
          // Add clear instruction to prompt for JSON return
          requestData.prompt += "\n\nSTRICT RESPONSE REQUIREMENTS:\n" +
            "1. RESPOND ONLY IN JSON FORMAT\n" +
            "2. DO NOT ADD ANY ADDITIONAL TEXTS OR COMMENTS\n" +
            "3. DO NOT USE Markdown OR OTHER FORMATS\n" +
            "4. RETURN ONLY VALID JSON\n" +
            "RESPONSE FORMAT EXAMPLE:\n" +
            "{\n" +
            "  \"summary\": \"here is the brief summary\",\n" +
            "  \"keySentences\": [\"sentence 1\", \"sentence 2\"],\n" +
            "  \"violations\": []\n" +
            "}";
        }

        console.log("Sending request to Ollama API");
        const response = await axios.post(
          this.apiUrl,
          requestData,
          { 
            timeout: 500000,
            headers: {
              'Content-Type': 'application/json'
            }
          }
        );
        console.log("Response from Ollama API received");

        console.log("Response from AI model:", response.data);
        const result = this.safeParseResponse(response.data);
        console.log("Parsed response:", result);
        return result;
      } catch (error) {
        console.error("Error requesting model:", error);
        console.error("Error stack:", error.stack);
        if (error.code === 'ECONNREFUSED') {
          throw new Error("Не удалось подключиться к Ollama. Пожалуйста, убедитесь, что Ollama запущена и доступна по адресу " + this.apiUrl);
        }
        if (error.code === 'ECONNRESET') {
          throw new Error("Соединение с Ollama было сброшено. Пожалуйста, проверьте стабильность подключения.");
        }
        if (error.response) {
          // Server responded with error status
          console.error("Response error data:", error.response.data);
          console.error("Response error status:", error.response.status);
          console.error("Response error headers:", error.response.headers);
          throw new Error(`AI Model error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
        } else if (error.request) {
          // Request was made but no response received
          console.error("No response received:", error.request);
          throw new Error("No response received from AI Model. Please check if the service is running.");
        } else {
          // Something else happened
          console.error("Error message:", error.message);
          throw new Error(`Error in AI Model request: ${error.message}`);
        }
      }
    } catch (error) {
      console.error("Unexpected error in queryLocalModel:", error);
      console.error("Error stack:", error.stack);
      throw error;
    }
  }

  async analyzeLegalText(text, instructions = "", strictMode = false) {
    try {
      console.log("analyzeLegalText called with text length:", text ? text.length : 0);
      console.log("Instructions:", instructions);
      console.log("Strict mode:", strictMode);
      
      if (!text || typeof text !== 'string') {
        console.log("Invalid text input");
        return {
          summary: "Invalid text input",
          keySentences: [],
          violations: [],
          documentDate: "",
          senderAgency: "",
        };
      }
      
      // Limit text length for processing
      let processedText = text;
      if (text.length > 25000) {
        processedText = text.substring(0, 25000);
        console.log("Text truncated to 25000 characters");
      }
      
      console.log("Sending text:", processedText.substring(0, 200) + "...");
      
      // Clean up expired cache entries
      this.cleanupExpiredCache();
      
      const cacheKey = this.generateCacheKey(processedText, instructions);

      // Check cache with TTL consideration
      if (this.analysisCache.has(cacheKey)) {
        const timestamp = this.cacheTimestamps.get(cacheKey);
        if (timestamp && (Date.now() - timestamp <= this.cacheTTL)) {
          console.log("Returning cached result");
          return this.analysisCache.get(cacheKey);
        } else {
          // Remove expired entry
          this.analysisCache.delete(cacheKey);
          this.cacheTimestamps.delete(cacheKey);
        }
      }

      try {
        console.log("Building analysis prompt");
        const promptData = this.buildAnalysisPrompt(processedText, instructions, strictMode);
        console.log("Prompt built, calling queryLocalModel");
        
        const result = await this.queryLocalModel(promptData, {
          temperature: 0.3,
          format: "json",
        });

        console.log("Model response received:", typeof result);
        if (typeof result === 'string') {
          console.log("Model response (first 200 chars):", result.substring(0, 200));
        }

        const parsedResult = this.safeParseResponse(result);
        console.log("Parsed result:", parsedResult);

        // If parsing failed, return error object
        if (!parsedResult) {
          console.log("Failed to parse model response");
          return {
            summary: "Failed to parse model response",
            keySentences: [],
            violations: [],
            documentDate: "",
            senderAgency: "",
          };
        }

        // Extract data from result
        const summary = parsedResult.summary || parsedResult.content || "Failed to generate brief summary";
        const keySentences = Array.isArray(parsedResult.keySentences) 
          ? parsedResult.keySentences.filter((p) => p && p.length > 5)
          : (Array.isArray(parsedResult.content) 
            ? parsedResult.content.filter((p) => p && p.length > 5)
            : []);
        const violations = Array.isArray(parsedResult.violations) 
          ? parsedResult.violations
          : [];
        const documentDate = parsedResult.documentDate || parsedResult.sentDate || this.extractDate(processedText) || "";
        const senderAgency = parsedResult.senderAgency || parsedResult.agency || this.extractAgency(processedText) || "";

        const enhancedResult = {
          summary,
          keySentences,
          violations,
          documentDate,
          senderAgency,
        };

        // Cache size management
        if (this.analysisCache.size >= this.maxCacheSize) {
          // Remove first element (least recently used)
          const firstKey = this.analysisCache.keys().next().value;
          if (firstKey) {
            this.analysisCache.delete(firstKey);
            this.cacheTimestamps.delete(firstKey);
          }
        }
        
        // Save result to cache with timestamp
        this.analysisCache.set(cacheKey, enhancedResult);
        this.cacheTimestamps.set(cacheKey, Date.now());
        
        console.log("Analysis completed successfully:", enhancedResult);
        return enhancedResult;
      } catch (error) {
        console.error("Error in analyzeLegalText:", error);
        console.error("Error stack:", error.stack);
        // Return default object in case of error
        return {
          summary: "Error analyzing document: " + error.message,
          keySentences: [],
          violations: [],
          documentDate: "",
          senderAgency: "",
        };
      }
    } catch (error) {
      console.error("Unexpected error in analyzeLegalText:", error);
      console.error("Error stack:", error.stack);
      return {
        summary: "Unexpected error: " + error.message,
        keySentences: [],
        violations: [],
        documentDate: "",
        senderAgency: "",
      };
    }
  }

  safeParseResponse(response) {
    // If response is already an object, return it as is
    if (typeof response === "object" && response !== null) {
      return response;
    }
    
    // If response is a string
    if (typeof response === "string") {
      // Attempt 1: Direct parsing of entire string as JSON
      try {
        return JSON.parse(response);
      } catch (directParseError) {
        console.error("Direct JSON parse failed:", directParseError);
        // Attempt 2: Extract JSON from markdown code blocks
        try {
          const jsonMatch = response.match(/```(?:json)?\s*({.*?})\s*```/s);
          if (jsonMatch && jsonMatch[1]) {
            return JSON.parse(jsonMatch[1]);
          }
        } catch (markdownParseError) {
          console.error("Markdown JSON parse failed:", markdownParseError);
        }
        
        // Attempt 3: Manual extraction of key fields
        try {
          const summaryMatch = response.match(/"summary"\s*:\s*"([^"]+)"/);
          const keySentencesMatch = response.match(/"keySentences"\s*:\s*($$[^$$]*$$)/);
          const violationsMatch = response.match(/"violations"\s*:\s*($$[^$$]*$$)/);
          
          return {
            summary: summaryMatch ? summaryMatch[1] : "Failed to extract summary",
            keySentences: keySentencesMatch ? JSON.parse(keySentencesMatch[1]) : [],
            violations: violationsMatch ? JSON.parse(violationsMatch[1]) : []
          };
        } catch (manualParseError) {
          console.error("Manual JSON parse failed:", manualParseError);
        }
      }
    }
    
    // If all parsing attempts failed
    console.error("All parsing attempts failed for response:", response);
    return null;
  }

  async analyzeAttachment(text, instructions = "") {
    try {
      console.log("analyzeAttachment called with text length:", text ? text.length : 0);
      
      if (!text || typeof text !== 'string') {
        console.log("Invalid text input for attachment");
        return {
          documentType: "Invalid input",
          sentDate: "",
          senderAgency: "",
          summary: "Invalid text input",
          keySentences: [],
        };
      }
      
      // Limit text length for processing
      let processedText = text;
      if (text.length > 25000) {
        processedText = text.substring(0, 25000);
        console.log("Attachment text truncated to 25000 characters");
      }
      
      console.log("Sending attachment text:", processedText.substring(0, 200) + "...");
      
      const promptData = this.buildAttachmentAnalysisPrompt(processedText, instructions);
      
      const result = await this.queryLocalModel(promptData, {
        temperature: 0.2,
        format: "json",
        taskType: "attachment"
      });

      const parsedResult = this.safeParseResponse(result);
      
      if (!parsedResult) {
        return {
          documentType: "Failed to parse",
          sentDate: "",
          senderAgency: "",
          summary: "Failed to parse model response",
          keySentences: [],
        };
      }

      return {
        documentType: parsedResult.documentType || "Unknown",
        sentDate: parsedResult.sentDate || parsedResult.documentDate || "",
        senderAgency: parsedResult.senderAgency || parsedResult.agency || "",
        summary: parsedResult.summary || parsedResult.content || "Failed to generate summary",
        keySentences: Array.isArray(parsedResult.keySentences) 
          ? parsedResult.keySentences.filter((p) => p && p.length > 5)
          : (Array.isArray(parsedResult.content) 
            ? parsedResult.content.filter((p) => p && p.length > 5)
            : []),
      };
    } catch (error) {
      console.error("Error in analyzeAttachment:", error);
      return {
        documentType: "Error",
        sentDate: "",
        senderAgency: "",
        summary: "Error analyzing attachment: " + error.message,
        keySentences: [],
      };
    }
  }

  extractDate(text) {
    // Implementation for date extraction
    const dateRegex = /(\d{1,2}[.\-\/]\d{1,2}[.\-\/]\d{2,4})|(\d{4}[.\-\/]\d{1,2}[.\-\/]\d{1,2})/;
    const match = text.match(dateRegex);
    return match ? match[0] : "";
  }

  extractAgency(text) {
    // Implementation for agency extraction
    const agencies = ["ФССП", "Прокуратура", "Суд", "Омбудсмен"];
    return agencies.find((agency) => text.includes(agency)) || "";
  }

  buildAnalysisPrompt(text, instructions, strictMode) {
    // Implementation for building analysis prompt
    return {
      task: "legal_analysis",
      text: text,
      instructions: instructions,
      strictMode: strictMode
    };
  }

  buildAttachmentAnalysisPrompt(text, instructions = "") {
    // Implementation for building attachment analysis prompt
    return {
      task: "attachment_analysis",
      text: text,
      instructions: instructions
    };
  }

  preparePrompt(prompt, taskType, options) {
    // Если prompt является объектом (как в случае с buildAnalysisPrompt), используем его поля
    if (typeof prompt === 'object' && prompt !== null) {
      const { text, instructions, strictMode, task } = prompt;
      
      // Формируем промпт в зависимости от типа задачи
      let basePrompt = text || "";
      
      // Добавляем инструкции, если они есть
      if (instructions && instructions.trim()) {
        basePrompt = `${basePrompt}

ДОПОЛНИТЕЛЬНЫЕ ИНСТРУКЦИИ:
${instructions}`;
      }
      
      // Добавляем указания по режиму строгого анализа
      if (strictMode) {
        basePrompt = `${basePrompt}

ПРИМЕНЯЙТЕ СТРОГИЙ АНАЛИЗ ДОКУМЕНТА.`;
      }
      
      // Добавляем общие указания по формату ответа в зависимости от типа задачи
      switch (task) {
        case 'legal_analysis':
          basePrompt = `${basePrompt}

ПРОАНАЛИЗИРУЙТЕ ДОКУМЕНТ И ПРЕДОСТАВЬТЕ СТРУКТУРИРОВАННЫЙ ОТВЕТ В ФОРМАТЕ JSON С ПОЛЯМИ:
- summary: краткая суть документа
- keySentences: массив важных предложений
- violations: массив выявленных нарушений
- documentDate: дата документа
- senderAgency: ведомство-отправитель`;
          break;
        case 'summary':
          basePrompt = `${basePrompt}

СОЗДАЙТЕ КРАТКУЮ СУТЬ ДОКУМЕНТА.`;
          break;
        case 'paragraphs':
          basePrompt = `${basePrompt}

ИЗВЛЕЧИТЕ ВАЖНЫЕ ПРЕДЛОЖЕНИЯ ИЗ ДОКУМЕНТА.`;
          break;
        case 'violations':
          basePrompt = `${basePrompt}

ВЫЯВИТЕ ВОЗМОЖНЫЕ НАРУШЕНИЯ В ДОКУМЕНТЕ.`;
          break;
        case 'attachment_analysis':
          basePrompt = `${basePrompt}

ПРОАНАЛИЗИРУЙТЕ ВЛОЖЕНИЕ И ПРЕДОСТАВЬТЕ СТРУКТУРИРОВАННЫЙ ОТВЕТ В ФОРМАТЕ JSON С ПОЛЯМИ:
- documentType: тип документа
- sentDate: дата отправки
- senderAgency: ведомство-отправитель
- summary: краткая суть
- keySentences: массив важных предложений`;
          break;
      }
      
      return basePrompt;
    }
    
    // Если prompt - строка, возвращаем её как есть
    return prompt;
  }

  generateCacheKey(text, instructions) {
    // Implementation for generating cache key
    return `${text.substring(0, 100)}_${instructions}`;
  }

  cleanupExpiredCache() {
    // Implementation for cleaning up expired cache
    const now = Date.now();
    for (const [key, timestamp] of this.cacheTimestamps.entries()) {
      if (now - timestamp > this.cacheTTL) {
        this.analysisCache.delete(key);
        this.cacheTimestamps.delete(key);
      }
    }
  }

  clearCache() {
    // Implementation for clearing cache
    this.analysisCache.clear();
    this.cacheTimestamps.clear();
  }

  getCacheStats() {
    // Implementation for getting cache stats
    return {
      size: this.analysisCache.size,
      max_size: this.maxCacheSize,
      ttl: this.cacheTTL
    };
  }

  normalizeError(error) {
    // Implementation for normalizing error
    return error;
  }
}

export default AIService;

====================

// Файл: backend\routes\documentRoutes.js
import { Router } from 'express';
import express from 'express';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import fs from 'fs/promises';

import pdfService from '../services/pdfService.js';
import { fileURLToPath } from 'url';
import { analyzeText, analyzeDocument, analyzeAttachment } from '../services/documentService.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default function documentRoutes({ db, upload }) {
  const router = Router();

  // Middleware для проверки JSON только для POST и PUT запросов с JSON телом
  router.use((req, res, next) => {
    if ((req.method === 'POST' || req.method === 'PUT') && req.is('application/json')) {
      express.json({
        verify: (req, res, buf, encoding) => {
          try {
            if (buf.length > 0) {
              JSON.parse(buf.toString());
            }
          } catch (e) {
            console.error('Invalid JSON:', buf.toString());
            // Отправляем ошибку и завершаем обработку
            res.status(400).json({ message: 'Invalid JSON' });
            // Не выбрасываем ошибку, а просто возвращаемся
            return;
          }
        }
      })(req, res, next);
    } else {
      next();
    }
  });

  // Извлечение текста из файла
  const extractFileContent = async (file) => {
    console.log('Извлечение текста из файла:', file);
    if (file.mimetype === 'application/pdf') {
      const dataBuffer = await fs.readFile(file.path);
      const pdfData = await pdfService.extractTextFromPdf(dataBuffer);
      console.log('Извлеченный текст из PDF:', pdfData.text ? pdfData.text.substring(0, 100) + '...' : 'null');
      
      // Проверка типа текста из PDF
      if (pdfData.text !== undefined && pdfData.text !== null) {
        if (typeof pdfData.text === 'string') {
          return pdfData.text;
        } else {
          console.log("Предупреждение: текст из PDF не является строкой:", typeof pdfData.text);
          return String(pdfData.text);
        }
      }
      return "";
    } else if (file.mimetype === 'text/plain') {
      const text = await fs.readFile(file.path, 'utf-8');
      console.log('Извлеченный текст из TXT:', text ? text.substring(0, 100) + '...' : 'null');
      
      // Проверка типа текста из TXT
      if (text !== undefined && text !== null) {
        if (typeof text === 'string') {
          return text;
        } else {
          console.log("Предупреждение: текст из TXT не является строкой:", typeof text);
          return String(text);
        }
      }
      return "";
    }
    throw new Error('Неподдерживаемый тип файла');
  };

  // Обработка загруженных файлов
  const processUploadedFiles = async (files, userText, userComments) => {
    console.log('Обработка загруженных файлов:', { files, userText, userComments });
    if (!files || files.length === 0) {
      throw new Error('Нет файлов для загрузки');
    }

    // Проверяем тип userText
    let validUserText = "";
    if (userText !== undefined && userText !== null) {
      if (typeof userText === 'string') {
        validUserText = userText;
      } else {
        console.log("Предупреждение: userText не является строкой:", typeof userText);
        validUserText = String(userText);
      }
    }

    const filesData = [];
    
    for (const file of files) {
      try {
        console.log('Обработка файла:', file);
        const fileContent = await extractFileContent(file);
        console.log('Извлеченный текст из файла:', fileContent ? fileContent.text.substring(0, 100) + '...' : 'null');
        
        // Комбинируем пользовательский текст и текст из файла
        // Если пользовательский текст пуст, используем только текст из файла
        // Если текст из файла пуст, используем только пользовательский текст
        const combinedText = [validUserText, fileContent].filter(Boolean).join('');
        console.log('Комбинированный текст:', combinedText ? combinedText.substring(0, 100) + '...' : 'null');

        const newDocument = {
          id: uuidv4(),
          date: new Date().toISOString().split('T')[0],
          agency: '',
          originalText: combinedText || '', 
          summary: '',
          documentDate: '',
          senderAgency: '',
          keySentences: [],
          attachments: [{
            id: uuidv4(),
            name: file.originalname,
            type: file.mimetype,
            size: file.size,
            path: `/uploads/${file.filename}`,
            text: fileContent || '', 
            analysis: null,
            documentDate: '',
            senderAgency: '',
            summary: '',
            keySentences: []
          }],
          complaints: [],
          analysisStatus: 'pending',
          lastAnalyzedAt: null,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          violations: []
        };

        console.log('Созданный документ из файла:', newDocument);

        // Инициализация коллекции документов, если её нет
        if (!db.data) {
          db.data = {};
        }
        if (!db.data.documents) {
          db.data.documents = [];
        }

        db.data.documents.push(newDocument);
        await db.write();
        filesData.push(newDocument);
        try {
          await fs.unlink(file.path);
        } catch (unlinkError) {
          console.error(`Не удалось удалить временный файл ${file.path}:`, unlinkError);
          // Не прерываем выполнение, просто логируем ошибку
        }
      } catch (fileError) {
        console.error(`Ошибка обработки файла ${file.originalname}:`, fileError);
        continue;
      }
    }

    console.log('Обработанные файлы:', filesData);
    return filesData;
  };

  // Обновление данных анализа
  const updateDocumentAnalysis = (doc, analysis) => {
    console.log("Обновление данных анализа для документа", doc.id);
    console.log("Анализ:", analysis);
    
    // Проверяем, что analysis является объектом
    if (!analysis || typeof analysis !== 'object') {
      console.log("Предупреждение: analysis не является объектом:", typeof analysis);
      // Используем пустой объект как значение по умолчанию
      analysis = {};
    }
    
    doc.summary = analysis.summary || doc.summary || "";
    doc.documentDate = analysis.documentDate || doc.documentDate || "";
    doc.senderAgency = analysis.senderAgency || doc.senderAgency || "";
    doc.keySentences = Array.isArray(analysis.keySentences) ? analysis.keySentences : 
                      (Array.isArray(doc.keySentences) ? doc.keySentences : []);
    // Добавляем обработку нарушений
    doc.violations = Array.isArray(analysis.violations) ? analysis.violations : 
                    (Array.isArray(doc.violations) ? doc.violations : []);
    doc.analysisStatus = 'completed';
    doc.lastAnalyzedAt = new Date().toISOString();
    doc.updatedAt = new Date().toISOString();
    console.log("Данные анализа обновлены для документа", doc.id);
  };

  // Сохранение жалобы
  const saveComplaint = (doc, complaint) => {
    if (!db.data.complaints) {
      db.data.complaints = [];
    }
    db.data.complaints.push(complaint);

    if (!doc.complaints) {
      doc.complaints = [];
    }
    doc.complaints.push(complaint.id);
    doc.updatedAt = new Date().toISOString();
  };

  // Загрузка документа (текст + файлы)
  router.post('/upload', upload.array('files'), async (req, res) => {
    try {
      // Проверка типа userText
      let userText = "";
      if (req.body.text !== undefined && req.body.text !== null) {
        if (typeof req.body.text === 'string') {
          userText = req.body.text;
        } else {
          console.log("Предупреждение: userText не является строкой:", typeof req.body.text);
          userText = String(req.body.text);
        }
      }
      
      const userComments = req.body.comments || "";
      console.log('Получены данные для загрузки:', { userText, userComments, files: req.files });

      // Обработка только текста
      if (userText && (!req.files || req.files.length === 0)) {
        const newDocument = {
          id: uuidv4(),
          date: new Date().toISOString().split('T')[0],
          agency: '',
          originalText: userText,
          summary: '',
          documentDate: '',
          senderAgency: '',
          keySentences: [], // Используем keySentences
          attachments: [],
          complaints: [],
          analysisStatus: 'pending',
          lastAnalyzedAt: null,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          violations: []
        };
        
        console.log('Созданный документ (только текст):', newDocument);
        
        // Инициализация коллекции документов, если её нет
        if (!db.data) {
          db.data = {};
        }
        if (!db.data.documents) {
          db.data.documents = [];
        }
        
        db.data.documents.push(newDocument);
        await db.write();
        return res.status(201).json(newDocument);
      }

      // Обработка файлов
      const filesData = await processUploadedFiles(req.files, userText, userComments);
      console.log('Загруженные файлы:', filesData);
      res.status(201).json(filesData[0]);
    } catch (err) {
      console.error('Ошибка загрузки:', err);
      res.status(500).json({ 
        message: err.message || 'Ошибка сервера при обработке документа'
      });
    }
  });

  // Создание документа
  router.post('/', async (req, res) => {
    try {
      const docData = req.body;
      console.log('Получены данные для создания документа:', docData);
      
      // Базовая валидация структуры
      if (!docData.id) {
        docData.id = uuidv4();
      }
      if (!docData.date) {
        docData.date = new Date().toISOString().split('T')[0];
      }
      if (!docData.createdAt) {
        docData.createdAt = new Date().toISOString();
      }
      docData.updatedAt = new Date().toISOString();
      
      // Проверка и коррекция типов полей
      let validOriginalText = "";
      if (docData.originalText !== undefined && docData.originalText !== null) {
        if (typeof docData.originalText === 'string') {
          validOriginalText = docData.originalText;
        } else {
          console.log("Предупреждение: originalText не является строкой:", typeof docData.originalText);
          validOriginalText = String(docData.originalText);
        }
      }
      
      // Установка значений по умолчанию для отсутствующих полей
      const newDocument = {
        id: docData.id,
        date: docData.date,
        agency: docData.agency || '',
        originalText: validOriginalText,
        summary: docData.summary || '',
        documentDate: docData.documentDate || '',
        senderAgency: docData.senderAgency || '',
        keySentences: Array.isArray(docData.keySentences) ? docData.keySentences : [],
        attachments: Array.isArray(docData.attachments) ? docData.attachments.map(att => {
          // Проверка и коррекция типов полей вложения
          let validAttachmentText = "";
          if (att.text !== undefined && att.text !== null) {
            if (typeof att.text === 'string') {
              validAttachmentText = att.text;
            } else {
              console.log("Предупреждение: attachment text не является строкой:", typeof att.text);
              validAttachmentText = String(att.text);
            }
          }
          
          return {
            id: att.id || uuidv4(),
            name: att.name || '',
            type: att.type || '',
            size: att.size || 0,
            path: att.path || '',
            text: validAttachmentText,
            analysis: att.analysis || null,
            documentDate: att.documentDate || '',
            senderAgency: att.senderAgency || '',
            summary: att.summary || '',
            keySentences: Array.isArray(att.keySentences) ? att.keySentences : []
          };
        }) : [],
        complaints: Array.isArray(docData.complaints) ? docData.complaints : [],
        analysisStatus: docData.analysisStatus || 'pending',
        lastAnalyzedAt: docData.lastAnalyzedAt || null,
        createdAt: docData.createdAt,
        updatedAt: docData.updatedAt,
        violations: Array.isArray(docData.violations) ? docData.violations : []
      };
      
      console.log('Созданный документ:', newDocument);
      
      // Инициализация коллекции документов, если её нет
      if (!db.data) {
        db.data = {};
      }
      if (!db.data.documents) {
        db.data.documents = [];
      }
      
      db.data.documents.push(newDocument);
      await db.write();
      res.status(201).json(newDocument);
    } catch (err) {
      console.error('Ошибка создания документа:', err);
      res.status(400).json({ message: err.message });
    }
  });

  // Получение списка документов
  router.get('/', async (req, res) => {
    try {
      await db.read();
      const { limit = 50, offset = 0 } = req.query;
      
      const documents = db.data.documents
        .slice(parseInt(offset), parseInt(offset) + parseInt(limit))
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      res.json({
        total: db.data.documents.length,
        items: documents
      });
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Получение документа по ID
  router.get('/:id', async (req, res) => {
    try {
      const doc = db.data.documents.find(d => d.id === req.params.id);
      if (!doc) return res.status(404).json({ message: 'Документ не найден' });
      res.json(doc);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  

  // Удаление документа
  router.delete('/:id', async (req, res) => {
    try {
      await db.read();
      const initialLength = db.data.documents.length;
      db.data.documents = db.data.documents.filter(d => d.id !== req.params.id);
      
      if (db.data.documents.length === initialLength) {
        return res.status(404).json({ message: 'Document not found' });
      }
      
      await db.write();
      res.status(204).end();
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Получение жалоб для документа
  router.get('/:id/complaints', async (req, res) => {
    try {
      const complaints = db.data.complaints?.filter(c => c.documentId === req.params.id) || [];
      res.json(complaints);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Обновление документа
  router.put('/:id', async (req, res) => {
    try {
      console.log(`Получен запрос на обновление документа с ID: ${req.params.id}`);
      console.log('Данные для обновления:', req.body);
      
      const docIndex = db.data.documents.findIndex(d => d.id === req.params.id);
      if (docIndex === -1) {
        console.log(`Документ с ID ${req.params.id} не найден`);
        return res.status(404).json({ message: 'Document not found' });
      }
      
      // Глубокое объединение данных документа
      const existingDoc = db.data.documents[docIndex];
      const updateData = req.body;
      console.log('Существующий документ:', existingDoc);
      console.log('Данные для обновления:', updateData);
      
      // Проверка и коррекция типов полей
      let validOriginalText = existingDoc.originalText || "";
      if (updateData.originalText !== undefined && updateData.originalText !== null) {
        if (typeof updateData.originalText === 'string') {
          validOriginalText = updateData.originalText;
        } else {
          console.log("Предупреждение: originalText не является строкой:", typeof updateData.originalText);
          validOriginalText = String(updateData.originalText);
        }
      }
      
      // Создаем обновленный документ, начиная с копии существующего
      // Используем только известные поля, игнорируем неизвестные
      const updatedDoc = {
        ...existingDoc,
        // Обновляем простые поля (игнорируем неизвестные)
        id: updateData.id || existingDoc.id,
        date: updateData.date || existingDoc.date,
        agency: updateData.agency || existingDoc.agency,
        originalText: validOriginalText,
        summary: updateData.summary || existingDoc.summary,
        documentDate: updateData.documentDate || existingDoc.documentDate,
        senderAgency: updateData.senderAgency || existingDoc.senderAgency,
        keySentences: Array.isArray(updateData.keySentences) ? updateData.keySentences : existingDoc.keySentences,
        complaints: Array.isArray(updateData.complaints) ? updateData.complaints : existingDoc.complaints,
        analysisStatus: updateData.analysisStatus || existingDoc.analysisStatus,
        lastAnalyzedAt: updateData.lastAnalyzedAt || existingDoc.lastAnalyzedAt,
        createdAt: updateData.createdAt || existingDoc.createdAt,
        updatedAt: new Date().toISOString(),
        violations: Array.isArray(updateData.violations) ? updateData.violations : existingDoc.violations,
        // Обновляем вложения с глубоким объединением
        attachments: Array.isArray(updateData.attachments) ? 
          updateData.attachments.map(newAttachment => {
            // Ищем существующее вложение по ID
            const existingAttachment = existingDoc.attachments.find(a => a.id === newAttachment.id);
            if (existingAttachment) {
              // Проверка и коррекция типов полей вложения
              let validAttachmentText = existingAttachment.text || "";
              if (newAttachment.text !== undefined && newAttachment.text !== null) {
                if (typeof newAttachment.text === 'string') {
                  validAttachmentText = newAttachment.text;
                } else {
                  console.log("Предупреждение: attachment text не является строкой:", typeof newAttachment.text);
                  validAttachmentText = String(newAttachment.text);
                }
              }
              
              // Если вложение существует, объединяем данные
              return {
                ...existingAttachment,
                ...newAttachment,
                // Для вложенных объектов analysis также делаем объединение
                analysis: newAttachment.analysis ? {
                  ...existingAttachment.analysis,
                  ...newAttachment.analysis
                } : existingAttachment.analysis,
                // Убедимся, что текст корректный
                text: validAttachmentText
              };
            } else {
              // Если это новое вложение, добавляем его как есть
              // Убеждаемся, что у него есть все необходимые поля
              // Проверка и коррекция типов полей вложения
              let validNewAttachmentText = "";
              if (newAttachment.text !== undefined && newAttachment.text !== null) {
                if (typeof newAttachment.text === 'string') {
                  validNewAttachmentText = newAttachment.text;
                } else {
                  console.log("Предупреждение: new attachment text не является строкой:", typeof newAttachment.text);
                  validNewAttachmentText = String(newAttachment.text);
                }
              }
              
              return {
                id: newAttachment.id || uuidv4(),
                name: newAttachment.name || '',
                type: newAttachment.type || '',
                size: newAttachment.size || 0,
                path: newAttachment.path || '',
                text: validNewAttachmentText,
                analysis: newAttachment.analysis || null,
                documentDate: newAttachment.documentDate || '',
                senderAgency: newAttachment.senderAgency || '',
                summary: newAttachment.summary || '',
                keySentences: Array.isArray(newAttachment.keySentences) ? newAttachment.keySentences : []
              };
            }
          }) : existingDoc.attachments
      };
      
      console.log('Обновленный документ:', updatedDoc);
      
      db.data.documents[docIndex] = updatedDoc;
      
      await db.write();
      res.json(updatedDoc);
    } catch (err) {
      console.error('Ошибка обновления документа:', err);
      res.status(400).json({ message: err.message });
    }
  });

  // Анализ документа по ID
  router.post('/:id/analyze', async (req, res) => {
    try {
      const { id } = req.params;
      // Корректная обработка типа для strictMode
      let { instructions = "", strictMode = false } = req.body;
      
      // Преобразуем strictMode в boolean, если он пришел как строка
      if (typeof strictMode === 'string') {
        strictMode = strictMode.toLowerCase() === 'true';
      } else if (typeof strictMode !== 'boolean') {
        // Если strictMode не boolean и не строка, используем значение по умолчанию
        strictMode = false;
      }
      
      console.log(`Получен запрос на анализ документа с ID: ${id}`);
      
      // Используем значения по умолчанию, если параметры не переданы
      const { 
        model = process.env.AI_MODEL || "llama3.1/18/8192"
      } = req.body;
      
      console.log(`Параметры анализа: model=${model}, instructions=${instructions}, strictMode=${strictMode}`);
      
      const doc = db.data.documents.find(d => d.id === id);
      
      if (!doc) {
        console.log(`Документ с ID ${id} не найден`);
        return res.status(404).json({ 
          message: 'Документ не найден',
          documentId: id
        });
      }
      
      console.log(`Найден документ:`, {
        id: doc.id,
        hasOriginalText: !!doc.originalText,
        originalTextLength: doc.originalText ? doc.originalText.length : 0,
        attachmentsCount: doc.attachments ? doc.attachments.length : 0
      });
      
      // Проверяем, что документ содержит текст или вложения
      const hasOriginalText = doc.originalText && doc.originalText.trim().length > 0;
      const hasAttachmentsWithText = doc.attachments && doc.attachments.some(att => att.text && att.text.trim().length > 0);
      
      console.log(`Проверка содержимого: hasOriginalText=${hasOriginalText}, hasAttachmentsWithText=${hasAttachmentsWithText}`);
      
      if (!hasOriginalText && !hasAttachmentsWithText) {
        console.log(`Документ не содержит текста для анализа`);
        return res.status(400).json({ 
          message: 'Документ должен содержать текст или вложения с текстом для анализа',
          documentId: id
        });
      }
      
      // Обновление статуса
      doc.analysisStatus = 'processing';
      doc.updatedAt = new Date().toISOString();
      await db.write();
      console.log(`Статус документа обновлен на 'processing'`);

      console.log("Вызов analyzeDocument");
      const analysisResult = await analyzeDocument(doc, instructions, strictMode);
      console.log("Результат analyzeDocument:", analysisResult);
      
      if (analysisResult.success) {
        // Обновление документа
        console.log("Вызов updateDocumentAnalysis");
        updateDocumentAnalysis(doc, analysisResult.data);
        await db.write();
        console.log(`Документ обновлен после анализа`);

        res.json({
          ...analysisResult.data,
          modelUsed: model,
          analyzedAt: doc.lastAnalyzedAt
        });
      } else {
        throw new Error(analysisResult.error || "Неизвестная ошибка анализа");
      }
    } catch (err) {
      console.error(`Ошибка анализа документа:`, err);
      
      // Обновление статуса документа в случае ошибки
      const { id } = req.params;
      const doc = db.data.documents.find(d => d.id === id);
      if (doc) {
        doc.analysisStatus = 'failed';
        doc.updatedAt = new Date().toISOString();
        await db.write();
      }
      
      res.status(500).json({ 
        message: 'Ошибка при анализе документа',
        error: err.message 
      });
    }
  });

  // Анализ произвольного текста
  router.post('/analyze', async (req, res) => {
    try {
      // Корректная обработка типа для strictMode
      let { text, instructions = "", strictMode = false } = req.body;
      
      // Преобразуем strictMode в boolean, если он пришел как строка
      if (typeof strictMode === 'string') {
        strictMode = strictMode.toLowerCase() === 'true';
      } else if (typeof strictMode !== 'boolean') {
        // Если strictMode не boolean и не строка, используем значение по умолчанию
        strictMode = false;
      }
      
      if (!text) {
        return res.status(400).json({ message: 'Текст обязателен' });
      }
      
      // Проверка типа параметра text
      if (typeof text !== 'string') {
        return res.status(400).json({ 
          message: 'Параметр text должен быть строкой',
          receivedType: typeof text,
          receivedValue: typeof text === 'object' ? '[object Object]' : String(text)
        });
      }
      
      // Анализируем текст
      console.log("Анализ текста через упрощенный путь анализа");
      const analysisResult = await analyzeText(text, instructions, strictMode);
      
      if (analysisResult.success) {
        res.json(analysisResult.data);
      } else {
        throw new Error(analysisResult.error);
      }
    } catch (err) {
      console.error('Ошибка анализа текста:', err);
      res.status(500).json({ 
        message: 'Ошибка при анализе текста',
        error: err.message 
      });
    }
  });

  return router; 
}

====================

// Файл: backend\routes\complaintRoutes.js
import { Router } from 'express';
import { Document, Paragraph, TextRun, Packer } from 'docx';
import { generateUnifiedComplaint } from '../services/complaintService.js';

export default function complaintRoutes({ db }) {
  const router = Router();

  // Генерация жалобы (унифицированный метод)
  router.post('/generate', async (req, res) => {
    try {
      console.log('Получен запрос на генерацию жалобы:', req.body);
      const complaint = await generateUnifiedComplaint(db, req.body);
      res.status(201).json(complaint);
    } catch (err) {
      console.error('Ошибка генерации жалобы:', err);
      res.status(500).json({ message: err.message });
    }
  });

  // Экспорт жалобы

  // Экспорт жалобы
  router.get('/:id/export', async (req, res) => {
    try {
      const { format = 'txt' } = req.query;
      const complaint = db.data.complaints.find(c => c.id === req.params.id);
      
      if (!complaint) {
        return res.status(404).json({ message: 'Complaint not found' });
      }

      if (format === 'txt') {
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Content-Disposition', `attachment; filename=complaint_${complaint.agency}.txt`);
        res.send(complaint.content);
      } 
      else if (format === 'doc') {
        const docxDocument = new Document({
          sections: [{
            children: [
              new Paragraph({
                children: [
                  new TextRun({
                    text: complaint.content,
                    size: 24
                  })
                ]
              })
            ]
          }]
        });

        const buffer = await Packer.toBuffer(docxDocument);
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
        res.setHeader('Content-Disposition', `attachment; filename=complaint_${complaint.agency}.docx`);
        res.send(buffer);
      }
      else {
        res.status(400).json({ message: 'Unsupported format' });
      }
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Получение всех жалоб
  router.get('/', async (req, res) => {
    try {
      await db.read();
      
      // Сортировка по дате создания (новые сначала)
      const complaints = db.data.complaints?.sort((a, b) => 
        new Date(b.createdAt) - new Date(a.createdAt)
      ) || [];
      
      res.json(complaints);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Удаление жалобы
  router.delete('/:id', async (req, res) => {
    try {
      await db.read();
      const initialLength = db.data.complaints.length;
      
      // Удаление жалобы
      db.data.complaints = db.data.complaints.filter(c => c.id !== req.params.id);
      
      if (db.data.complaints.length === initialLength) {
        return res.status(404).json({ message: 'Complaint not found' });
      }
      
      // Удаление ссылки из документа
      for (const doc of db.data.documents) {
        if (doc.complaints) {
          doc.complaints = doc.complaints.filter(id => id !== req.params.id);
        }
      }
      
      await db.write();
      res.status(204).end();
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  return router;
}

====================

// Файл: backend\middleware\aiErrorHandler.js
export default (err, req, res, next) => {
  if (err.message.includes('Ollama')) {
    console.error('AI Error:', {
      endpoint: req.originalUrl,
      input: req.body.text?.substring(0, 100),
      error: err.stack
    });
    
    return res.status(503).json({
      error: "Сервис анализа временно недоступен",
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
  next(err);
};

====================

// Файл: frontend\src\views\HomeView.vue
<template>
  <div class="home-view">
    <h1>Изложите суть Вашей ситуации:</h1>
    <textarea 
      v-model="userText" 
      placeholder="Подробно опишите вашу ситуацию..."
      class="text-input"
      rows="15"
    ></textarea>
    
    <div class="upload-section">
      <p>Приложите входящие документы (.txt / .pdf)</p>
      <FileUpload 
        label="Загрузить документы"
        @files-selected="handleFilesSelected"
        accept=".txt,.pdf"
      />
      <div v-if="files.length > 0" class="files-preview">
        <p>Выбранные файлы: {{ files.map(f => f.name).join(', ') }}</p>
      </div>
    </div>

    <button 
      @click="submitData"
      :disabled="!isFormValid || isLoading"
      class="submit-btn"
    >
      <span v-if="!isLoading">Продолжить</span>
      <span v-else>Обработка...</span>
    </button>

    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useRouter } from 'vue-router';
import FileUpload from '@/components/common/FileUpload.vue';
import { useDocumentStore } from '@/stores/documentStore';

const documentStore = useDocumentStore();
const router = useRouter();
const userText = ref('');
const files = ref([]);
const isLoading = ref(false);
const errorMessage = ref('');

const handleFilesSelected = (selectedFiles) => {
  files.value = selectedFiles;
  errorMessage.value = '';
};

const isFormValid = computed(() => {
  return userText.value.trim() !== '' || files.value.length > 0;
});

const submitData = async () => {
  if (!isFormValid.value || isLoading.value) return;

  isLoading.value = true;
  errorMessage.value = '';

  try {
    // Инициализируем новый документ с полной структурой
    const newDocument = {
      id: null, // Будет установлен при сохранении
      date: new Date().toISOString().split('T')[0],
      agency: '',
      originalText: userText.value,
      summary: '',
      documentDate: '',
      senderAgency: '',
      keySentences: [],
      attachments: [],
      comments: userText.value,
      complaints: [],
      analysisStatus: 'pending',
      lastAnalyzedAt: null
    };

    // Обновляем документ в хранилище
    documentStore.currentDocument = newDocument;

    // Загружаем файлы (если есть)
    if (files.value.length > 0) {
      await documentStore.uploadFiles(files.value);
      // Предполагаем, что uploadFiles обновляет currentDocument.attachments
    }

    // Сохраняем документ
    const savedDoc = await documentStore.saveDocument();
    
    if (savedDoc?.id) {
      router.push({ 
        name: 'review', 
        params: { id: savedDoc.id },
        query: { new: 'true' }  
      });
    } else {
      throw new Error('Документ не был сохранен: отсутствует ID');
    }
  } catch (error) {
    console.error('Ошибка при создании документа:', error);
    errorMessage.value = error.response?.data?.message || 
                         error.message || 
                         'Произошла ошибка при сохранении документа';
    
    // Сбрасываем статус анализа в случае ошибки
    documentStore.currentDocument.analysisStatus = 'failed';
  } finally {
    isLoading.value = false;
  }
};
</script>



====================

// Файл: frontend\src\views\DocumentsList.vue
<template>
  <div class="documents-list">
    <div class="header">
      <h1>Архив входящих документов</h1>
      <router-link to="/" class="new-doc-btn">+ Новый документ</router-link>
    </div>

    <div class="filters">
      <input v-model="searchQuery" type="text" placeholder="Поиск по тексту" class="search-input" />
      <select v-model="selectedAgency" class="agency-select">
        <option value="">Все ведомства</option>
        <option v-for="agency in agenciesList" :key="agency" :value="agency">
          {{ agency }}
        </option>
      </select>
      <button @click="applyFilters" class="filter-btn">Применить</button>
      <button @click="resetFilters" class="filter-btn">Сбросить</button>
    </div>

    <div v-if="isLoading" class="loading">Загрузка документов...</div>
    <div v-else-if="filteredDocuments.length === 0" class="empty">
      Нет документов, соответствующих фильтрам
    </div>


    <ul v-else class="documents">
      <li 
        v-for="doc in filteredDocuments" 
        :key="doc.id" 
        class="document-item"
      >
        <div class="document-main" @click="viewDocument(doc.id)">
          <div class="document-meta">
            <span class="document-date">{{ formatDate(doc.date) }}</span>
            <span class="document-agency">{{ doc.agency }}</span>
          </div>
          <p class="document-summary">
            {{ doc.summary || doc.originalText.substring(0, 100) + '...' }}
          </p>
        </div>
        <div class="document-actions">
          <button 
            @click.stop="analyzeDocument(doc.id)" 
            class="analyze-btn" 
            :disabled="isAnalyzing"
          >
            {{ isAnalyzing ? 'Анализ...' : 'Проверить законность' }}
          </button>
          <button 
            @click.stop="confirmDelete(doc.id)" 
            class="delete-btn"
          >
            Удалить
          </button>
        </div>
      </li>
    </ul>


    <!-- Модальное окно подтверждения удаления -->
    <div v-if="showDeleteModal" class="modal-overlay">
      <div class="modal-content">
        <h3>Подтверждение удаления</h3>
        <p>Вы уверены, что хотите удалить этот документ?</p>
        <div class="modal-actions">
          <button @click="deleteDocument" class="confirm-btn">Да, удалить</button>
          <button @click="showDeleteModal = false" class="cancel-btn">Отмена</button>
        </div>
      </div>
    </div>



    <div v-if="showComplaintDialog" class="complaint-dialog" :class="{ closing: !showComplaintDialog && !isAnalyzing }">
      <div class="dialog-content">
        <h3>Выберите ведомство для жалобы</h3>
        <select v-model="selectedComplaintAgency" class="agency-select">
          <option v-for="agency in complaintAgencies" :key="agency" :value="agency">
            {{ agency }}
          </option>
        </select>
        <div class="dialog-actions">
          <button @click="generateComplaint" class="action-btn primary" :disabled="!selectedComplaintAgency">
            Сформировать жалобу
          </button>
          <button @click="showComplaintDialog = false" class="action-btn">
            Отмена
          </button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="1500"
      @close="showNotification = false"
    />

    <!-- Индикатор загрузки -->
    <div v-if="isAnalyzing" class="loading-overlay">
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-text">Генерация жалобы...</div>
        <div class="loading-subtext">Пожалуйста, подождите</div>
      </div>
    </div>

  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'
import { useRouter } from 'vue-router'
import NotificationToast from '@/components/ui/NotificationToast.vue'

const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()
const router = useRouter()
const showNotification = ref(false)
const notificationMessage = ref('')
const notificationType = ref('success')

const isLoading = ref(false)
const isAnalyzing = ref(false)
const searchQuery = ref('')
const selectedAgency = ref('')
const showComplaintDialog = ref(false)
const selectedComplaintAgency = ref('')
const currentDocumentId = ref(null)

// Для удаления документов
const showDeleteModal = ref(false)
const documentToDelete = ref(null)

const confirmDelete = (id) => {
  documentToDelete.value = id
  showDeleteModal.value = true
}

const deleteDocument = async () => {
  if (documentToDelete.value) {
    try {
      await documentStore.deleteDocument(documentToDelete.value)
      await documentStore.fetchDocuments()
      
      // Показываем уведомление
      notificationMessage.value = 'Документ успешно удалён'
      notificationType.value = 'success'
      showNotification.value = true
    } catch (error) {
      console.error('Ошибка удаления:', error)
      
      // Уведомление об ошибке
      notificationMessage.value = 'Ошибка при удалении документа'
      notificationType.value = 'error'
      showNotification.value = true
    }
  }
  showDeleteModal.value = false
}


const viewDocument = (id) => {
  router.push(`/documents/${id}`)
}

// Загружаем документы при монтировании
onMounted(async () => {
  isLoading.value = true
  try {
    await documentStore.fetchDocuments()
  } finally {
    isLoading.value = false
  }
})

// Получаем список ведомств
const agenciesList = computed(() => documentStore.agenciesList)

// Фильтрация документов
const filteredDocuments = computed(() => {
  return documentStore.documents.filter((doc) => {
    const matchesSearch =
      searchQuery.value === '' ||
      doc.summary.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
      doc.originalText.toLowerCase().includes(searchQuery.value.toLowerCase())

    const matchesAgency =
      selectedAgency.value === '' || doc.agency === selectedAgency.value

    return matchesSearch && matchesAgency
  })
})

// Варианты ведомств для жалоб
const complaintAgencies = computed(() => complaintStore.agenciesOptions)

const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const applyFilters = () => {
  // Фильтрация происходит автоматически через computed свойство
}

const resetFilters = () => {
  searchQuery.value = ''
  selectedAgency.value = ''
}

const analyzeDocument = async (docId) => {
  isAnalyzing.value = true;
  currentDocumentId.value = docId;
  try {
    // Загружаем данные документа
    await documentStore.fetchDocumentById(docId);
    
    // Показываем диалог выбора ведомства
    showComplaintDialog.value = true;
  } catch (error) {
    console.error('Ошибка загрузки документа:', error);
    // Показываем уведомление об ошибке
    notificationMessage.value = 'Ошибка при загрузке документа';
    notificationType.value = 'error';
    showNotification.value = true;
  } finally {
    isAnalyzing.value = false;
  }
}

const generateComplaint = async () => {
  if (!selectedComplaintAgency.value || !currentDocumentId.value) return

  // Скрываем модальное окно сразу после нажатия кнопки
  showComplaintDialog.value = false
  
  // Показываем индикатор загрузки
  isAnalyzing.value = true

  try {
    console.log('Генерация жалобы для документа:', currentDocumentId.value, 'в ведомство:', selectedComplaintAgency.value)
    const result = await complaintStore.generateComplaint(
      currentDocumentId.value,
      selectedComplaintAgency.value
    )
    console.log('Результат генерации жалобы:', result)
    
    // Ждем немного для плавного перехода
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    // Переходим к подробному просмотру созданной жалобы
    router.push(`/complaints/${result.id}`)
    
  } catch (error) {
    console.error('Ошибка генерации жалобы:', error)
    
    // Показываем уведомление об ошибке
    notificationMessage.value = 'Ошибка при формировании жалобы: ' + (error.message || 'Неизвестная ошибка')
    notificationType.value = 'error'
    showNotification.value = true
  } finally {
    // Скрываем индикатор загрузки
    isAnalyzing.value = false
  }
}
</script>



====================

// Файл: frontend\src\views\DocumentReview.vue
<template>
  <div class="document-review">
    <div class="header">
      <h1>Предпросмотр документа</h1>
      <button @click="goBack" class="back-button">← Назад</button>
    </div>

    <div v-if="isLoading" class="loading-state">
      <div class="spinner"></div>
      <p>Загрузка данных...</p>
    </div>

    <!-- Индикатор анализа -->
    <div v-if="isAnalyzing && !isLoading" class="analyzing-overlay">
      <div class="analyzing-content">
        <div class="loading-spinner"></div>
        <div class="analyzing-text">Анализ документа...</div>
        <div class="analyzing-subtext">Пожалуйста, подождите</div>
      </div>
    </div>

    <div v-else class="review-container">
      <form @submit.prevent="handleSubmit" class="review-form">
        <!-- Основные поля -->
        <div class="form-section">
          <h2>Основная информация</h2>
          <div class="form-group">
            <label for="date">Дата поступления:</label>
            <input type="date" id="date" v-model="document.date" required class="form-input" />
          </div>

          <div class="form-group">
            <label for="agency">Ведомство, допустившее нарушение:</label>
            <input type="text" id="agency" v-model="document.agency" list="agencies" required class="form-input"
              placeholder="Выберите ведомство" />
            <datalist id="agencies">
              <option v-for="agency in agenciesList" :key="agency">{{ agency }}</option>
            </datalist>
          </div>

          <div class="form-group">
            <label for="originalText">Текст документа:</label>
            <textarea id="originalText" v-model="document.originalText" required class="form-textarea" rows="15"
              placeholder="Введите текст документа"></textarea>
          </div>
        </div>

        <!-- Анализ документа -->
        <div class="form-section" v-if="document.analysisStatus !== 'pending'">
          <h2>Анализ документа</h2>

          <div class="form-group" v-if="document.analysisStatus === 'completed'">
            <label>Краткая суть:</label>
            <div class="summary-container">
              <textarea v-model="document.summary" required class="form-textarea" rows="12"
                placeholder="Анализ выполняется..."></textarea>
              <button type="button" @click="regenerateSummary" class="refresh-btn" :disabled="aiStore.isLoading"
                title="Перегенерировать краткую суть">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                  <path d="M3 3v5h5" />
                  <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
                  <path d="M16 16h5v5" />
                </svg>
              </button>
            </div>
          </div>

          <!-- Важные предложения -->
          <div class="form-group" v-if="document.analysisStatus === 'completed'">
            <label>Важные предложения:</label>
            <div v-for="(sentence, index) in document.keySentences" :key="index" class="paragraph-item">
              <textarea v-model="document.keySentences[index]" required class="form-textarea" rows="3"></textarea>
              <button type="button" @click="removeSentence(index)" class="remove-btn" title="Удалить предложение">
                ×
              </button>
            </div>
            <button type="button" @click="addSentence" class="add-btn" title="Добавить предложение">
              + Добавить предложение
            </button>
          </div>
        </div>

        <!-- Отправитель вложенного документа (только при наличии вложений) -->
        <div class="form-section" v-if="document.attachments?.length">
          <h2>Отправитель вложенного документа</h2>
          
          <div class="form-group">
            <label>Дата отправления документа:</label>
            <input v-model="document.documentDate" type="date" class="form-input" />
          </div>

          <div class="form-group">
            <label>Ведомство-отправитель:</label>
            <input v-model="document.senderAgency" class="form-input" list="agencies" />
          </div>
        </div>

        <!-- Вложения -->
        <div class="form-section" v-if="document.attachments?.length">
          <h2>Вложенные документы</h2>
          <div v-for="(attachment, idx) in document.attachments" :key="attachment.id || idx"
            class="attachment-analysis">
            <div class="attachment-header">
              <h3>{{ attachment.name }}</h3>
              <span class="file-size">{{ formatFileSize(attachment.size) }}</span>
              <button @click="regenerateAttachmentAnalysis(attachment.id)" class="refresh-btn" :disabled="isAnalyzing"
                title="Переанализировать документ">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                  <path d="M3 3v5h5" />
                  <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
                  <path d="M16 16h5v5" />
                </svg>
              </button>
            </div>

            <div v-if="attachment.analysis" class="attachment-details">
              <div class="detail-row">
                <span class="detail-label">Тип документа:</span>
                <span>{{ attachment.analysis.documentType || 'Не указан' }}</span>
              </div>
              <div class="detail-row">
                <span class="detail-label">Дата отправления:</span>
                <input type="date" v-model="attachment.documentDate" class="form-input small">
              </div>
              <div class="detail-row">
                <span class="detail-label">Ведомство-отправитель:</span>
                <input v-model="attachment.senderAgency" class="form-input small" list="agencies">
              </div>
              <div class="detail-row full-width">
                <span class="detail-label">Краткая суть:</span>
                <textarea v-model="attachment.summary" class="form-textarea" rows="3"></textarea>
              </div>
              <div class="detail-row full-width">
                <span class="detail-label">Полный текст:</span>
                <textarea v-model="attachment.text" class="form-textarea" rows="6" readonly></textarea>
              </div>

              <div class="key-paragraphs">
                <h4>Важные предложения:</h4>
                <div v-for="(sentence, index) in attachment.keySentences" :key="index" class="paragraph-item">
                  <textarea v-model="attachment.keySentences[index]" class="form-textarea" rows="2"></textarea>
                  <button type="button" @click="removeAttachmentSentence(attachment.id, index)" class="remove-btn"
                    title="Удалить предложение">
                    ×
                  </button>
                </div>
                <button type="button" @click="addAttachmentSentence(attachment.id)" class="add-btn"
                  title="Добавить предложение">
                  + Добавить предложение
                </button>
              </div>
            </div>
            <div v-else class="no-analysis">
              <p>Анализ не выполнен</p>
              <button @click="analyzeAttachment(attachment)" class="analyze-btn" :disabled="isAnalyzing">
                Анализировать
              </button>
            </div>
          </div>
        </div>



        <!-- Кнопки действий -->
        <div class="form-actions">
          <button type="button" @click="analyzeDocument" class="analyze-btn"
            :disabled="isAnalyzing || (!document.originalText && (!document.attachments || document.attachments.length === 0))">
            <span v-if="isAnalyzing" class="button-loader"></span>
            {{ isAnalyzing ? 'Анализ...' : 'Анализировать документ' }}
          </button>

          <button type="submit" class="save-btn" :disabled="isSaving">
            {{ isSaving ? 'Сохранение...' : 'Сохранить документ' }}
          </button>
        </div>
      </form>

      <!-- Блок статуса -->
      <div class="status-section">
        <div class="status-indicator" :class="document.analysisStatus">
          Статус анализа:
          <span>{{ getStatusText(document.analysisStatus) }}</span>
        </div>
        <div v-if="document.lastAnalyzedAt" class="last-analyzed">
          Последний анализ: {{ formatDate(document.lastAnalyzedAt) }}
        </div>
      </div>

      <!-- Уведомления об ошибках -->
      <div v-if="error" class="error-message">
        <div class="error-content">
          <span class="error-icon">!</span>
          <span>{{ error }}</span>
          <button @click="error = null" class="close-error" title="Закрыть">×</button>
        </div>
      </div>
    </div>
    
    <!-- Индикатор анализа -->
    <div v-if="isAnalyzing && !isLoading" class="analyzing-overlay">
      <div class="analyzing-content">
        <div class="loading-spinner"></div>
        <div class="analyzing-text">Анализ документа...</div>
        <div class="analyzing-subtext">Пожалуйста, подождите</div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import axios from 'axios'
import { useAIStore } from '@/stores/aiStore'
import { useDocumentStore } from '@/stores/documentStore'

const router = useRouter()
const aiStore = useAIStore()
const documentStore = useDocumentStore()

const isLoading = ref(true)
const isSaving = ref(false)
const isAnalyzing = ref(false)
const error = ref(null)

const document = ref({
  ...documentStore.currentDocument
})

const agenciesList = computed(() => documentStore.agenciesList)

onMounted(async () => {
  try {
    console.log('Инициализация компонента DocumentReview');
    await aiStore.checkServerStatus();

    // Проверяем, есть ли текст для анализа
    const hasOriginalText = document.value.originalText && document.value.originalText.trim().length > 0;
    const hasAttachmentsWithText = document.value.attachments?.some(att => att.text && att.text.trim().length > 0);
    
    console.log('Проверка текста при инициализации:', { hasOriginalText, hasAttachmentsWithText, document: document.value });
    
    if (!document.value.id && !hasOriginalText && !hasAttachmentsWithText) {
      console.log('Нет документа для анализа, перенаправление на главную');
      router.push('/');
      return;
    }

    if (document.value.id) {
      console.log('Загрузка документа по ID:', document.value.id);
      await documentStore.fetchDocumentById(document.value.id);
      document.value = {
        ...documentStore.currentDocument,
        attachments: documentStore.currentDocument.attachments?.map(att => ({
          ...att,
          analysis: att.analysis || null
        })) || []
      };
      console.log('Документ загружен:', document.value);
    }
  } catch (err) {
    console.error('Ошибка загрузки:', err);
    error.value = 'Ошибка загрузки: ' + err.message;
  } finally {
    isLoading.value = false;
  }
});

const addAttachmentSentence = (attachmentId) => {
  const attachment = document.value.attachments.find(a => a.id === attachmentId);
  if (attachment) {
    if (!attachment.keySentences) {
      attachment.keySentences = [];
    }
    attachment.keySentences.push('');
  }
};

const removeAttachmentSentence = (attachmentId, index) => {
  const attachment = document.value.attachments.find(a => a.id === attachmentId);
  if (attachment && attachment.keySentences) {
    attachment.keySentences.splice(index, 1);
  }
};

// Обновленный метод анализа вложения
const analyzeAttachment = async (attachment) => {
  if (!attachment.text) return;
  
  isAnalyzing.value = true;
  try {
    // Вызываем бэкенд для анализа вложения
    const response = await axios.post('http://localhost:3001/api/attachments/analyze', {
      text: attachment.text
    });
    const analysis = response.data;
    
    const index = document.value.attachments.findIndex(a => a.id === attachment.id);
    if (index !== -1) {
      document.value.attachments[index] = {
        ...document.value.attachments[index],
        analysis,
        documentDate: analysis.documentDate || "",
        senderAgency: analysis.senderAgency || "",
        summary: analysis.summary || "",
        text: attachment.text,
        keySentences: analysis.keySentences || []
      };
    }
  } catch (err) {
    error.value = 'Ошибка анализа вложения: ' + err.message;
  } finally {
    isAnalyzing.value = false;
  }
};

// Метод для перегенерации анализа
const regenerateAttachmentAnalysis = async (attachmentId) => {
  isAnalyzing.value = true;
  try {
    const updatedAttachment = await documentStore.regenerateAttachmentAnalysis(attachmentId);
    const index = document.value.attachments.findIndex(a => a.id === attachmentId);
    if (index !== -1) {
      document.value.attachments[index] = updatedAttachment;
    }
  } catch (err) {
    error.value = 'Ошибка перегенерации анализа: ' + err.message;
  } finally {
    isAnalyzing.value = false;
  }
}

const addSentence = () => {
  document.value.keySentences.push('')
}

const removeSentence = (index) => {
  document.value.keySentences.splice(index, 1)
}

const analyzeDocument = async () => {
  isAnalyzing.value = true
  error.value = null

  try {
    const updatedDocument = await documentStore.analyzeDocument(document.value.id)

    document.value = {
      ...updatedDocument
    }
    
    // Обновляем currentDocument в хранилище
    documentStore.currentDocument = document.value
  } catch (err) {
    error.value = 'Ошибка анализа: ' + err.message
  } finally {
    isAnalyzing.value = false
  }
}


const regenerateSummary = async () => {
  isAnalyzing.value = true
  try {
    // Вызываем бэкенд для генерации краткой сути
    const response = await axios.post('http://localhost:3001/api/documents/analyze-text', {
      text: document.value.originalText
    });
    const analysis = response.data;
    
    document.value.summary = analysis.summary || 'Не удалось сгенерировать краткую суть';
  } catch (err) {
    error.value = 'Ошибка перегенерации: ' + err.message
  } finally {
    isAnalyzing.value = false
  }
}

const handleSubmit = async () => {
  isSaving.value = true
  error.value = null

  try {
    documentStore.currentDocument = document.value
    await documentStore.saveDocument()
    router.push('/documents')
  } catch (err) {
    error.value = 'Ошибка сохранения: ' + err.message
  } finally {
    isSaving.value = false
  }
}

const goBack = () => {
  router.push('/')
}

const formatDate = (dateString) => {
  if (!dateString) return ''
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const formatFileSize = (bytes) => {
  if (!bytes) return '0 KB'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i]
  )
}

const getStatusText = (status) => {
  const statusMap = {
    pending: 'Ожидает анализа',
    processing: 'В процессе',
    completed: 'Завершён',
    failed: 'Ошибка'
  }
  return statusMap[status] || status
}
</script>



====================

// Файл: frontend\src\views\DocumentDetail.vue
<!-- src/views/DocumentDetail.vue -->
<template>
  <div class="document-detail">
    <button @click="goBack" class="back-button">← Назад к списку</button>
    
    <div v-if="loading" class="loading-state">
      <p>Загрузка документа...</p>
    </div>
    <div v-else-if="error" class="error-state">
      <p>Ошибка загрузки: {{ error }}</p>
    </div>
    <div v-else-if="!document" class="empty-state">
      <p>Документ не найден</p>
    </div>
    <div v-else class="document-content">
      <div class="document-header">
        <h1>Документ #{{ document.id }}</h1>
        <span class="document-date">{{ formatDate(document.date) }}</span>
      </div>
      <div class="document-meta">
        <div v-if="document.agency" class="meta-field">
          <span class="meta-label">Ведомство:</span>
          <span class="meta-value">{{ document.agency }}</span>
        </div>
        
        <div class="meta-field">
          <span class="meta-label">Дата создания:</span>
          <span class="meta-value">{{ formatDateTime(document.createdAt) }}</span>
        </div>
      </div>
      
      <!-- Кнопка создания жалобы -->
      <div class="complaint-action">
        <button @click="createComplaint" class="create-complaint-btn">
          Создать жалобу
        </button>
      </div>
      
      <div class="document-section">
        <h2>Исходный текст</h2>
        <pre class="original-text">{{ document.originalText }}</pre>
      </div>
      <div v-if="document.summary" class="document-section">
        <h2>Краткое содержание</h2>
        <p class="summary-text">{{ document.summary }}</p>
      </div>
      <div v-if="document.keySentences?.length" class="document-section">
        <h2>Важные предложения</h2>
        <ul class="paragraphs-list">
          <li v-for="(sentence, index) in document.keySentences" :key="index">
            {{ sentence }}
          </li>
        </ul>
      </div>
      <div v-if="document.attachments?.length" class="document-section">
        <h2>Прикрепленные файлы</h2>
        <div class="attachments-list">
          <div v-for="file in document.attachments" :key="file.id" class="attachment-item">
            <div class="attachment-info">
              <span class="attachment-name">{{ file.name }}</span>
              <span class="attachment-size">{{ formatFileSize(file.size) }}</span>
            </div>
            <a 
              :href="getFileUrl(file.path)" 
              target="_blank"
              class="download-button"
            >
              Скачать
            </a>
          </div>
        </div>
      </div>
      <div v-if="document.comments" class="document-section">
        <h2>Комментарии</h2>
        <p class="comments-text">{{ document.comments }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/documentStore'

const route = useRoute()
const router = useRouter()
const documentStore = useDocumentStore()

const document = ref(null)
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    loading.value = true
    error.value = null
    await documentStore.fetchDocumentById(route.params.id)
    document.value = { ...documentStore.currentDocument }
  } catch (err) {
    error.value = err.message || 'Не удалось загрузить документ'
    console.error('Ошибка загрузки документа:', err)
  } finally {
    loading.value = false
  }
})

const formatDate = (dateString) => {
  return dateString ? new Date(dateString).toLocaleDateString('ru-RU') : 'Дата не указана'
}

const formatDateTime = (dateString) => {
  if (!dateString) return 'Дата не указана'
  const options = {
    day: 'numeric',
    month: 'numeric',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  }
  return new Date(dateString).toLocaleString('ru-RU', options)
}

const formatFileSize = (bytes) => {
  if (!bytes) return '0 KB'
  return `${(bytes / 1024).toFixed(2)} KB`
}

const getFileUrl = (path) => {
  return path.startsWith('http') ? path : `http://localhost:3001${path}`
}

const goBack = () => {
  router.push('/documents')
}

const createComplaint = () => {
  router.push(`/documents/${route.params.id}/complaint`)
}
</script>



====================

// Файл: frontend\src\views\ComplaintsList.vue
<template>
  <div class="complaints-list">
    <div class="header">
      <h1>Сформированные жалобы</h1>
      <router-link to="/documents" class="back-btn">← К документам</router-link>
    </div>

    <!-- Отладочная информация -->
    <div v-if="debugMode" class="debug-info">
      <pre>Store state: {{ JSON.stringify(complaintStore.$state, null, 2) }}</pre>
    </div>

    <div v-if="isLoading" class="loading">
      <p>Загрузка жалоб...</p>
      <progress indeterminate></progress>
    </div>

    <div v-else-if="!complaints.length" class="empty">
      <p>Нет сформированных жалоб</p>
      <router-link to="/" class="create-link">Создать первую жалобу</router-link>
    </div>

    <ul v-else class="complaints">
      <li v-for="complaint in complaints" :key="complaint.id" class="complaint-item">
        <div class="complaint-card" @click="viewComplaint(complaint.id)">
          <h3>{{ complaint.agency }}</h3>
          <p class="date">{{ formatDate(complaint.createdAt) }}</p>
          <p class="preview">{{ complaint.content.substring(0, 100) }}...</p>
          <div class="actions">
            <button @click.stop="viewComplaint(complaint.id)" class="view-btn">
              Посмотреть
            </button>
            <button @click.stop="exportComplaint(complaint.id, 'txt')" class="export-btn">
              TXT
            </button>
            <button @click.stop="exportComplaint(complaint.id, 'doc')" class="export-btn">
              DOC
            </button>
            <button 
              @click.stop="confirmDelete(complaint)" 
              class="delete-btn"
            >
              Удалить
            </button>
          </div>
        </div>
      </li>
    </ul>

    <!-- Модальное окно подтверждения удаления -->
    <div v-if="showDeleteModal" class="modal-overlay">
      <div class="modal-content">
        <h3>Подтверждение удаления</h3>
        <p>Вы уверены, что хотите удалить жалобу в "{{ complaintToDelete?.agency }}"?</p>
        <div class="modal-actions">
          <button @click="deleteComplaint" class="confirm-btn">Да, удалить</button>
          <button @click="showDeleteModal = false" class="cancel-btn">Отмена</button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="1500"
      @close="showNotification = false"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { useComplaintStore } from '@/stores/complaintStore'
import { saveAs } from 'file-saver'
import NotificationToast from '@/components/ui/NotificationToast.vue'


// Debug
const debugMode = ref(false)

// Store
const complaintStore = useComplaintStore()
const router = useRouter()
const isLoading = ref(false)
const complaints = computed(() => complaintStore.complaints || [])

// Удаление жалоб
const showDeleteModal = ref(false)
const complaintToDelete = ref(null)
const showNotification = ref(false)
const notificationMessage = ref('')
const notificationType = ref('success')

const confirmDelete = (complaint) => {
  complaintToDelete.value = complaint
  showDeleteModal.value = true
}

const deleteComplaint = async () => {
  if (complaintToDelete.value) {
    try {
      await complaintStore.deleteComplaint(complaintToDelete.value.id)
      notificationMessage.value = 'Жалоба успешно удалена'
      notificationType.value = 'success'
    } catch (error) {
      notificationMessage.value = 'Ошибка при удалении жалобы'
      notificationType.value = 'error'
      console.error('Ошибка удаления:', error)
    } finally {
      showNotification.value = true
      showDeleteModal.value = false
    }
  }
}

const viewComplaint = (complaintId) => {
  router.push(`/complaints/${complaintId}`)
}


const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const exportComplaint = async (complaintId, format) => {
  try {
    const blob = await complaintStore.exportComplaint(complaintId, format)
    const complaint = complaints.value.find(c => c.id === complaintId)
    const filename = `Жалоба_${complaint.agency}_${formatDate(complaint.createdAt)}.${format}`
    saveAs(blob, filename)
  } catch (error) {
    console.error('Export error:', error)
    notificationMessage.value = 'Ошибка при экспорте'
    notificationType.value = 'error'
    showNotification.value = true
  }
}

// Lifecycle
onMounted(async () => {
  isLoading.value = true
  try {
    await complaintStore.fetchComplaints()
  } catch (error) {
    console.error('Failed to load complaints:', error)
    notificationMessage.value = 'Ошибка загрузки жалоб'
    notificationType.value = 'error'
    showNotification.value = true
  } finally {
    isLoading.value = false
  }
})
</script>



====================

// Файл: frontend\src\views\ComplaintForm.vue
<!-- src/components/complaints/ComplaintForm.vue -->
<template>
  <div class="complaint-form">
    <div class="header">
      <button @click="goBack" class="back-button">← Назад</button>
      <h1>Создание жалобы</h1>
    </div>

    <div v-if="loading" class="loading">
      <p>Загрузка данных...</p>
    </div>
    
    <div v-else-if="error" class="error">
      <p>Ошибка: {{ error }}</p>
    </div>
    
    <div v-else class="complaint-form-content">
      <div class="document-preview">
        <h2>Документ для жалобы</h2>
        <div class="document-info">
          <div class="info-row">
            <span class="label">Дата поступления:</span>
            <span class="value">{{ formatDate(documentStore.currentDocument.date) }}</span>
          </div>
          <div class="info-row">
            <span class="label">Ведомство:</span>
            <span class="value">{{ documentStore.currentDocument.agency || 'Не указано' }}</span>
          </div>
          <div class="info-row">
            <span class="label">Дата документа:</span>
            <span class="value">{{ documentStore.currentDocument.documentDate || 'Не указана' }}</span>
          </div>
          <div class="info-row">
            <span class="label">Краткая суть:</span>
            <span class="value">{{ documentStore.currentDocument.summary || 'Нет краткой сводки' }}</span>
          </div>
        </div>
      </div>

      <div class="agency-selection">
        <h2>Выберите ведомство</h2>
        <select v-model="selectedAgency" @change="onAgencyChange" class="agency-select">
          <option value="">-- Выберите ведомство --</option>
          <option 
            v-for="agency in agenciesOptions" 
            :key="agency" 
            :value="agency"
          >
            {{ agency }}
          </option>
        </select>
      </div>

      <div class="instructions-section">
        <h2>Дополнительные инструкции</h2>
        <textarea 
          v-model="customInstructions" 
          placeholder="Введите дополнительные инструкции для нейросети (необязательно)"
          class="instructions-input"
          rows="4"
        ></textarea>
      </div>

      <div class="actions">
        <button 
          @click="generateComplaint" 
          :disabled="isGenerating || !selectedAgency"
          class="generate-btn"
        >
          {{ isGenerating ? 'Генерация...' : 'Создать жалобу' }}
        </button>
        <button @click="goBack" class="cancel-btn">Отмена</button>
      </div>

      <div v-if="generatedComplaint" class="complaint-result">
        <h2>Сгенерированная жалоба</h2>
        <div class="complaint-content">
          <pre>{{ generatedComplaint }}</pre>
        </div>
        <div class="result-actions">
          <button @click="copyToClipboard" class="copy-btn">Копировать</button>
          <button @click="saveComplaint" class="save-btn">Сохранить в документ</button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="2000"
      @close="showNotification = false"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'
import NotificationToast from '@/components/ui/NotificationToast.vue'

const route = useRoute()
const router = useRouter()
const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()

// Состояния
const selectedAgency = ref('')
const customInstructions = ref('')
const generatedComplaint = ref(null)
const showNotification = ref(false)
const notificationMessage = ref('')
const notificationType = ref('success')

// Геттеры из store
const agenciesOptions = computed(() => complaintStore.agenciesOptions)
const isGenerating = computed(() => complaintStore.isGenerating)
const loading = computed(() => documentStore.isLoading)
const error = computed(() => documentStore.error || complaintStore.error)

// Методы
const formatDate = (dateString) => {
  return dateString ? new Date(dateString).toLocaleDateString('ru-RU') : 'Дата не указана'
}

const onAgencyChange = () => {
  // Логика при изменении выбора ведомства
}

const generateComplaint = async () => {
  if (!selectedAgency.value) return
  
  try {
    // Используем метод из store с правильными параметрами
    const result = await complaintStore.generateComplaint(
      route.params.id, 
      selectedAgency.value, 
      customInstructions.value
    )
    generatedComplaint.value = result.content || result
    
    // Показываем уведомление об успешной генерации
    notificationMessage.value = 'Жалоба успешно сгенерирована'
    notificationType.value = 'success'
    showNotification.value = true
    
    // Сбросим состояние после успешной генерации
    // selectedAgency.value = ''
    // customInstructions.value = ''
  } catch (err) {
    console.error('Ошибка генерации жалобы:', err)
    // Показываем уведомление об ошибке
    notificationMessage.value = 'Ошибка при генерации жалобы: ' + (err.message || 'Неизвестная ошибка')
    notificationType.value = 'error'
    showNotification.value = true
  }
}

const copyToClipboard = () => {
  if (generatedComplaint.value) {
    navigator.clipboard.writeText(generatedComplaint.value)
    // Показываем уведомление
    notificationMessage.value = 'Жалоба скопирована в буфер обмена'
    notificationType.value = 'success'
    showNotification.value = true
  }
}

const saveComplaint = async () => {
  if (!generatedComplaint.value) return
  
  try {
    // Обновляем документ с новой жалобой
    await documentStore.fetchDocumentById(route.params.id)
    
    // Добавляем жалобу к документу
    if (!documentStore.currentDocument.complaints) {
      documentStore.currentDocument.complaints = []
    }
    
    // Находим сгенерированную жалобу в complaintStore
    const complaint = complaintStore.complaints.find(c => c.documentId === route.params.id)
    if (complaint) {
      documentStore.currentDocument.complaints.push(complaint)
      await documentStore.saveDocument()
    }
    
    // Показываем уведомление об успешном сохранении
    notificationMessage.value = 'Жалоба успешно сохранена в документ'
    notificationType.value = 'success'
    showNotification.value = true
    
    // Переходим к просмотру документа
    router.push(`/documents/${route.params.id}`)
  } catch (err) {
    console.error('Ошибка сохранения жалобы:', err)
    // Показываем уведомление об ошибке
    notificationMessage.value = 'Ошибка при сохранении жалобы: ' + (err.message || 'Неизвестная ошибка')
    notificationType.value = 'error'
    showNotification.value = true
  }
}

const goBack = () => {
  router.push(`/documents/${route.params.id}`)
}

// Загрузка данных документа
onMounted(async () => {
  try {
    await documentStore.fetchDocumentById(route.params.id)
    // Также загружаем жалобы для документа
    await complaintStore.fetchComplaints()
  } catch (err) {
    console.error('Ошибка загрузки документа:', err)
    // Показываем уведомление об ошибке
    notificationMessage.value = 'Ошибка при загрузке документа: ' + (err.message || 'Неизвестная ошибка')
    notificationType.value = 'error'
    showNotification.value = true
  }
})
</script>



====================

// Файл: frontend\src\views\ComplaintDetail.vue
<!-- src/views/ComplaintDetail.vue -->
<template>
  <div class="complaint-detail">
    <button @click="goBack" class="back-button">← Назад к списку</button>
    
    <div v-if="loading" class="loading-state">
      <p>Загрузка жалобы...</p>
    </div>
    <div v-else-if="error" class="error-state">
      <p>Ошибка загрузки: {{ error }}</p>
    </div>
    <div v-else-if="!complaint" class="empty-state">
      <p>Жалоба не найдена</p>
    </div>
    <div v-else class="complaint-content">
      <div class="complaint-header">
        <h1>Жалоба #{{ complaint.id }}</h1>
        <span class="complaint-date">{{ formatDate(complaint.createdAt) }}</span>
      </div>
      <div class="complaint-meta">
        <div class="meta-field">
          <span class="meta-label">Ведомство:</span>
          <span class="meta-value">{{ complaint.agency }}</span>
        </div>
        
        <div class="meta-field">
          <span class="meta-label">Статус:</span>
          <span class="meta-value">{{ complaint.status }}</span>
        </div>
      </div>
      
      <div class="complaint-section">
        <h2>Текст жалобы</h2>
        <div class="complaint-text">{{ complaint.content }}</div>
      </div>
      
      <div v-if="complaint.analysis?.violations?.length" class="complaint-section">
        <h2>Выявленные нарушения</h2>
        <ul class="violations-list">
          <li v-for="(violation, index) in complaint.analysis.violations" :key="index" class="violation-item">
            <div class="violation-law">Закон: {{ violation.law }}</div>
            <div class="violation-article">Статья: {{ violation.article }}</div>
            <div class="violation-description">Описание: {{ violation.description }}</div>
            <div class="violation-evidence">Доказательство: {{ violation.evidence }}</div>
          </li>
        </ul>
      </div>
      
      <div class="complaint-actions">
        <button @click="exportComplaint('txt')" class="export-btn">Экспорт в TXT</button>
        <button @click="exportComplaint('doc')" class="export-btn">Экспорт в DOC</button>
        <button @click="deleteComplaint" class="delete-btn">Удалить жалобу</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useComplaintStore } from '@/stores/complaintStore'

const route = useRoute()
const router = useRouter()
const complaintStore = useComplaintStore()

const complaint = ref(null)
const loading = ref(false)
const error = ref(null)

onMounted(async () => {
  await loadComplaint()
})

const loadComplaint = async () => {
  loading.value = true
  error.value = null
  try {
    // Получаем список всех жалоб
    await complaintStore.fetchComplaints()
    // Находим нужную жалобу по ID
    complaint.value = complaintStore.complaints.find(c => c.id === route.params.id)
    if (!complaint.value) {
      error.value = 'Жалоба не найдена'
    }
  } catch (err) {
    console.error('Ошибка загрузки жалобы:', err)
    error.value = err.message || 'Не удалось загрузить жалобу'
  } finally {
    loading.value = false
  }
}

const goBack = () => {
  router.push('/complaints')
}

const exportComplaint = async (format) => {
  try {
    await complaintStore.exportComplaint(complaint.value.id, format)
  } catch (err) {
    console.error('Ошибка экспорта:', err)
    error.value = 'Не удалось экспортировать жалобу'
  }
}

const deleteComplaint = async () => {
  if (confirm('Вы уверены, что хотите удалить эту жалобу?')) {
    try {
      await complaintStore.deleteComplaint(complaint.value.id)
      router.push('/complaints')
    } catch (err) {
      console.error('Ошибка удаления:', err)
      error.value = 'Не удалось удалить жалобу'
    }
  }
}

const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString('ru-RU')
}
</script>



====================

// Файл: frontend\src\stores\documentStore.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import axios from "axios";
import { useRouter } from "vue-router";
import { v4 as uuidv4 } from "uuid";
import { useAIStore } from "@/stores/aiStore";

export const useDocumentStore = defineStore("document", () => {
  const router = useRouter();
  const aiStore = useAIStore();
  const API_BASE = "http://localhost:3001";

  // Состояние хранилища
  const documents = ref([]);
  const isLoading = ref(false);
  const error = ref(null);
  const isAnalyzing = ref(false);

  const currentDocument = ref({
    id: uuidv4(),
    date: new Date().toISOString().split("T")[0],
    agency: "",
    originalText: "",
    summary: "",
    keySentences: [],
    documentDate: "",
    senderAgency: "",
    attachments: [],
    complaints: [],
    analysisStatus: "pending",
    lastAnalyzedAt: null,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    violations: [],
  });

  // Геттеры
  const agenciesList = computed(() => {
    const complaintAgencies = new Set([
      "ФССП",
      "Прокуратура",
      "Суд",
      "Омбудсмен",
    ]);
    const allAgencies = new Set(complaintAgencies);

    documents.value.forEach((doc) => {
      const agency = doc.agency || doc.senderAgency;
      if (
        agency &&
        typeof agency === "string" &&
        !complaintAgencies.has(agency)
      ) {
        allAgencies.add(agency);
      }
    });

    return Array.from(allAgencies).sort();
  });

  const hasAttachments = computed(() => {
    return currentDocument.value.attachments?.length > 0;
  });

  const analyzedDocuments = computed(() => {
    return documents.value.filter((doc) => doc.analysisStatus === "completed");
  });

  // Вспомогательные функции

  const updateDocumentsList = (savedDocument) => {
    const index = documents.value.findIndex((d) => d.id === savedDocument.id);
    if (index !== -1) {
      documents.value[index] = savedDocument;
    } else {
      documents.value.unshift(savedDocument);
    }
  };

  const handleApiCall = async (apiFunction) => {
    isLoading.value = true;
    error.value = null;
    try {
      return await apiFunction();
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const analyzeDocumentContent = async (documentId) => {
    try {
      const id = documentId || currentDocument.value.id;
      console.log('Анализ содержимого документа, ID:', id);
      // Правильная передача параметров анализа
      const { data } = await axios.post(
        `${API_BASE}/api/documents/${id}/analyze`,
        {
          instructions: "",
          strictMode: false
        }
      );

      console.log("Полный ответ модели:", data);
      
      return {
        summary: data.summary || "Не удалось сгенерировать краткую суть",
        keySentences: Array.isArray(data.keySentences) ? 
          data.keySentences : 
          [],
        violations: Array.isArray(data.violations) ?
          data.violations :
          [],
        documentDate: data.documentDate || "",
        senderAgency: data.senderAgency || ""
      };
    } catch (error) {
      console.error("Ошибка анализа документа:", error);
      // Возвращаем объект с полями по умолчанию в случае ошибки
      return {
        summary: "Ошибка анализа документа: " + (error.response?.data?.message || error.message),
        keySentences: [],
        violations: [],
        documentDate: "",
        senderAgency: ""
      };
    }
  };

  const analyzeAttachments = async () => {
    console.log(
      "Анализ вложений, количество:",
      currentDocument.value.attachments?.length
    );
    if (!currentDocument.value.attachments?.length)
      return currentDocument.value.attachments;

    const analyzedAttachments = [];
    for (const attachment of currentDocument.value.attachments) {
      console.log("Анализ вложения:", attachment.id);
      if (attachment.text) {
        try {
          const { data } = await axios.post(
            `${API_BASE}/api/attachments/analyze`,
            { text: attachment.text }
          );
          console.log("Результат анализа вложения:", data);
          analyzedAttachments.push({
            ...attachment,
            analysis: data,
            documentDate: data.documentDate || "",
            senderAgency: data.senderAgency || "",
            summary: data.summary || "",
            keySentences: data.keySentences || [],
          });
        } catch (error) {
          console.error("Ошибка анализа вложения:", error);
          // Даже в случае ошибки добавляем вложение, но с полями по умолчанию
          analyzedAttachments.push({
            ...attachment,
            analysis: {
              documentType: "Неизвестный тип",
              sentDate: "",
              senderAgency: "",
              summary:
                "Ошибка анализа вложения: " +
                (error.response?.data?.message || error.message),
              keySentences: [],
            },
            documentDate: "",
            senderAgency: "",
            summary:
              "Ошибка анализа вложения: " +
              (error.response?.data?.message || error.message),
            keySentences: [],
          });
        }
      } else {
        console.log("Вложение не содержит текста:", attachment.id);
        analyzedAttachments.push(attachment);
      }
    }
    console.log("Анализ вложений завершен:", analyzedAttachments);
    return analyzedAttachments;
  };

  const determineTargetAgency = (text) => {
    const violations = text.match(/нарушен[ия]|незаконн|жалоб[аы]/gi);
    if (!violations) return "";

    if (text.includes("ФССП") || text.includes("судебн")) return "ФССП";
    if (text.includes("прокурор")) return "Прокуратура";
    if (text.includes("суд")) return "Суд";
    if (text.includes("омбудсмен")) return "Омбудсмен";

    return "ФССП";
  };

  const extractDate = (text) => {
    const dateRegex = /(\d{2}\.\d{2}\.\d{4})|(\d{4}-\d{2}-\d{2})/;
    const match = text.match(dateRegex);
    return match ? match[0] : "";
  };

  const extractAgency = (text) => {
    const agencies = ["ФССП", "Прокуратура", "Суд", "Омбудсмен"];
    return agencies.find((agency) => text.includes(agency)) || "";
  };

  const resetCurrentDocument = () => {
    currentDocument.value = {
      id: uuidv4(),
      date: new Date().toISOString().split("T")[0],
      agency: "",
      originalText: "",
      summary: "",
      keySentences: [],
      documentDate: "",
      senderAgency: "",
      attachments: [],
      complaints: [],
      analysisStatus: "pending",
      lastAnalyzedAt: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      violations: [],
    };
  };

  // Действия
  const fetchDocuments = async () => {
    return handleApiCall(async () => {
      const { data } = await axios.get(`${API_BASE}/api/documents`);
      documents.value = data.items || data;
    });
  };

  const fetchDocumentById = async (id) => {
    console.log("Загрузка документа по ID:", id);
    return handleApiCall(async () => {
      const { data } = await axios.get(`${API_BASE}/api/documents/${id}`);
      console.log("Загруженный документ:", data);
      // Документ уже в правильной структуре, просто присваиваем
      // Убедимся, что originalText правильно установлен
      currentDocument.value = {
        ...data,
        originalText: data.originalText !== undefined ? data.originalText : "",
      };
      return data;
    });
  };

  const uploadFiles = async (files) => {
    console.log("Загрузка файлов:", files);
    return handleApiCall(async () => {
      const formData = new FormData();
      if (currentDocument.value.originalText) {
        formData.append("text", currentDocument.value.originalText);
      }

      Array.from(files).forEach((file) => formData.append("files", file));

      const { data } = await axios.post(
        `${API_BASE}/api/documents/upload`,
        formData,
        { headers: { "Content-Type": "multipart/form-data" } }
      );

      console.log("Результат загрузки файлов:", data);
      // Бэкенд возвращает созданный документ в правильной структуре
      currentDocument.value = {
        ...currentDocument.value,
        ...data,
        // Убедимся, что originalText правильно установлен
        originalText:
          data.originalText || currentDocument.value.originalText || "",
      };
      return data;
    });
  };

  const saveDocument = async () => {
    console.log("Сохранение документа:", currentDocument.value);
    return handleApiCall(async () => {
      // Убедимся, что у документа есть все необходимые поля
      // и актуальная дата обновления
      currentDocument.value.updatedAt = new Date().toISOString();

      // Убедимся, что originalText не undefined
      currentDocument.value.originalText =
        currentDocument.value.originalText !== undefined
          ? currentDocument.value.originalText
          : "";

      let savedDocument;
      if (currentDocument.value.id) {
        console.log("Обновление существующего документа");
        const { data } = await axios.put(
          `${API_BASE}/api/documents/${currentDocument.value.id}`,
          currentDocument.value
        );
        savedDocument = data;
      } else {
        console.log("Создание нового документа");
        // Убедимся, что новый документ имеет правильную структуру
        const newDocToSave = {
          ...currentDocument.value,
          id: currentDocument.value.id || uuidv4(),
          createdAt:
            currentDocument.value.createdAt || new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          originalText:
            currentDocument.value.originalText !== undefined
              ? currentDocument.value.originalText
              : "",
        };
        const { data } = await axios.post(
          `${API_BASE}/api/documents`,
          newDocToSave
        );
        savedDocument = data;
      }

      updateDocumentsList(savedDocument);
      // После сохранения обновляем currentDocument значением от сервера
      currentDocument.value = {
        ...currentDocument.value,
        ...savedDocument,
        // Убедимся, что originalText правильно установлен
        originalText:
          savedDocument.originalText !== undefined
            ? savedDocument.originalText
            : currentDocument.value.originalText || "",
      };
      console.log("Документ сохранен:", savedDocument);
      return savedDocument;
    });
  };

  const deleteDocument = async (id) => {
    return handleApiCall(async () => {
      await axios.delete(`${API_BASE}/api/documents/${id}`);
      documents.value = documents.value.filter((doc) => doc.id !== id);

      if (currentDocument.value.id === id) {
        resetCurrentDocument();
      }
    });
  };

  const analyzeDocument = async (documentId = null) => {
    console.log("Анализ документа, ID:", documentId);
    // Если передан ID документа, загружаем его
    if (documentId) {
      await fetchDocumentById(documentId);
    }

    // Проверяем, есть ли текст для анализа
    const hasOriginalText =
      currentDocument.value.originalText &&
      currentDocument.value.originalText.trim().length > 0;
    const hasAttachmentsWithText = currentDocument.value.attachments?.some(
      (att) => att.text && att.text.trim().length > 0
    );

    console.log("Проверка текста для анализа:", {
      hasOriginalText,
      hasAttachmentsWithText,
    });

    if (!hasOriginalText && !hasAttachmentsWithText) {
      error.value = "Нет текста для анализа";
      console.log("Нет текста для анализа");
      return;
    }

    isAnalyzing.value = true;
    error.value = null;

    try {
      currentDocument.value.analysisStatus = "processing";

      const analysis = await analyzeDocumentContent(currentDocument.value.id);
      const attachmentsAnalysis = await analyzeAttachments();

      currentDocument.value = {
        ...currentDocument.value,
        ...analysis,
        attachments: attachmentsAnalysis,
        analysisStatus: "completed",
        lastAnalyzedAt: new Date().toISOString(),
      };

      const savedDocument = await saveDocument();
      return savedDocument;
    } catch (err) {
      console.error("Ошибка анализа документа:", err);
      currentDocument.value.analysisStatus = "failed";
      await saveDocument();
      throw err;
    } finally {
      isAnalyzing.value = false;
    }
  };

  const regenerateAttachmentAnalysis = async (attachmentId) => {
    isAnalyzing.value = true;
    try {
      const attachment = currentDocument.value.attachments.find(
        (a) => a.id === attachmentId
      );
      if (!attachment || !attachment.text) {
        throw new Error("Вложение не найдено или не содержит текст");
      }

      const { data } = await axios.post(`${API_BASE}/api/attachments/analyze`, {
        text: attachment.text,
      });

      const updatedAttachment = {
        ...attachment,
        analysis: data,
        documentDate: data.documentDate || "",
        senderAgency: data.senderAgency || "",
        summary: data.summary || "",
        keySentences: data.keySentences || [],
      };

      const index = currentDocument.value.attachments.findIndex(
        (a) => a.id === attachmentId
      );
      if (index !== -1) {
        currentDocument.value.attachments[index] = updatedAttachment;
        await saveDocument();
      }

      return updatedAttachment;
    } catch (err) {
      error.value = "Ошибка перегенерации анализа: " + err.message;
      throw err;
    } finally {
      isAnalyzing.value = false;
    }
  };

  const fetchComplaints = async (documentId) => {
    return handleApiCall(async () => {
      const { data } = await axios.get(
        `${API_BASE}/api/documents/${documentId}/complaints`
      );

      if (currentDocument.value.id === documentId) {
        currentDocument.value.complaints = data;
      }

      return data;
    });
  };

  const viewDocument = async (id) => {
    await fetchDocumentById(id);
    router.push(`/documents/${id}`);
  };

  // Экспортируемые значения
  return {
    // Состояние
    currentDocument,
    documents,
    isLoading,
    error,
    isAnalyzing,

    // Геттеры
    agenciesList,
    hasAttachments,
    analyzedDocuments,

    // Действия
    fetchDocuments,
    fetchDocumentById,
    uploadFiles,
    saveDocument,
    deleteDocument,
    analyzeDocument,
    regenerateAttachmentAnalysis,
    fetchComplaints,
    resetCurrentDocument,
    viewDocument,
  };
});


====================

// Файл: frontend\src\stores\complaintStore.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import axios from "axios";
import { saveAs } from "file-saver";

const API_BASE = "http://localhost:3001";

export const useComplaintStore = defineStore("complaint", () => {
  // Состояние
  const complaints = ref([]);
  const isLoading = ref(false);
  const error = ref(null);
  const isGenerating = ref(false);
  const isExporting = ref(false);

  // Геттеры
  const agenciesOptions = computed(() => [
    "Федеральная служба судебных приставов (ФССП)",
    "Прокуратура",
    "Суд (административное исковое заявление)",
    "Уполномоченный по правам человека (омбудсмен)",
  ]);

  const getComplaintsByDocument = computed(() => (documentId) => {
    return complaints.value.filter((c) => c.documentId === documentId);
  });

  // Действия
  const fetchComplaints = async () => {
    isLoading.value = true;
    error.value = null;
    try {
      const { data } = await axios.get(`${API_BASE}/api/complaints`);
      complaints.value = data;
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const generateComplaint = async (documentId, agency, instructions = "") => {
    isGenerating.value = true;
    error.value = null;

    try {
      const { data } = await axios.post(`${API_BASE}/api/complaints/generate`, {
        documentId,
        agency,
        instructions
      });

      complaints.value.unshift(data);
      return data;
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isGenerating.value = false;
    }
  };

  const exportComplaint = async (complaintId, format = "txt") => {
    isExporting.value = true;
    error.value = null;
    try {
      const response = await axios.get(
        `${API_BASE}/api/complaints/${complaintId}/export?format=${format}`,
        { responseType: format === "doc" ? "blob" : "text" }
      );

      const complaint = complaints.value.find(c => c.id === complaintId);
      const fileName = `Жалоба_${complaint.agency}_${new Date(complaint.createdAt).toLocaleDateString('ru-RU')}.${format}`;

      if (format === "doc") {
        saveAs(response.data, fileName);
      } else {
        const blob = new Blob([response.data], { type: "text/plain;charset=utf-8" });
        saveAs(blob, fileName);
      }

      return response.data;
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isExporting.value = false;
    }
  };

  const deleteComplaint = async (id) => {
    isLoading.value = true;
    error.value = null;
    try {
      await axios.delete(`${API_BASE}/api/complaints/${id}`);
      complaints.value = complaints.value.filter((c) => c.id !== id);
      return true;
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  return {
    // Состояние
    complaints,
    isLoading,
    error,
    isGenerating,
    isExporting,

    // Геттеры
    agenciesOptions,
    getComplaintsByDocument,

    // Действия
    fetchComplaints,
    generateComplaint,
    exportComplaint,
    deleteComplaint,
  };
});


====================

// Файл: frontend\src\stores\aiStore.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import axios from "axios";

export const useAIStore = defineStore("ai", () => {
  // Состояние
  const isLoading = ref(false);
  const error = ref(null);
  const apiStatus = ref("unknown");
  
  const apiUrl = ref("http://localhost:11434/api/generate");
  const model = ref("llama3.1/18/8192");
  
  const availableModels = ref([
    {
      name: "llama3.1/18/8192",
      description: "using 18 threads with 8192 num_ctx",
      parameters: {
        temperature: 0.3,
        top_p: 0.9,
      },
    },
  ]);

  const agencies = ref(["ФССП", "Прокуратура", "Суд", "Омбудсмен"]);

  // Действия
  const checkServerStatus = async () => {
    try {
      // Проверяем непосредственно AI сервер (Ollama)
      const response = await axios.get("http://localhost:11434/api/tags", {
        timeout: 5000
      });
      apiStatus.value = "ready";
      return true;
    } catch (error) {
      apiStatus.value = "offline";
      throw new Error("AI сервер недоступен");
    }
  };

  const analyzeText = async (text, options = {}) => {
    isLoading.value = true;
    error.value = null;
    
    try {
      const response = await axios.post(apiUrl.value, {
        model: model.value,
        prompt: text,
        stream: false,
        options: {
          temperature: options.temperature || 0.3,
          top_p: options.top_p || 0.9,
        }
      }, { timeout: 30000 });
      
      return response.data;
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const generateSummary = async (text) => {
    return analyzeText(text);
  };

  const analyzeAttachment = async (text) => {
    return analyzeText(text);
  };

  // Геттеры
  const isServerOnline = computed(() => apiStatus.value === "ready");
  
  const activeModelName = computed(() => {
    const modelObj = availableModels.value.find(m => m.name === model.value);
    return modelObj ? modelObj.description : "Неизвестная модель";
  });

  return {
    // Состояние
    isLoading,
    error,
    apiStatus,
    apiUrl,
    model,
    availableModels,
    agencies,

    // Действия
    checkServerStatus,
    analyzeText,
    generateSummary,
    analyzeAttachment,

    // Геттеры
    isServerOnline,
    activeModelName
  };
});

====================

// Файл: frontend\src\router\index.js
import { createRouter, createWebHistory } from "vue-router";

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: "/",
      name: "home",
      component: () => import("@/views/HomeView.vue"),
    },
    {
      path: "/review/:id",
      name: "review",
      component: () => import("@/views/DocumentReview.vue"),
      props: true,
    },
    {
      path: "/documents",
      name: "documents",
      component: () => import("@/views/DocumentsList.vue"),
    },
    {
      path: "/complaints",
      name: "complaints",
      component: () => import("@/views/ComplaintsList.vue"),
    },
    {
      path: "/documents/:id",
      name: "DocumentDetail",
      component: () => import("@/views/DocumentDetail.vue"),
      props: true,
    },
    {
      path: '/documents/:id/complaint',
      name: 'ComplaintForm',
      component: () => import('@/views/ComplaintForm.vue'),
      props: true
    },
    {
      path: '/complaints/:id',
      name: 'ComplaintDetail',
      component: () => import('@/views/ComplaintDetail.vue'),
      props: true
    }
  ],
});

export default router;











====================

// Файл: frontend\src\composables\useDocumentAnalysis.js
import { useDocumentStore } from '@/stores/documentStore';
import { useAIStore } from '@/stores/aiStore';

export const useDocumentAnalysis = () => {
  const documentStore = useDocumentStore();
  const aiStore = useAIStore();

  const analyzeCurrentDocument = async () => {
    return await documentStore.analyzeDocument();
  };

  const analyzeTextWithLLM = async (text) => {
    return await aiStore.analyzeText(text);
  };

  return {
    analyzeCurrentDocument,
    analyzeTextWithLLM
  };
};

====================

// Файл: frontend\src\components\ui\NotificationToast.vue
<template>
  <transition name="fade">
    <div v-if="show" class="notification-center">
      <div class="notification-content">
        {{ message }}
      </div>
    </div>
  </transition>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const props = defineProps({
  message: String,
  type: {
    type: String,
    default: 'success'
  },
  duration: {
    type: Number,
    default: 3000
  }
})

const show = ref(false)

onMounted(() => {
  show.value = true
  setTimeout(() => {
    show.value = false
  }, props.duration)
})
</script>



====================

// Файл: frontend\src\components\layout\Header.vue


====================

// Файл: frontend\src\components\layout\Footer.vue


====================

// Файл: frontend\src\components\icons\IconTooling.vue
<!-- This icon is from <https://github.com/Templarian/MaterialDesign>, distributed under Apache 2.0 (https://www.apache.org/licenses/LICENSE-2.0) license-->
<template>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    aria-hidden="true"
    role="img"
    class="iconify iconify--mdi"
    width="24"
    height="24"
    preserveAspectRatio="xMidYMid meet"
    viewBox="0 0 24 24"
  >
    <path
      d="M20 18v-4h-3v1h-2v-1H9v1H7v-1H4v4h16M6.33 8l-1.74 4H7v-1h2v1h6v-1h2v1h2.41l-1.74-4H6.33M9 5v1h6V5H9m12.84 7.61c.1.22.16.48.16.8V18c0 .53-.21 1-.6 1.41c-.4.4-.85.59-1.4.59H4c-.55 0-1-.19-1.4-.59C2.21 19 2 18.53 2 18v-4.59c0-.32.06-.58.16-.8L4.5 7.22C4.84 6.41 5.45 6 6.33 6H7V5c0-.55.18-1 .57-1.41C7.96 3.2 8.44 3 9 3h6c.56 0 1.04.2 1.43.59c.39.41.57.86.57 1.41v1h.67c.88 0 1.49.41 1.83 1.22l2.34 5.39z"
      fill="currentColor"
    ></path>
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconSupport.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor">
    <path
      d="M10 3.22l-.61-.6a5.5 5.5 0 0 0-7.666.105 5.5 5.5 0 0 0-.114 7.665L10 18.78l8.39-8.4a5.5 5.5 0 0 0-.114-7.665 5.5 5.5 0 0 0-7.666-.105l-.61.61z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconEcosystem.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="18" height="20" fill="currentColor">
    <path
      d="M11.447 8.894a1 1 0 1 0-.894-1.789l.894 1.789zm-2.894-.789a1 1 0 1 0 .894 1.789l-.894-1.789zm0 1.789a1 1 0 1 0 .894-1.789l-.894 1.789zM7.447 7.106a1 1 0 1 0-.894 1.789l.894-1.789zM10 9a1 1 0 1 0-2 0h2zm-2 2.5a1 1 0 1 0 2 0H8zm9.447-5.606a1 1 0 1 0-.894-1.789l.894 1.789zm-2.894-.789a1 1 0 1 0 .894 1.789l-.894-1.789zm2 .789a1 1 0 1 0 .894-1.789l-.894 1.789zm-1.106-2.789a1 1 0 1 0-.894 1.789l.894-1.789zM18 5a1 1 0 1 0-2 0h2zm-2 2.5a1 1 0 1 0 2 0h-2zm-5.447-4.606a1 1 0 1 0 .894-1.789l-.894 1.789zM9 1l.447-.894a1 1 0 0 0-.894 0L9 1zm-2.447.106a1 1 0 1 0 .894 1.789l-.894-1.789zm-6 3a1 1 0 1 0 .894 1.789L.553 4.106zm2.894.789a1 1 0 1 0-.894-1.789l.894 1.789zm-2-.789a1 1 0 1 0-.894 1.789l.894-1.789zm1.106 2.789a1 1 0 1 0 .894-1.789l-.894 1.789zM2 5a1 1 0 1 0-2 0h2zM0 7.5a1 1 0 1 0 2 0H0zm8.553 12.394a1 1 0 1 0 .894-1.789l-.894 1.789zm-1.106-2.789a1 1 0 1 0-.894 1.789l.894-1.789zm1.106 1a1 1 0 1 0 .894 1.789l-.894-1.789zm2.894.789a1 1 0 1 0-.894-1.789l.894 1.789zM8 19a1 1 0 1 0 2 0H8zm2-2.5a1 1 0 1 0-2 0h2zm-7.447.394a1 1 0 1 0 .894-1.789l-.894 1.789zM1 15H0a1 1 0 0 0 .553.894L1 15zm1-2.5a1 1 0 1 0-2 0h2zm12.553 2.606a1 1 0 1 0 .894 1.789l-.894-1.789zM17 15l.447.894A1 1 0 0 0 18 15h-1zm1-2.5a1 1 0 1 0-2 0h2zm-7.447-5.394l-2 1 .894 1.789 2-1-.894-1.789zm-1.106 1l-2-1-.894 1.789 2 1 .894-1.789zM8 9v2.5h2V9H8zm8.553-4.894l-2 1 .894 1.789 2-1-.894-1.789zm.894 0l-2-1-.894 1.789 2 1 .894-1.789zM16 5v2.5h2V5h-2zm-4.553-3.894l-2-1-.894 1.789 2 1 .894-1.789zm-2.894-1l-2 1 .894 1.789 2-1L8.553.106zM1.447 5.894l2-1-.894-1.789-2 1 .894 1.789zm-.894 0l2 1 .894-1.789-2-1-.894 1.789zM0 5v2.5h2V5H0zm9.447 13.106l-2-1-.894 1.789 2 1 .894-1.789zm0 1.789l2-1-.894-1.789-2 1 .894 1.789zM10 19v-2.5H8V19h2zm-6.553-3.894l-2-1-.894 1.789 2 1 .894-1.789zM2 15v-2.5H0V15h2zm13.447 1.894l2-1-.894-1.789-2 1 .894 1.789zM18 15v-2.5h-2V15h2z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconDocumentation.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="17" fill="currentColor">
    <path
      d="M11 2.253a1 1 0 1 0-2 0h2zm-2 13a1 1 0 1 0 2 0H9zm.447-12.167a1 1 0 1 0 1.107-1.666L9.447 3.086zM1 2.253L.447 1.42A1 1 0 0 0 0 2.253h1zm0 13H0a1 1 0 0 0 1.553.833L1 15.253zm8.447.833a1 1 0 1 0 1.107-1.666l-1.107 1.666zm0-14.666a1 1 0 1 0 1.107 1.666L9.447 1.42zM19 2.253h1a1 1 0 0 0-.447-.833L19 2.253zm0 13l-.553.833A1 1 0 0 0 20 15.253h-1zm-9.553-.833a1 1 0 1 0 1.107 1.666L9.447 14.42zM9 2.253v13h2v-13H9zm1.553-.833C9.203.523 7.42 0 5.5 0v2c1.572 0 2.961.431 3.947 1.086l1.107-1.666zM5.5 0C3.58 0 1.797.523.447 1.42l1.107 1.666C2.539 2.431 3.928 2 5.5 2V0zM0 2.253v13h2v-13H0zm1.553 13.833C2.539 15.431 3.928 15 5.5 15v-2c-1.92 0-3.703.523-5.053 1.42l1.107 1.666zM5.5 15c1.572 0 2.961.431 3.947 1.086l1.107-1.666C9.203 13.523 7.42 13 5.5 13v2zm5.053-11.914C11.539 2.431 12.928 2 14.5 2V0c-1.92 0-3.703.523-5.053 1.42l1.107 1.666zM14.5 2c1.573 0 2.961.431 3.947 1.086l1.107-1.666C18.203.523 16.421 0 14.5 0v2zm3.5.253v13h2v-13h-2zm1.553 12.167C18.203 13.523 16.421 13 14.5 13v2c1.573 0 2.961.431 3.947 1.086l1.107-1.666zM14.5 13c-1.92 0-3.703.523-5.053 1.42l1.107 1.666C11.539 15.431 12.928 15 14.5 15v-2z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconCommunity.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor">
    <path
      d="M15 4a1 1 0 1 0 0 2V4zm0 11v-1a1 1 0 0 0-1 1h1zm0 4l-.707.707A1 1 0 0 0 16 19h-1zm-4-4l.707-.707A1 1 0 0 0 11 14v1zm-4.707-1.293a1 1 0 0 0-1.414 1.414l1.414-1.414zm-.707.707l-.707-.707.707.707zM9 11v-1a1 1 0 0 0-.707.293L9 11zm-4 0h1a1 1 0 0 0-1-1v1zm0 4H4a1 1 0 0 0 1.707.707L5 15zm10-9h2V4h-2v2zm2 0a1 1 0 0 1 1 1h2a3 3 0 0 0-3-3v2zm1 1v6h2V7h-2zm0 6a1 1 0 0 1-1 1v2a3 3 0 0 0 3-3h-2zm-1 1h-2v2h2v-2zm-3 1v4h2v-4h-2zm1.707 3.293l-4-4-1.414 1.414 4 4 1.414-1.414zM11 14H7v2h4v-2zm-4 0c-.276 0-.525-.111-.707-.293l-1.414 1.414C5.42 15.663 6.172 16 7 16v-2zm-.707 1.121l3.414-3.414-1.414-1.414-3.414 3.414 1.414 1.414zM9 12h4v-2H9v2zm4 0a3 3 0 0 0 3-3h-2a1 1 0 0 1-1 1v2zm3-3V3h-2v6h2zm0-6a3 3 0 0 0-3-3v2a1 1 0 0 1 1 1h2zm-3-3H3v2h10V0zM3 0a3 3 0 0 0-3 3h2a1 1 0 0 1 1-1V0zM0 3v6h2V3H0zm0 6a3 3 0 0 0 3 3v-2a1 1 0 0 1-1-1H0zm3 3h2v-2H3v2zm1-1v4h2v-4H4zm1.707 4.707l.586-.586-1.414-1.414-.586.586 1.414 1.414z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\common\TextEditor.vue


====================

// Файл: frontend\src\components\common\FileUpload.vue
<template>
  <div class="file-upload">
    <input 
      type="file" 
      id="fileInput"
      ref="fileInput"
      :accept="allowedExtensions"
      @change="handleFileUpload"
      multiple
      hidden
    />
    <label for="fileInput" class="upload-button">
      {{ label }}
    </label>
    <div v-if="files.length > 0" class="file-list">
      <div v-for="(file, index) in files" :key="index" class="file-item">
        <span class="file-name">{{ file.name }}</span>
        <span class="file-size">{{ formatFileSize(file.size) }}</span>
        <button @click="removeFile(index)" class="remove-btn">×</button>
      </div>
    </div>
    <div v-if="error" class="error-message">{{ error }}</div>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const props = defineProps({
  label: {
    type: String,
    default: 'Выберите файлы'
  },
  maxSize: {
    type: Number,
    default: 10 * 1024 * 1024 // 10MB по умолчанию
  }
});

const emit = defineEmits(['files-selected', 'upload-error']);

const fileInput = ref(null);
const files = ref([]);
const error = ref(null);
const allowedExtensions = '.pdf,.txt,.doc,.docx';

const handleFileUpload = (event) => {
  error.value = null;
  const newFiles = Array.from(event.target.files);
  
  // Проверка каждого файла
  for (const file of newFiles) {
    // 1. Проверка расширения
    const extension = file.name.split('.').pop().toLowerCase();
    if (!['pdf', 'txt', 'doc', 'docx'].includes(extension)) {
      error.value = `Файл ${file.name}: недопустимое расширение`;
      emit('upload-error', error.value);
      return;
    }

    // 2. Проверка MIME-типа (клиентская проверка ненадежна, но лучше чем ничего)
    const allowedMimes = [
      'application/pdf',
      'text/plain',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
    
    if (file.type && !allowedMimes.includes(file.type)) {
      error.value = `Файл ${file.name}: недопустимый тип`;
      emit('upload-error', error.value);
      return;
    }

    // 3. Проверка размера
    if (file.size > props.maxSize) {
      error.value = `Файл ${file.name}: превышен максимальный размер (${props.maxSize / 1024 / 1024}MB)`;
      emit('upload-error', error.value);
      return;
    }
  }

  // Если все проверки пройдены
  files.value = [...files.value, ...newFiles];
  updateFileInput();
  emit('files-selected', files.value);
};

const removeFile = (index) => {
  files.value.splice(index, 1);
  updateFileInput();
  emit('files-selected', files.value);
};

const updateFileInput = () => {
  const dataTransfer = new DataTransfer();
  files.value.forEach(file => dataTransfer.items.add(file));
  fileInput.value.files = dataTransfer.files;
};

const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};
</script>



====================

