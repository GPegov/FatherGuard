// Файл: vite.config.js
import { fileURLToPath, URL } from 'node:url'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

// https://vite.dev/config/
export default defineConfig({
  server: {
    host: '0.0.0.0',
    proxy: {
      '/api': {
        target: 'http://localhost:11434',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },
  plugins: [
    vue(),
    vueDevTools(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  define: {
    // Решаем проблему с process is not defined
    'process.env': {},
    // Альтернативный вариант, если нужно передать конкретные переменные
    // 'process.env': {
    //   NODE_ENV: JSON.stringify(process.env.NODE_ENV)
    // }
  },
  optimizeDeps: {
    include: ['uuid'],
    exclude: ['@llama-node/core'] // Исключаем проблемные зависимости, если есть
  }
})

====================

// Файл: frontend\vite.config.js
import { fileURLToPath, URL } from 'node:url'
import { defineConfig, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

export default defineConfig(({ mode }) => {
  // Загружаем env переменные
  const env = loadEnv(mode, process.cwd(), ['VITE_'])

  return {
    server: {
      host: '0.0.0.0',
      port: parseInt(env.VITE_PORT || 5173), // Используем порт из env
      proxy: {
        '/ollama': {
          target: 'http://localhost:11434',
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/ollama/, '')
        },
        '/api': {
          target: env.VITE_API_BASE,
          changeOrigin: true
        }
      }
    },
    plugins: [
      vue(),
      vueDevTools(),
    ],
    resolve: {
      alias: {
        '@': fileURLToPath(new URL('./src', import.meta.url))
      }
    },
    define: {
      'process.env': {},
      '__APP_ENV__': JSON.stringify(env)
    },
    optimizeDeps: {
      include: ['uuid']
    }
  }
})

====================

// Файл: frontend\index.html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>


====================

// Файл: backend\test-ai.js
import aiService from './services/aiService.js';

async function test() {
  try {
    console.log("Testing AI connection...");
    const result = await aiService.analyzeLegalText(
      "Арендодатель запрещает держать животных в квартире"
    );
    console.log("✅ Success:", JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("❌ Error:", error.message);
    if (error.response) {
      console.error("Response data:", error.response.data);
    }
  } finally {
    process.exit();
  }
}

test();

====================

// Файл: backend\ai-test-cases.js
import aiService from './services/aiService.js';

const testCases = [
  {
    input: "Арендодатель запрещает держать кошек в квартире",
    expected: { violations: [{ article: expect.any(String) }] }
  },
  {
    input: "Договор запрещает возврат товара в течение 14 дней",
    expected: { violations: [{ article: "ст. 25 ЗПП" }] }
  }
];

async function runTests() {
  for (const test of testCases) {
    try {
      console.log(`\nTesting: "${test.input.substring(0, 30)}..."`);
      const result = await aiService.analyzeLegalText(test.input);
      
      console.log("Result:", {
        violations: result.violations.map(v => v.article),
        summary: result.summary
      });

      if (!result.violations.length) {
        console.warn("⚠️ No violations detected for:", test.input);
      }
    } catch (error) {
      console.error(`❌ Failed on: "${test.input}"`, error.message);
    }
  }
}

runTests();

====================

// Файл: backend\ai-bailiff-test.js
import aiService from './services/aiService.js';

const bailiffTestCases = [
  {
    description: "Сокрытие доходов от алиментов",
    text: "Плательщик алиментов не указал доходы от сдачи квартиры в аренду",
    expected: { article: "ст. 115 СК РФ" }
  },
  {
    description: "Нарушение сроков уведомления",
    text: "Судебный пристав не направил постановление в течение 3 дней",
    expected: { article: "ст. 30 229-ФЗ" }
  }
];

async function runBailiffTests() {
  let passed = 0;
  
  for (const test of bailiffTestCases) {
    try {
      console.log(`\nТест: ${test.description}`);
      const result = await aiService.analyzeLegalText(test.text);
      
      const foundViolation = result.violations.some(v => 
        v.article.includes(test.expected.article)
      );
      
      if (foundViolation) {
        passed++;
        console.log(`✅ Найдено нарушение: ${test.expected.article}`);
      } else {
        console.warn(`❌ Не обнаружено: ${test.expected.article}`);
        console.log("Полный ответ:", result);
      }
    } catch (error) {
      console.error(`Ошибка в тесте "${test.description}":`, error.message);
    }
  }
  
  console.log(`\nРезультат: ${passed}/${bailiffTestCases.length} тестов пройдено`);
}

runBailiffTests();

====================

// Файл: frontend\src\main.js
import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'


const app = createApp(App)

const pinia = createPinia()
app.use(pinia)


app.use(router)


app.mount('#app')

====================

// Файл: frontend\src\App.vue
<template>
  <div class="app">
    <header class="app-header">
      <nav class="nav-container">
        <router-link to="/" class="nav-logo">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" class="logo-icon">
            <path fill="currentColor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
          </svg>
          <span class="logo-text">Юридическая Защита Отцов</span>
        </router-link>
        <div class="nav-links">
          <router-link to="/" class="nav-link" exact-active-class="active">Главная</router-link>
          <router-link to="/documents" class="nav-link" exact-active-class="active">Документы</router-link>
          <router-link to="/complaints" class="nav-link" exact-active-class="active">Жалобы</router-link>
        </div>
      </nav>
    </header>

    <main class="app-main">
      <router-view v-slot="{ Component }">
        <transition name="fade" mode="out-in">
          <component :is="Component" />
        </transition>
      </router-view>
    </main>

    <footer class="app-footer">
      <div class="footer-content">
        <p>© 2025 Юридический сервис "Защита Отцов".</p>
      </div>
    </footer>
  </div>
</template>

<script setup>
import { watch } from 'vue'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'

const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()

// Загружаем данные при первом открытии соответствующих страниц
watch(
  () => documentStore.documents,
  (newVal) => {
    if (newVal.length === 0) { 
      documentStore.fetchDocuments()
    }
  },
  { immediate: true }
)
watch(
  () => documentStore.documents,
  (newVal) => {
    if (newVal.length === 0) { 
      documentStore.fetchComplaints()
    }
  },
  { immediate: true }
)
</script>



====================

// Файл: backend\services\pdfService.js
import pdf from 'pdf-parse';

export default {
  async extractTextFromPdf(buffer) {
    try {
      const data = await pdf(buffer);
      return {
        text: data.text,
        metadata: data.metadata,
        numPages: data.numpages
      };
    } catch (error) {
      console.error('PDF parsing error:', error);
      throw new Error('Не удалось обработать PDF файл');
    }
  }
}

====================

// Файл: backend\services\nlpService.js


====================

// Файл: backend\services\modelHealthCheck.js
import axios from 'axios';

export async function checkModelAvailability() {
  try {
    const response = await axios.get('http://localhost:11434', {
      timeout: 10000
    });
    return response.status === 200;
  } catch (error) {
    console.error('Модель недоступна:', error.message);
    return false;
  }
}

====================

// Файл: backend\services\FileService.js


====================

// Файл: backend\services\documentService.js


====================

// Файл: backend\services\aiService.js
import axios from "axios";

class AIService {
  constructor(apiUrl, activeModel) {
    this.apiUrl = 'http://localhost:11434/api/generate';
    this.activeModel = 'llama3.1/18/8192'; 
    this.defaultOptions = {
      temperature: 0.3,
      max_tokens: 16384,
      repeat_penalty: 1.2,
      format: "json",
    };
    this.analysisCache = new Map();
    this.maxRetries = 2;
    // Явная привязка методов
    this.queryLocalModel = this.queryLocalModel.bind(this);
    this.analyzeLegalText = this.analyzeLegalText.bind(this);
    this.safeParseResponse = this.safeParseResponse.bind(this);
    this.generateComplaintV2 = this.generateComplaintV2.bind(this);
    this.analyzeAttachment = this.analyzeAttachment.bind(this);
    this.parseAttachmentAnalysis = this.parseAttachmentAnalysis.bind(this);
  }

  async queryLocalModel(prompt, customOptions = {}) {
    const options = {
      method: 'POST',
      ...this.defaultOptions,
      ...customOptions,
      prompt: this.preparePrompt(prompt, customOptions.taskType),
    };

    try {
      const response = await axios.post(
        this.apiUrl,
        {
          model: this.activeModel,
          prompt,
          stream: false,
          format: "json",
          ...options,
        },
        { timeout: 500000 }
      );

      return this.safeParseResponse(response.data);
    } catch (error) {
      console.error("Ошибка запроса к модели:", error);
      throw this.normalizeError(error);
    }
  }

  async analyzeLegalText(text, instructions = "", strictMode = false) {
    console.log("Отправляемый текст:", text.substring(0, 200) + "...");
    const cacheKey = this.generateCacheKey(text, instructions);
    
    if (this.analysisCache.has(cacheKey)) {
      return this.analysisCache.get(cacheKey);
    }

    const prompt = this.buildAnalysisPrompt(text, instructions, strictMode);
    const result = await this.queryLocalModel(prompt, {
      temperature: 0.3,
      format: "json"
    });

    const parsedResult = this.safeParseResponse(result);
    
    if (!parsedResult) {
      throw new Error("Не удалось разобрать ответ модели");
    }

    const enhancedResult = {
      summary: parsedResult.summary || "Не удалось сгенерировать краткую суть",
      keyParagraphs: Array.isArray(parsedResult.keyParagraphs) ? 
        parsedResult.keyParagraphs.filter(p => p && p.length > 10) : 
        [],
      violations: Array.isArray(parsedResult.violations) ?
        parsedResult.violations :
        [],
      documentDate: parsedResult.documentDate || this.extractDate(text),
      senderAgency: parsedResult.senderAgency || this.extractAgency(text)
    };

    this.analysisCache.set(cacheKey, enhancedResult);
    return enhancedResult;
  }

  safeParseResponse(response) {
    try {
      if (typeof response === 'string') {
        // Попытка найти JSON в строке
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        return jsonMatch ? JSON.parse(jsonMatch[0]) : null;
      }
      return response;
    } catch (e) {
      console.error("Ошибка парсинга ответа:", e);
      return null;
    }
  }

  async generateComplaintV2(documentText, agency, relatedDocuments = [], instructions = "") {
    const prompt = this.buildComplaintPromptV2(documentText, agency, relatedDocuments, instructions);
    const response = await this.queryLocalModel(prompt, {
      temperature: 0.5,
      max_tokens: 7000
    });

    return {
      content: response.content || this.generateDefaultComplaint(documentText, agency),
      violations: response.violations || []
    };
  }

  async analyzeAttachment(text) {
    const prompt = this.buildAttachmentPrompt(text);
    const response = await this.queryLocalModel(prompt, {
      temperature: 0.2,
      format: "json",
    });

    return this.parseAttachmentAnalysis(response);
  }

  preparePrompt(text, taskType = "default") {
    const baseSystemPrompt = `[SYSTEM] Ты - юридический ассистент. Проанализируй текст как юридический документ.
Требования:
1. Только факты
2. Укажи ведомство и дату если есть
`;

    const taskSpecificPrompts = {
      summary: `${baseSystemPrompt}
Сгенерируй краткую суть документа объемом от трёх до пяти предложений: 
1. Повествование о клиенте в следующем стиле: 'Вы оспорили... Вы подали прошение...'
2. Без вступительных фраз вроде 'Документ:' или 
  'Краткая суть текста:' - сразу сгенерированная краткая суть!
[TEXT]: ${text.substring(0, 12000)}
[SUMMARY]:`,

      violations: `${baseSystemPrompt}
Найди нарушения в тексте. Формат:
- Закон: [название]
- Статья: [номер]
- Описание: [текст]
- Доказательство: [цитата]
[TEXT]: ${text.substring(0, 9000)}
[VIOLATIONS]:`,

      attachment: `${baseSystemPrompt}
Проанализируй вложение. Верни JSON:
{
  "documentType": "тип",
  "sentDate": "дата",
  "senderAgency": "ведомство",
  "summary": "суть",
  "keyParagraphs": ["ключевые параграфы документа во вложении"]
}
[TEXT]: ${text.substring(0, 9000)}
[ANALYSIS]:`,

      default: `${baseSystemPrompt}
[TEXT]: ${text.substring(0, 9000)}
[RESULT]:`
    };

    return taskSpecificPrompts[taskType] || taskSpecificPrompts.default;
  }

  buildAnalysisPrompt(text, instructions, strictMode) {
    return JSON.stringify({
      task: "ANALYZE_LEGAL_DOCUMENT",
      text: text.substring(0, 10000),
      requirements: {
        summaryLength: "3-5 предложений",
        keyParagraphs: {
          count: 3,
          exactQuotes: true,
        },
        extractDates: true,
        identifyAgencies: true,
        strictAnalysis: strictMode,
        additionalInstructions: instructions,
      },
      lawsToCheck: [
        "Федеральный закон 'Об исполнительном производстве' №229-ФЗ",
        "Семейный кодекс РФ",
        "КоАП РФ",
      ],
    });
  }

  buildComplaintPromptV2(text, agency, relatedDocuments, instructions = "") {
    return JSON.stringify({
      task: "GENERATE_COMPLAINT_V2",
      agency,
      sourceText: text.substring(0, 5000),
      relatedDocuments: relatedDocuments.map(doc => doc.substring(0, 2000)),
      requirements: {
        style: "Официальный",
        sections: [
          "Шапка (кому/от кого)",
          "Описание ситуации",
          "Ссылки на документы",
          "Нарушения",
          "Требования",
          "Приложения",
        ],
        includeReferences: true,
        citeLaws: true,
        additionalInstructions: instructions
      },
    });
  }

  buildAttachmentPrompt(text) {
    return this.preparePrompt(text, "attachment");
  }

  parseAttachmentAnalysis(response) {
    try {
      const parsed = this.safeParseResponse(response);
      return {
        documentType: parsed?.documentType || "Неизвестный тип",
        sentDate: parsed?.sentDate || "",
        senderAgency: parsed?.senderAgency || "",
        summary: parsed?.summary || "Не удалось сгенерировать краткую суть",
        keyParagraphs: parsed?.keyParagraphs || [],
      };
    } catch (e) {
      console.error("Ошибка парсинга анализа вложения:", e);
      return {
        documentType: "Неизвестный тип",
        sentDate: "",
        senderAgency: "",
        summary: "Ошибка анализа вложения",
        keyParagraphs: [],
      };
    }
  }

  generateCacheKey(text, instructions = "") {
    const str = text.substring(0, 200) + instructions;
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = (hash << 5) - hash + str.charCodeAt(i);
      hash |= 0;
    }
    return hash.toString(36);
  }

  extractDate(text) {
    const dateRegex = /(\d{2}\.\d{2}\.\d{4})|(\d{4}-\d{2}-\d{2})/;
    const match = text.match(dateRegex);
    return match ? match[0] : null;
  }

  extractAgency(text) {
    const agencies = ["ФССП", "Прокуратура", "Суд", "Омбудсмен"];
    return agencies.find(agency => text.includes(agency)) || "";
  }

  generateDefaultComplaint(text, agency) {
    return `В ${agency}\n\nЗаявитель: [ФИО]\n\nЖалоба на документ:\n${text.substring(
      0,
      500
    )}\n\nТребования: Провести проверку\n\nДата: ${new Date().toLocaleDateString()}`;
  }

  normalizeError(error) {
    const serverError = error.response?.data?.error;
    return serverError ? new Error(`Ошибка модели: ${serverError}`) : error;
  }
}

export default AIService;

====================

// Файл: backend\routes\documentRoutes.js
import { Router } from 'express';
import express from 'express';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import Document from '../models/Document.js';
import aiService from '../services/aiService.js';
import pdfService from '../services/pdfService.js';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default function documentRoutes({ db, upload }) {
  const router = Router();

  // Middleware для проверки JSON
  router.use(express.json({
    verify: (req, res, buf, encoding) => {
      try {
        JSON.parse(buf.toString());
      } catch (e) {
        console.error('Invalid JSON:', buf.toString());
        res.status(400).json({ message: 'Invalid JSON' });
        throw new Error('Invalid JSON');
      }
    }
  }));

  // Вспомогательные функции
  const normalizeDocument = (data) => {
    return {
      id: data.id || uuidv4(),
      date: data.date || new Date().toISOString().split('T')[0],
      agency: data.agency || '',
      originalText: data.originalText || '',
      summary: data.summary || '',
      documentDate: data.documentDate || '',
      senderAgency: data.senderAgency || '',
      keyParagraphs: data.keyParagraphs || [],
      attachments: (data.attachments || []).map(att => ({
        id: att.id || uuidv4(),
        name: att.name,
        type: att.type,
        size: att.size,
        path: att.path,
        text: att.text || '',
        analysis: att.analysis || null
      })),
      complaints: data.complaints || [],
      analysisStatus: data.analysisStatus || 'pending',
      lastAnalyzedAt: data.lastAnalyzedAt || null,
      createdAt: data.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  };

  const validateDocument = (doc) => {
    if (!doc.originalText && (!doc.attachments || doc.attachments.length === 0)) {
      throw new Error('Документ должен содержать текст или вложения');
    }
  };

  // Загрузка документа (текст + файлы)
  router.post('/upload', upload.array('files'), async (req, res) => {
    try {
      const userText = req.body.text || "";
      const userComments = req.body.comments || "";

      // Обработка только текста
      if (userText && (!req.files || req.files.length === 0)) {
        const newDocument = normalizeDocument({
          originalText: userText,
          comments: userComments
        });
        
        db.data.documents.push(newDocument);
        await db.write();
        return res.status(201).json(newDocument);
      }

      // Обработка файлов
      const filesData = await processUploadedFiles(req.files, userText, userComments);
      res.status(201).json(filesData[0]);
    } catch (err) {
      console.error('Ошибка загрузки:', err);
      res.status(500).json({ 
        message: err.message || 'Ошибка сервера при обработке документа'
      });
    }
  });

  // Обработка загруженных файлов
  const processUploadedFiles = async (files, userText, userComments) => {
    if (!files || files.length === 0) {
      throw new Error('Нет файлов для загрузки');
    }

    const filesData = [];
    
    for (const file of files) {
      try {
        const fileContent = await extractFileContent(file);
        const combinedText = [userText, fileContent].filter(Boolean).join('\n\n');

        const newDocument = normalizeDocument({
          originalText: combinedText,
          comments: userComments,
          attachments: [{
            name: file.originalname,
            type: file.mimetype,
            size: file.size,
            path: `/uploads/${file.filename}`,
            text: fileContent
          }]
        });

        db.data.documents.push(newDocument);
        await db.write();
        filesData.push(newDocument);
        await fs.unlink(file.path);
      } catch (fileError) {
        console.error(`Ошибка обработки файла ${file.originalname}:`, fileError);
        continue;
      }
    }

    return filesData;
  };

  // Извлечение текста из файла
  const extractFileContent = async (file) => {
    if (file.mimetype === 'application/pdf') {
      const dataBuffer = await fs.readFile(file.path);
      const pdfData = await pdfService.extractTextFromPdf(dataBuffer);
      return pdfData.text;
    } else if (file.mimetype === 'text/plain') {
      return await fs.readFile(file.path, 'utf-8');
    }
    throw new Error('Неподдерживаемый тип файла');
  };

  // Создание документа
  router.post('/', async (req, res) => {
    try {
      const doc = normalizeDocument(req.body);
      validateDocument(doc);
      
      db.data.documents.push(doc);
      await db.write();
      res.status(201).json(doc);
    } catch (err) {
      res.status(400).json({ message: err.message });
    }
  });

  // Получение списка документов
  router.get('/', async (req, res) => {
    try {
      await db.read();
      const { limit = 50, offset = 0 } = req.query;
      
      const documents = db.data.documents
        .slice(parseInt(offset), parseInt(offset) + parseInt(limit))
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      res.json({
        total: db.data.documents.length,
        items: documents
      });
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Получение документа по ID
  router.get('/:id', async (req, res) => {
    try {
      const doc = db.data.documents.find(d => d.id === req.params.id);
      if (!doc) return res.status(404).json({ message: 'Документ не найден' });
      res.json(doc);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Анализ документа
  router.post('/:id/analyze', async (req, res) => {
    try {
      const { model, instructions, strictMode } = req.body;
      const doc = db.data.documents.find(d => d.id === req.params.id);
      
      if (!doc) {
        return res.status(404).json({ 
          message: 'Документ не найден',
          documentId: req.params.id
        });
      }

      // Обновление статуса
      doc.analysisStatus = 'processing';
      doc.updatedAt = new Date().toISOString();
      await db.write();

      const analysis = await analyzeDocumentContent(doc, instructions, strictMode);
      await analyzeAttachments(doc);

      // Обновление документа
      updateDocumentAnalysis(doc, analysis);
      await db.write();

      res.json({
        ...analysis,
        modelUsed: model,
        analyzedAt: doc.lastAnalyzedAt
      });

    } catch (err) {
      console.error(`Ошибка анализа документа ${req.params.id}:`, err);
      
      // Обновление статуса в случае ошибки
      const doc = db.data.documents.find(d => d.id === req.params.id);
      if (doc) {
        doc.analysisStatus = 'failed';
        doc.updatedAt = new Date().toISOString();
        await db.write();
      }
      
      res.status(500).json({
        message: 'Ошибка при анализе документа',
        error: err.message,
        documentId: req.params.id,
        stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
      });
    }
  });

  // Анализ содержимого документа
  const analyzeDocumentContent = async (doc, instructions, strictMode) => {
    return await aiService.analyzeLegalText(
      doc.originalText,
      instructions,
      strictMode
    );
  };

  // Анализ вложений
  const analyzeAttachments = async (doc) => {
    if (!doc.attachments?.length) return;

    for (const attachment of doc.attachments) {
      if (attachment.text) {
        attachment.analysis = await aiService.analyzeLegalText(
          attachment.text,
          'Определи тип документа, дату отправления и ведомство',
          true
        );
      }
    }
  };

  // Обновление данных анализа
  const updateDocumentAnalysis = (doc, analysis) => {
    doc.summary = analysis.summary;
    doc.documentDate = analysis.documentDate || "";
    doc.senderAgency = analysis.senderAgency || "";
    doc.keyParagraphs = analysis.keyParagraphs;
    doc.analysisStatus = 'completed';
    doc.lastAnalyzedAt = new Date().toISOString();
    doc.updatedAt = new Date().toISOString();
  };

  // Удаление документа
  router.delete('/:id', async (req, res) => {
    try {
      await db.read();
      const initialLength = db.data.documents.length;
      db.data.documents = db.data.documents.filter(d => d.id !== req.params.id);
      
      if (db.data.documents.length === initialLength) {
        return res.status(404).json({ message: 'Document not found' });
      }
      
      await db.write();
      res.status(204).end();
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Жалобы для документа
  router.post('/:id/complaints', async (req, res) => {
    try {
      const { agency } = req.body;
      if (!agency) return res.status(400).json({ message: 'Не указано ведомство' });

      const doc = db.data.documents.find(d => d.id === req.params.id);
      if (!doc) return res.status(404).json({ message: 'Документ не найден' });

      const relatedDocs = db.data.documents.filter(d => 
        d.date <= doc.date && d.id !== req.params.id
      );

      const complaint = await generateComplaint(doc, agency, relatedDocs);
      saveComplaint(doc, complaint);

      res.status(201).json(complaint);
    } catch (err) {
      res.status(500).json({ 
        message: err.message || 'Ошибка генерации жалобы',
        details: err.response?.data
      });
    }
  });

  // Генерация жалобы
  const generateComplaint = async (doc, agency, relatedDocs) => {
    const complaint = await aiService.generateComplaintV2(
      doc.originalText,
      agency,
      relatedDocs.map(d => d.originalText)
    );

    return {
      id: uuidv4(),
      documentId: doc.id,
      agency,
      content: complaint.content,
      violations: complaint.violations || [],
      status: 'draft',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  };

  // Сохранение жалобы
  const saveComplaint = (doc, complaint) => {
    if (!db.data.complaints) {
      db.data.complaints = [];
    }
    db.data.complaints.push(complaint);

    if (!doc.complaints) {
      doc.complaints = [];
    }
    doc.complaints.push(complaint.id);
    doc.updatedAt = new Date().toISOString();
  };

  // Получение жалоб для документа
  router.get('/:id/complaints', async (req, res) => {
    try {
      const complaints = db.data.complaints?.filter(c => c.documentId === req.params.id) || [];
      res.json(complaints);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Обновление документа
  router.put('/:id', async (req, res) => {
    try {
      const docIndex = db.data.documents.findIndex(d => d.id === req.params.id);
      if (docIndex === -1) return res.status(404).json({ message: 'Document not found' });
      
      db.data.documents[docIndex] = {
        ...db.data.documents[docIndex],
        ...req.body,
        updatedAt: new Date().toISOString()
      };
      
      await db.write();
      res.json(db.data.documents[docIndex]);
    } catch (err) {
      res.status(400).json({ message: err.message });
    }
  });

  return router;
}











====================

// Файл: backend\routes\complaintRoutes.js
import { Router } from 'express';
import { v4 as uuidv4 } from 'uuid';
import * as docx from 'docx';
import { Document, Paragraph, TextRun, Packer } from 'docx';

export default function complaintRoutes({ db }) {
  const router = Router();

    const helpers = {
  async generateComplaintContent(doc, agency, relatedDocs, instructions) {
    try {
      // Используем AI сервис через dependency injection
      const aiService = req.app.get('aiService'); // Предполагаем, что сервис добавлен в app
      
      const complaint = await aiService.generateComplaintV2(
        doc.originalText,
        agency,
        relatedDocs.map(d => d.originalText),
        instructions
      );
      
      return complaint.content || this.generateFallbackComplaint(doc, agency);
    } catch (err) {
      console.error('Ошибка генерации жалобы через AI:', err);
      return this.generateFallbackComplaint(doc, agency);
    }
  },

  generateFallbackComplaint(doc, agency) {
    return `Жалоба в ${agency}\n\n` +
      `Документ: ${doc.summary || "Без описания"}\n` +
      `Дата: ${doc.documentDate || "Не указана"}\n\n` +
      `Текст: ${doc.originalText.substring(0, 500)}...`;
  }
};

  // Генерация жалобы (обновляем вызов)
  router.post('/generate', async (req, res) => {
    try {
      // ... существующий код
      const complaintContent = await helpers.generateComplaintContent(
        doc,
        agency,
        relatedDocs,
        instructions
      );
      // ... остальной код
    } catch (err) {
      // ... обработка ошибок
    }
  });



  // Генерация жалобы (обновлённая версия)
  router.post('/generate', async (req, res) => {
    try {
      const { documentId, agency, instructions } = req.body;
      
      // Проверка обязательных полей
      if (!agency || !documentId) {
        return res.status(400).json({ message: 'Не указаны обязательные параметры' });
      }

      // Поиск документа
      const doc = db.data.documents.find(d => d.id === documentId);
      if (!doc) {
        return res.status(404).json({ message: 'Document not found' });
      }

      // Поиск связанных документов
      const relatedDocs = db.data.documents.filter(d => 
        d.id !== documentId && d.date <= doc.date
      );

      // Генерация жалобы
      const complaintContent = await this.generateComplaintContent(
        doc,
        agency,
        relatedDocs,
        instructions
      );

      // Создание объекта жалобы
      const complaint = {
        id: uuidv4(),
        documentId,
        agency,
        content: complaintContent,
        relatedDocuments: relatedDocs.map(d => d.id),
        status: 'draft',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      // Сохранение в БД
      if (!db.data.complaints) {
        db.data.complaints = [];
      }
      db.data.complaints.push(complaint);
      await db.write();

      // Обновление документа
      if (!doc.complaints) {
        doc.complaints = [];
      }
      doc.complaints.push(complaint.id);
      await db.write();

      res.status(201).json(complaint);
    } catch (err) {
      console.error('Ошибка генерации жалобы:', err);
      res.status(500).json({ message: err.message });
    }
  });

  // Экспорт жалобы
  router.get('/:id/export', async (req, res) => {
    try {
      const { format = 'txt' } = req.query;
      const complaint = db.data.complaints.find(c => c.id === req.params.id);
      
      if (!complaint) {
        return res.status(404).json({ message: 'Complaint not found' });
      }

      if (format === 'txt') {
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Content-Disposition', `attachment; filename=complaint_${complaint.agency}.txt`);
        res.send(complaint.content);
      } 
      else if (format === 'doc') {
        const doc = new Document({
          sections: [{
            children: [
              new Paragraph({
                children: [
                  new TextRun({
                    text: complaint.content,
                    size: 24
                  })
                ]
              })
            ]
          }]
        });

        const buffer = await Packer.toBuffer(doc);
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
        res.setHeader('Content-Disposition', `attachment; filename=complaint_${complaint.agency}.docx`);
        res.send(buffer);
      }
      else {
        res.status(400).json({ message: 'Unsupported format' });
      }
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Получение всех жалоб
  router.get('/', async (req, res) => {
    try {
      await db.read();
      
      // Сортировка по дате создания (новые сначала)
      const complaints = db.data.complaints?.sort((a, b) => 
        new Date(b.createdAt) - new Date(a.createdAt)
      ) || [];
      
      res.json(complaints);
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Удаление жалобы
  router.delete('/:id', async (req, res) => {
    try {
      await db.read();
      const initialLength = db.data.complaints.length;
      
      // Удаление жалобы
      db.data.complaints = db.data.complaints.filter(c => c.id !== req.params.id);
      
      if (db.data.complaints.length === initialLength) {
        return res.status(404).json({ message: 'Complaint not found' });
      }
      
      // Удаление ссылки из документа
      for (const doc of db.data.documents) {
        if (doc.complaints) {
          doc.complaints = doc.complaints.filter(id => id !== req.params.id);
        }
      }
      
      await db.write();
      res.status(204).end();
    } catch (err) {
      res.status(500).json({ message: err.message });
    }
  });

  // Вспомогательный метод для генерации содержания жалобы
  async function generateComplaintContent(doc, agency, relatedDocs, instructions) {
    try {
      // Здесь должна быть логика обращения к AI сервису
      // Временная реализация:
      let content = `Жалоба в ${agency}\n\n`;
      content += `Основание: ${doc.summary || "Не указано"}\n\n`;
      content += `Дата документа: ${doc.documentDate || "Не указана"}\n`;
      content += `Ведомство: ${doc.agency || "Не указано"}\n\n`;
      
      if (doc.keyParagraphs?.length) {
        content += `Существенные моменты:\n${doc.keyParagraphs.join('\n')}\n\n`;
      }
      
      if (relatedDocs.length) {
        content += `Связанные документы:\n`;
        content += relatedDocs.map(d => `- ${d.date}: ${d.summary || "Без описания"}`).join('\n');
      }
      
      if (instructions) {
        content += `\n\nДополнительные указания: ${instructions}`;
      }
      
      content += `\n\nДата составления: ${new Date().toLocaleDateString()}`;
      
      return content;
    } catch (err) {
      console.error('Ошибка генерации содержания жалобы:', err);
      return `Жалоба в ${agency}\n\nТекст документа: ${doc.originalText.substring(0, 500)}...`;
    }
  }

  return router;
}

====================

// Файл: backend\routes\analysisRoutes.js


====================

// Файл: backend\routes\aiRoutes.js
import express from 'express';
const router = express.Router();
import aiController from '../controllers/aiController.js';

router.post('/analyze', aiController.analyzeText);
router.post('/generate-complaint', aiController.generateComplaint);

export default router;

====================

// Файл: backend\models\Document.js
export default class Document {
  constructor(data) {
    this.id = data.id || uuidv4();
    this.dateReceived = data.dateReceived || new Date().toISOString().split('T')[0];
    this.agency = data.agency || '';
    this.originalText = data.originalText || '';
    this.summary = data.summary || '';
    this.keyParagraphs = data.keyParagraphs || [];
    this.attachments = data.attachments || [];
    this.complaints = data.complaints || [];
    this.analysisStatus = data.analysisStatus || 'pending';
    this.lastAnalyzedAt = data.lastAnalyzedAt || null;
    this.createdAt = data.createdAt || new Date().toISOString();
    this.updatedAt = data.updatedAt || new Date().toISOString();
    
    // Поля для вложенных документов
    this.attachments = this.attachments.map(att => ({
      id: att.id || uuidv4(),
      name: att.name,
      type: att.type,
      size: att.size,
      path: att.path,
      text: att.text || '',
      analysis: att.analysis || {
        documentType: '',
        sentDate: '',
        senderAgency: '',
        summary: '',
        keyParagraphs: []
      }
    }));
  }

  validate() {
    if (!this.originalText && this.attachments.length === 0) {
      throw new Error('Документ должен содержать текст или вложения');
    }
    
    if (this.attachments.some(att => !att.text && !att.analysis)) {
      throw new Error('Все вложения должны содержать текст или анализ');
    }
  }
}

====================

// Файл: backend\models\Complaint.js


====================

// Файл: backend\middleware\aiErrorHandler.js
export default (err, req, res, next) => {
  if (err.message.includes('Ollama')) {
    console.error('AI Error:', {
      endpoint: req.originalUrl,
      input: req.body.text?.substring(0, 100),
      error: err.stack
    });
    
    return res.status(503).json({
      error: "Сервис анализа временно недоступен",
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
  next(err);
};

====================

// Файл: backend\controllers\documentController.js
import Document from '../models/Document.js';
import aiService from '../services/aiService.js';
import pdfService from '../services/pdfService.js';

export default {
  async createDocument(req, res) {
    try {
      const { text, files = [] } = req.body;
      const document = new Document({ text });
      
      if (files.length) {
        const fileContents = await Promise.all(
          files.map(file => pdfService.extractTextFromPdf(file.buffer))
        );
        document.text += '\n\n' + fileContents.join('\n\n');
      }

      const analysis = await aiService.analyzeWithDeepSeek(document.text);
      document.summary = analysis.summary;
      document.keyParagraphs = analysis.keyParagraphs;

      await document.save();
      res.status(201).json(document);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  },

  async analyzeDocument(req, res) {
    try {
      const document = await Document.findById(req.params.id);
      const analysis = await aiService.analyzeWithDeepSeek(
        document.originalText,
        req.body.instructions
      );
      
      document.analysis = analysis;
      await document.save();
      
      res.json(analysis);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
};

====================

// Файл: backend\controllers\complaintController.js
export default {
  async createAIComplaint(req, res) {
    try {
      const { text, agency, documentId } = req.body;
      const files = req.files?.attachments || [];

      // Анализ текста и файлов
      const fileContents = await Promise.all(
        files.map(file => parseFileContent(file.path))
      );
      
      const fullText = [text, ...fileContents].join('\n\n');
      const result = await aiService.generateComplaint(fullText, files, agency);

      // Сохранение жалобы
      const complaint = await Complaint.create({
        content: result.content,
        agency,
        documentId,
        analysis: result.analysis
      });

      res.json(complaint);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
};

====================

// Файл: backend\controllers\analysisController.js


====================

// Файл: backend\controllers\aiController.js
import aiService from '../services/aiService.js';

const analyzeText = async (req, res) => {
  try {
    const result = await aiService.analyzeText(req.body.text);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

const generateComplaint = async (req, res) => {
  try {
    const result = await aiService.generateComplaint(req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export default { analyzeText, generateComplaint };

====================

// Файл: frontend\src\views\HomeView.vue
<template>
  <div class="home-view">
    <h1>Изложите суть Вашей ситуации:</h1>
    <textarea 
      v-model="userText" 
      placeholder="Подробно опишите вашу ситуацию..."
      class="text-input"
    ></textarea>
    
    <div class="upload-section">
      <p>Приложите входящие документы (.txt / .pdf)</p>
      <FileUpload 
        label="Загрузить документы"
        @files-selected="handleFilesSelected"
        accept=".txt,.pdf"
      />
      <div v-if="files.length > 0" class="files-preview">
        <p>Выбранные файлы: {{ files.map(f => f.name).join(', ') }}</p>
      </div>
    </div>

    <button 
      @click="submitData"
      :disabled="!isFormValid || isLoading"
      class="submit-btn"
    >
      <span v-if="!isLoading">Продолжить</span>
      <span v-else>Обработка...</span>
    </button>

    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useRouter } from 'vue-router';
import FileUpload from '@/components/common/FileUpload.vue';
import { useDocumentStore } from '@/stores/documentStore';

const documentStore = useDocumentStore();
const router = useRouter();
const userText = ref('');
const files = ref([]);
const isLoading = ref(false);
const errorMessage = ref('');

const handleFilesSelected = (selectedFiles) => {
  files.value = selectedFiles;
  errorMessage.value = '';
};

const isFormValid = computed(() => {
  return userText.value.trim() !== '' || files.value.length > 0;
});

const submitData = async () => {
  if (!isFormValid.value || isLoading.value) return;

  isLoading.value = true;
  errorMessage.value = '';

  try {
    // Инициализируем новый документ с полной структурой
    const newDocument = {
      id: null, // Будет установлен при сохранении
      dateReceived: new Date().toISOString().split('T')[0],
      agency: '',
      originalText: userText.value,
      summary: '',
      documentDate: '',
      senderAgency: '',
      keyParagraphs: [],
      attachments: [],
      comments: userText.value,
      complaints: [],
      analysisStatus: 'pending',
      lastAnalyzedAt: null
    };

    // Обновляем документ в хранилище
    documentStore.currentDocument = newDocument;

    // Загружаем файлы (если есть)
    if (files.value.length > 0) {
      await documentStore.uploadFiles(files.value);
      // Предполагаем, что uploadFiles обновляет currentDocument.attachments
    }

    // Сохраняем документ
    const savedDoc = await documentStore.saveDocument();
    
    if (savedDoc?.id) {
      router.push({ 
        name: 'review', 
        params: { id: savedDoc.id },
        query: { new: 'true' }  
      });
    } else {
      throw new Error('Документ не был сохранен: отсутствует ID');
    }
  } catch (error) {
    console.error('Ошибка при создании документа:', error);
    errorMessage.value = error.response?.data?.message || 
                         error.message || 
                         'Произошла ошибка при сохранении документа';
    
    // Сбрасываем статус анализа в случае ошибки
    documentStore.currentDocument.analysisStatus = 'failed';
  } finally {
    isLoading.value = false;
  }
};
</script>



====================

// Файл: frontend\src\views\DocumentsList.vue
<template>
  <div class="documents-list">
    <div class="header">
      <h1>Архив входящих документов</h1>
      <router-link to="/" class="new-doc-btn">+ Новый документ</router-link>
    </div>

    <div class="filters">
      <input v-model="searchQuery" type="text" placeholder="Поиск по тексту" class="search-input" />
      <select v-model="selectedAgency" class="agency-select">
        <option value="">Все ведомства</option>
        <option v-for="agency in agenciesList" :key="agency" :value="agency">
          {{ agency }}
        </option>
      </select>
      <button @click="applyFilters" class="filter-btn">Применить</button>
      <button @click="resetFilters" class="filter-btn">Сбросить</button>
    </div>

    <div v-if="isLoading" class="loading">Загрузка документов...</div>
    <div v-else-if="filteredDocuments.length === 0" class="empty">
      Нет документов, соответствующих фильтрам
    </div>


    <ul v-else class="documents">
      <li 
        v-for="doc in filteredDocuments" 
        :key="doc.id" 
        class="document-item"
      >
        <div class="document-main" @click="viewDocument(doc.id)">
          <div class="document-meta">
            <span class="document-date">{{ formatDate(doc.date) }}</span>
            <span class="document-agency">{{ doc.agency }}</span>
          </div>
          <p class="document-summary">
            {{ doc.summary || doc.originalText.substring(0, 100) + '...' }}
          </p>
        </div>
        <div class="document-actions">
          <button 
            @click.stop="analyzeDocument(doc.id)" 
            class="analyze-btn" 
            :disabled="isAnalyzing"
          >
            {{ isAnalyzing ? 'Анализ...' : 'Проверить законность' }}
          </button>
          <button 
            @click.stop="confirmDelete(doc.id)" 
            class="delete-btn"
          >
            Удалить
          </button>
        </div>
      </li>
    </ul>


    <!-- Модальное окно подтверждения удаления -->
    <div v-if="showDeleteModal" class="modal-overlay">
      <div class="modal-content">
        <h3>Подтверждение удаления</h3>
        <p>Вы уверены, что хотите удалить этот документ?</p>
        <div class="modal-actions">
          <button @click="deleteDocument" class="confirm-btn">Да, удалить</button>
          <button @click="showDeleteModal = false" class="cancel-btn">Отмена</button>
        </div>
      </div>
    </div>



    <div v-if="showComplaintDialog" class="complaint-dialog">
      <div class="dialog-content">
        <h3>Выберите ведомство для жалобы</h3>
        <select v-model="selectedComplaintAgency" class="agency-select">
          <option v-for="agency in complaintAgencies" :key="agency" :value="agency">
            {{ agency }}
          </option>
        </select>
        <div class="dialog-actions">
          <button @click="generateComplaint" class="action-btn primary">
            Сформировать жалобу
          </button>
          <button @click="showComplaintDialog = false" class="action-btn">
            Отмена
          </button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="1500"
      @close="showNotification = false"
    />

  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'
import { useRouter } from 'vue-router'
import NotificationToast from '@/components/ui/NotificationToast.vue'

const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()
const router = useRouter()
const showNotification = ref(false)
const notificationMessage = ref('')
const notificationType = ref('success')

const isLoading = ref(false)
const isAnalyzing = ref(false)
const searchQuery = ref('')
const selectedAgency = ref('')
const showComplaintDialog = ref(false)
const selectedComplaintAgency = ref('')
const currentDocumentId = ref(null)

// Для удаления документов
const showDeleteModal = ref(false)
const documentToDelete = ref(null)

const confirmDelete = (id) => {
  documentToDelete.value = id
  showDeleteModal.value = true
}

const deleteDocument = async () => {
  if (documentToDelete.value) {
    try {
      await documentStore.deleteDocument(documentToDelete.value)
      await documentStore.fetchDocuments()
      
      // Показываем уведомление
      notificationMessage.value = 'Документ успешно удалён'
      notificationType.value = 'success'
      showNotification.value = true
    } catch (error) {
      console.error('Ошибка удаления:', error)
      
      // Уведомление об ошибке
      notificationMessage.value = 'Ошибка при удалении документа'
      notificationType.value = 'error'
      showNotification.value = true
    }
  }
  showDeleteModal.value = false
}


const viewDocument = (id) => {
  router.push(`/documents/${id}`)
}

// Загружаем документы при монтировании
onMounted(async () => {
  isLoading.value = true
  try {
    await documentStore.fetchDocuments()
  } finally {
    isLoading.value = false
  }
})

// Получаем список ведомств
const agenciesList = computed(() => documentStore.agenciesList)

// Фильтрация документов
const filteredDocuments = computed(() => {
  return documentStore.documents.filter((doc) => {
    const matchesSearch =
      searchQuery.value === '' ||
      doc.summary.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
      doc.originalText.toLowerCase().includes(searchQuery.value.toLowerCase())

    const matchesAgency =
      selectedAgency.value === '' || doc.agency === selectedAgency.value

    return matchesSearch && matchesAgency
  })
})

// Варианты ведомств для жалоб
const complaintAgencies = computed(() => complaintStore.agenciesOptions)

const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const applyFilters = () => {
  // Фильтрация происходит автоматически через computed свойство
}

const resetFilters = () => {
  searchQuery.value = ''
  selectedAgency.value = ''
}

const analyzeDocument = async (docId) => {
  isAnalyzing.value = true
  currentDocumentId.value = docId
  try {
    // Здесь будет вызов API к нейросети для анализа нарушений
    // После анализа показываем диалог выбора ведомства
    showComplaintDialog.value = true
  } catch (error) {
    console.error('Ошибка анализа:', error)
  } finally {
    isAnalyzing.value = false
  }
}

const generateComplaint = async () => {
  if (!selectedComplaintAgency.value || !currentDocumentId.value) return

  try {
    await complaintStore.generateAIComplaint(
      currentDocumentId.value,
      selectedComplaintAgency.value
    )
    router.push('/complaints')
  } catch (error) {
    console.error('Ошибка генерации жалобы:', error)
  } finally {
    showComplaintDialog.value = false
  }
}
</script>



====================

// Файл: frontend\src\views\DocumentReview.vue
<template>
  <div class="document-review">
    <div class="header">
      <h1>Предпросмотр документа</h1>
      <button @click="goBack" class="back-button">← Назад</button>
    </div>

    <div v-if="isLoading" class="loading-state">
      <div class="spinner"></div>
      <p>Загрузка данных...</p>
    </div>

    <div v-else class="review-container">
      <form @submit.prevent="handleSubmit" class="review-form">
        <!-- Основные поля -->
        <div class="form-section">
          <h2>Основная информация</h2>
          <div class="form-group">
            <label for="date">Дата поступления:</label>
            <input type="date" id="date" v-model="document.date" required class="form-input" />
          </div>

          <div class="form-group">
            <label for="agency">Ведомство, допустившее нарушение:</label>
            <input type="text" id="agency" v-model="document.agency" list="agencies" required class="form-input"
              placeholder="Выберите ведомство" />
            <datalist id="agencies">
              <option v-for="agency in agenciesList" :key="agency">{{ agency }}</option>
            </datalist>
          </div>

          <div class="form-group">
            <label for="originalText">Текст документа:</label>
            <textarea id="originalText" v-model="document.originalText" required class="form-textarea" rows="8"
              placeholder="Введите текст документа"></textarea>
          </div>
        </div>

        <!-- Анализ документа -->
        <div class="form-section" v-if="document.analysisStatus !== 'pending'">
          <h2>Анализ документа</h2>

          <div class="form-group" v-if="document.analysisStatus === 'completed'">
            <label>Краткая суть:</label>
            <div class="summary-container">
              <textarea v-model="document.summary" required class="form-textarea" rows="3"
                placeholder="Анализ выполняется..."></textarea>
              <button type="button" @click="regenerateSummary" class="refresh-btn" :disabled="aiStore.isLoading"
                title="Перегенерировать краткую суть">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                  <path d="M3 3v5h5" />
                  <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
                  <path d="M16 16h5v5" />
                </svg>
              </button>
            </div>
          </div>

          <div class="form-group">
            <label>Дата отправления документа:</label>
            <input v-model="document.documentDate" type="date" class="form-input" />
          </div>

          <div class="form-group">
            <label>Ведомство-отправитель:</label>
            <input v-model="document.senderAgency" class="form-input" list="agencies" />
          </div>

          <!-- Ключевые параграфы -->
          <div class="form-group" v-if="document.analysisStatus === 'completed'">
            <label>Существенные параграфы:</label>
            <div v-for="(paragraph, index) in document.keyParagraphs" :key="index" class="paragraph-item">
              <textarea v-model="document.keyParagraphs[index]" required class="form-textarea" rows="3"></textarea>
              <button type="button" @click="removeParagraph(index)" class="remove-btn" title="Удалить параграф">
                ×
              </button>
            </div>
            <button type="button" @click="addParagraph" class="add-btn" title="Добавить параграф">
              + Добавить параграф
            </button>
          </div>
        </div>

        <!-- Вложения -->
        <div class="form-section" v-if="document.attachments?.length">
          <h2>Вложенные документы</h2>
          <div v-for="(attachment, idx) in document.attachments" :key="attachment.id || idx"
            class="attachment-analysis">
            <div class="attachment-header">
              <h3>{{ attachment.name }}</h3>
              <span class="file-size">{{ formatFileSize(attachment.size) }}</span>
              <button @click="regenerateAttachmentAnalysis(attachment.id)" class="refresh-btn" :disabled="isAnalyzing"
                title="Переанализировать документ">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
                  <path d="M3 3v5h5" />
                  <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" />
                  <path d="M16 16h5v5" />
                </svg>
              </button>
            </div>

            <div v-if="attachment.analysis" class="attachment-details">
              <div class="detail-row">
                <span class="detail-label">Тип документа:</span>
                <span>{{ attachment.analysis.documentType || 'Не указан' }}</span>
              </div>
              <div class="detail-row">
                <span class="detail-label">Дата отправления:</span>
                <input type="date" v-model="attachment.documentDate" class="form-input small">
              </div>
              <div class="detail-row">
                <span class="detail-label">Ведомство-отправитель:</span>
                <input v-model="attachment.senderAgency" class="form-input small" list="agencies">
              </div>
              <div class="detail-row full-width">
                <span class="detail-label">Краткая суть:</span>
                <textarea v-model="attachment.documentSummary" class="form-textarea" rows="3"></textarea>
              </div>
              <div class="detail-row full-width">
                <span class="detail-label">Полный текст:</span>
                <textarea v-model="attachment.fullText" class="form-textarea" rows="6" readonly></textarea>
              </div>

              <div class="key-paragraphs">
                <h4>Ключевые параграфы:</h4>
                <div v-for="(paragraph, index) in attachment.keyParagraphs" :key="index" class="paragraph-item">
                  <textarea v-model="attachment.keyParagraphs[index]" class="form-textarea" rows="2"></textarea>
                  <button type="button" @click="removeAttachmentParagraph(attachment.id, index)" class="remove-btn"
                    title="Удалить параграф">
                    ×
                  </button>
                </div>
                <button type="button" @click="addAttachmentParagraph(attachment.id)" class="add-btn"
                  title="Добавить параграф">
                  + Добавить параграф
                </button>
              </div>
            </div>
            <div v-else class="no-analysis">
              <p>Анализ не выполнен</p>
              <button @click="analyzeAttachment(attachment)" class="analyze-btn" :disabled="isAnalyzing">
                Анализировать
              </button>
            </div>
          </div>
        </div>



        <!-- Кнопки действий -->
        <div class="form-actions">
          <button type="button" @click="analyzeDocument" class="analyze-btn"
            :disabled="isAnalyzing || !document.originalText">
            <span v-if="isAnalyzing" class="button-loader"></span>
            {{ isAnalyzing ? 'Анализ...' : 'Анализировать документ' }}
          </button>

          <button type="submit" class="save-btn" :disabled="isSaving">
            {{ isSaving ? 'Сохранение...' : 'Сохранить документ' }}
          </button>
        </div>
      </form>

      <!-- Блок статуса -->
      <div class="status-section">
        <div class="status-indicator" :class="document.analysisStatus">
          Статус анализа:
          <span>{{ getStatusText(document.analysisStatus) }}</span>
        </div>
        <div v-if="document.lastAnalyzedAt" class="last-analyzed">
          Последний анализ: {{ formatDate(document.lastAnalyzedAt) }}
        </div>
      </div>

      <!-- Уведомления об ошибках -->
      <div v-if="error" class="error-message">
        <div class="error-content">
          <span class="error-icon">!</span>
          <span>{{ error }}</span>
          <button @click="error = null" class="close-error" title="Закрыть">×</button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAIStore } from '@/stores/aiStore'
import { useDocumentStore } from '@/stores/documentStore'

const router = useRouter()
const aiStore = useAIStore()
const documentStore = useDocumentStore()

const isLoading = ref(true)
const isSaving = ref(false)
const isAnalyzing = ref(false)
const error = ref(null)

const document = ref({
  ...documentStore.currentDocument
})

const agenciesList = computed(() => documentStore.agenciesList)

onMounted(async () => {
  try {
    await aiStore.checkServerStatus()

    if (!document.value.id && !document.value.originalText) {
      router.push('/')
      return
    }

    if (document.value.id) {
      await documentStore.fetchDocumentById(document.value.id)
      document.value = {
        ...documentStore.currentDocument,
        attachments: documentStore.currentDocument.attachments?.map(att => ({
          ...att,
          analysis: att.analysis || null
        })) || []
      }
    }
  } catch (err) {
    error.value = 'Ошибка загрузки: ' + err.message
  } finally {
    isLoading.value = false
  }
})

const addAttachmentParagraph = (attachmentId) => {
  const attachment = document.value.attachments.find(a => a.id === attachmentId);
  if (attachment) {
    if (!attachment.keyParagraphs) {
      attachment.keyParagraphs = [];
    }
    attachment.keyParagraphs.push('');
  }
};

const removeAttachmentParagraph = (attachmentId, index) => {
  const attachment = document.value.attachments.find(a => a.id === attachmentId);
  if (attachment && attachment.keyParagraphs) {
    attachment.keyParagraphs.splice(index, 1);
  }
};

// Обновленный метод анализа вложения
const analyzeAttachment = async (attachment) => {
  if (!attachment.text) return;
  
  isAnalyzing.value = true;
  try {
    const analysis = await documentStore.analyzeAttachment(attachment);
    const index = document.value.attachments.findIndex(a => a.id === attachment.id);
    if (index !== -1) {
      document.value.attachments[index] = {
        ...document.value.attachments[index],
        ...analysis
      };
    }
  } catch (err) {
    error.value = 'Ошибка анализа вложения: ' + err.message;
  } finally {
    isAnalyzing.value = false;
  }
};

// Метод для перегенерации анализа
const regenerateAttachmentAnalysis = async (attachmentId) => {
  isAnalyzing.value = true;
  try {
    const updatedAttachment = await documentStore.regenerateAttachmentAnalysis(attachmentId);
    const index = document.value.attachments.findIndex(a => a.id === attachmentId);
    if (index !== -1) {
      document.value.attachments[index] = updatedAttachment;
    }
  } catch (err) {
    error.value = 'Ошибка перегенерации анализа: ' + err.message;
  } finally {
    isAnalyzing.value = false;
  }
}

const addParagraph = () => {
  document.value.keyParagraphs.push('')
}

const removeParagraph = (index) => {
  document.value.keyParagraphs.splice(index, 1)
}

const analyzeDocument = async () => {
  isAnalyzing.value = true
  error.value = null

  try {
    const analysis = await documentStore.analyzeDocument()

    document.value = {
      ...document.value,
      summary: analysis.summary,
      keyParagraphs: analysis.keyParagraphs,
      documentDate: analysis.documentDate || '',
      senderAgency: analysis.senderAgency || '',
      analysisStatus: 'completed',
      lastAnalyzedAt: new Date().toISOString()
    }
  } catch (err) {
    error.value = 'Ошибка анализа: ' + err.message
  } finally {
    isAnalyzing.value = false
  }
}


const regenerateSummary = async () => {
  isAnalyzing.value = true
  try {
    document.value.summary = await aiStore.generateSummary(document.value.originalText)
  } catch (err) {
    error.value = 'Ошибка перегенерации: ' + err.message
  } finally {
    isAnalyzing.value = false
  }
}

const handleSubmit = async () => {
  isSaving.value = true
  error.value = null

  try {
    documentStore.currentDocument = document.value
    await documentStore.saveDocument()
    router.push('/documents')
  } catch (err) {
    error.value = 'Ошибка сохранения: ' + err.message
  } finally {
    isSaving.value = false
  }
}

const goBack = () => {
  router.push('/')
}

const formatDate = (dateString) => {
  if (!dateString) return ''
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const formatFileSize = (bytes) => {
  if (!bytes) return '0 KB'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i]
  )
}

const getStatusText = (status) => {
  const statusMap = {
    pending: 'Ожидает анализа',
    processing: 'В процессе',
    completed: 'Завершён',
    failed: 'Ошибка'
  }
  return statusMap[status] || status
}
</script>



====================

// Файл: frontend\src\views\DocumentDetail.vue
<!-- src/views/DocumentDetail.vue -->
<template>
  <div class="document-detail">
    <button @click="goBack" class="back-button">← Назад к списку</button>
    
    <div v-if="loading" class="loading-state">
      <p>Загрузка документа...</p>
    </div>
    <div v-else-if="error" class="error-state">
      <p>Ошибка загрузки: {{ error }}</p>
    </div>
    <div v-else-if="!document" class="empty-state">
      <p>Документ не найден</p>
    </div>
    <div v-else class="document-content">
      <div class="document-header">
        <h1>Документ #{{ document.id }}</h1>
        <span class="document-date">{{ formatDate(document.date) }}</span>
      </div>
      <div class="document-meta">
        <div v-if="document.agency" class="meta-field">
          <span class="meta-label">Ведомство:</span>
          <span class="meta-value">{{ document.agency }}</span>
        </div>
        
        <div class="meta-field">
          <span class="meta-label">Дата создания:</span>
          <span class="meta-value">{{ formatDateTime(document.createdAt) }}</span>
        </div>
      </div>
      
      <!-- Кнопка создания жалобы -->
      <div class="complaint-action">
        <button @click="createComplaint" class="create-complaint-btn">
          Создать жалобу
        </button>
      </div>
      
      <div class="document-section">
        <h2>Исходный текст</h2>
        <pre class="original-text">{{ document.originalText }}</pre>
      </div>
      <div v-if="document.summary" class="document-section">
        <h2>Краткое содержание</h2>
        <p class="summary-text">{{ document.summary }}</p>
      </div>
      <div v-if="document.keyParagraphs?.length" class="document-section">
        <h2>Ключевые параграфы</h2>
        <ul class="paragraphs-list">
          <li v-for="(para, index) in document.keyParagraphs" :key="index">
            {{ para }}
          </li>
        </ul>
      </div>
      <div v-if="document.attachments?.length" class="document-section">
        <h2>Прикрепленные файлы</h2>
        <div class="attachments-list">
          <div v-for="file in document.attachments" :key="file.id" class="attachment-item">
            <div class="attachment-info">
              <span class="attachment-name">{{ file.name }}</span>
              <span class="attachment-size">{{ formatFileSize(file.size) }}</span>
            </div>
            <a 
              :href="getFileUrl(file.path)" 
              target="_blank"
              class="download-button"
            >
              Скачать
            </a>
          </div>
        </div>
      </div>
      <div v-if="document.comments" class="document-section">
        <h2>Комментарии</h2>
        <p class="comments-text">{{ document.comments }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/documentStore'

const route = useRoute()
const router = useRouter()
const documentStore = useDocumentStore()

const document = ref(null)
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    loading.value = true
    error.value = null
    await documentStore.fetchDocumentById(route.params.id)
    document.value = { ...documentStore.currentDocument }
  } catch (err) {
    error.value = err.message || 'Не удалось загрузить документ'
    console.error('Ошибка загрузки документа:', err)
  } finally {
    loading.value = false
  }
})

const formatDate = (dateString) => {
  return dateString ? new Date(dateString).toLocaleDateString('ru-RU') : 'Дата не указана'
}

const formatDateTime = (dateString) => {
  if (!dateString) return 'Дата не указана'
  const options = {
    day: 'numeric',
    month: 'numeric',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  }
  return new Date(dateString).toLocaleString('ru-RU', options)
}

const formatFileSize = (bytes) => {
  if (!bytes) return '0 KB'
  return `${(bytes / 1024).toFixed(2)} KB`
}

const getFileUrl = (path) => {
  return path.startsWith('http') ? path : `http://localhost:3001${path}`
}

const goBack = () => {
  router.push('/documents')
}

const createComplaint = () => {
  router.push(`/documents/${route.params.id}/complaint`)
}
</script>











<!-- <template>
  <div class="document-detail">
    <button @click="goBack" class="back-button">← Назад к списку</button>
    
    <div v-if="loading" class="loading-state">
      <p>Загрузка документа...</p>
    </div>

    <div v-else-if="error" class="error-state">
      <p>Ошибка загрузки: {{ error }}</p>
    </div>

    <div v-else-if="!document" class="empty-state">
      <p>Документ не найден</p>
    </div>

    <div v-else class="document-content">
      <div class="document-header">
        <h1>Документ #{{ document.id }}</h1>
        <span class="document-date">{{ formatDate(document.date) }}</span>
      </div>

      <div class="document-meta">
        <div v-if="document.agency" class="meta-field">
          <span class="meta-label">Ведомство:</span>
          <span class="meta-value">{{ document.agency }}</span>
        </div>
        
        <div class="meta-field">
          <span class="meta-label">Дата создания:</span>
          <span class="meta-value">{{ formatDateTime(document.createdAt) }}</span>
        </div>
      </div>

      <div class="document-section">
        <h2>Исходный текст</h2>
        <pre class="original-text">{{ document.originalText }}</pre>
      </div>

      <div v-if="document.summary" class="document-section">
        <h2>Краткое содержание</h2>
        <p class="summary-text">{{ document.summary }}</p>
      </div>

      <div v-if="document.keyParagraphs?.length" class="document-section">
        <h2>Ключевые параграфы</h2>
        <ul class="paragraphs-list">
          <li v-for="(para, index) in document.keyParagraphs" :key="index">
            {{ para }}
          </li>
        </ul>
      </div>

      <div v-if="document.attachments?.length" class="document-section">
        <h2>Прикрепленные файлы</h2>
        <div class="attachments-list">
          <div v-for="file in document.attachments" :key="file.id" class="attachment-item">
            <div class="attachment-info">
              <span class="attachment-name">{{ file.name }}</span>
              <span class="attachment-size">{{ formatFileSize(file.size) }}</span>
            </div>
            <a 
              :href="getFileUrl(file.path)" 
              target="_blank"
              class="download-button"
            >
              Скачать
            </a>
          </div>
        </div>
      </div>

      <div v-if="document.comments" class="document-section">
        <h2>Комментарии</h2>
        <p class="comments-text">{{ document.comments }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/documentStore'

const route = useRoute()
const router = useRouter()
const documentStore = useDocumentStore()

const document = ref(null)
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    loading.value = true
    error.value = null
    await documentStore.fetchDocumentById(route.params.id)
    document.value = { ...documentStore.currentDocument }
  } catch (err) {
    error.value = err.message || 'Не удалось загрузить документ'
    console.error('Ошибка загрузки документа:', err)
  } finally {
    loading.value = false
  }
})

const formatDate = (dateString) => {
  return dateString ? new Date(dateString).toLocaleDateString('ru-RU') : 'Дата не указана'
}

const formatDateTime = (dateString) => {
  if (!dateString) return 'Дата не указана'
  const options = {
    day: 'numeric',
    month: 'numeric',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  }
  return new Date(dateString).toLocaleString('ru-RU', options)
}

const formatFileSize = (bytes) => {
  if (!bytes) return '0 KB'
  return `${(bytes / 1024).toFixed(2)} KB`
}

const getFileUrl = (path) => {
  return path.startsWith('http') ? path : `http://localhost:3001${path}`
}

const goBack = () => {
  router.push('/documents')
}
</script>

 -->

====================

// Файл: frontend\src\views\ComplaintsList.vue
<template>
  <div class="complaints-list">
    <div class="header">
      <h1>Сформированные жалобы</h1>
      <router-link to="/documents" class="back-btn">← К документам</router-link>
    </div>

    <!-- Отладочная информация -->
    <div v-if="debugMode" class="debug-info">
      <pre>Store state: {{ JSON.stringify(complaintStore.$state, null, 2) }}</pre>
    </div>

    <div v-if="isLoading" class="loading">
      <p>Загрузка жалоб...</p>
      <progress indeterminate></progress>
    </div>

    <div v-else-if="!complaints.length" class="empty">
      <p>Нет сформированных жалоб</p>
      <router-link to="/" class="create-link">Создать первую жалобу</router-link>
    </div>

    <ul v-else class="complaints">
      <li v-for="complaint in complaints" :key="complaint.id" class="complaint-item">
        <div class="complaint-card">
          <h3>{{ complaint.agency }}</h3>
          <p class="date">{{ formatDate(complaint.createdAt) }}</p>
          <p class="preview">{{ complaint.content.substring(0, 100) }}...</p>
          <div class="actions">
            <button @click="exportComplaint(complaint.id, 'txt')" class="export-btn">
              TXT
            </button>
            <button @click="exportComplaint(complaint.id, 'doc')" class="export-btn">
              DOC
            </button>
            <button 
              @click.stop="confirmDelete(complaint)" 
              class="delete-btn"
            >
              Удалить
            </button>
          </div>
        </div>
      </li>
    </ul>

    <!-- Модальное окно подтверждения удаления -->
    <div v-if="showDeleteModal" class="modal-overlay">
      <div class="modal-content">
        <h3>Подтверждение удаления</h3>
        <p>Вы уверены, что хотите удалить жалобу в "{{ complaintToDelete?.agency }}"?</p>
        <div class="modal-actions">
          <button @click="deleteComplaint" class="confirm-btn">Да, удалить</button>
          <button @click="showDeleteModal = false" class="cancel-btn">Отмена</button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="1500"
      @close="showNotification = false"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useComplaintStore } from '@/stores/complaintStore'
import { saveAs } from 'file-saver'
import NotificationToast from '@/components/ui/NotificationToast.vue'


const analyzeBailiffAction = async (text) => {
  try {
    const analysis = await complaintStore.analyzeLegalText(text);
    
    if (analysis.violations.some(v => v.side === 'пристав')) {
      useToast().show({
        title: "Нарушение ФЗ 'О судебных приставах'",
        message: `Статья ${analysis.violations[0].article}`,
        variant: "warning"
      });
    }
    
    return {
      payerTips: analysis.recommendations.payer,
      bailiffWarnings: analysis.violations
        .filter(v => v.side === 'пристав')
    };
  } catch (error) {
    useToast().error("Ошибка анализа алиментного дела");
    throw error;
  }
};


// Debug
const debugMode = ref(false)

// Store
const complaintStore = useComplaintStore()
const isLoading = ref(false)
const complaints = computed(() => complaintStore.complaints || [])

// Удаление жалоб
const showDeleteModal = ref(false)
const complaintToDelete = ref(null)
const showNotification = ref(false)
const notificationMessage = ref('')
const notificationType = ref('success')

const confirmDelete = (complaint) => {
  complaintToDelete.value = complaint
  showDeleteModal.value = true
}

const deleteComplaint = async () => {
  if (complaintToDelete.value) {
    try {
      await complaintStore.deleteComplaint(complaintToDelete.value.id)
      notificationMessage.value = 'Жалоба успешно удалена'
      notificationType.value = 'success'
    } catch (error) {
      notificationMessage.value = 'Ошибка при удалении жалобы'
      notificationType.value = 'error'
      console.error('Ошибка удаления:', error)
    } finally {
      showNotification.value = true
      showDeleteModal.value = false
    }
  }
}

// Методы


const analyzeDocument = async (documentId) => {
  try {
    const doc = await fetchDocument(documentId); // Ваш метод загрузки документа
    const analysis = await complaintStore.analyzeLegalText(doc.content);
    
    useToast().show({
      title: "Анализ завершен",
      message: `Найдено нарушений: ${analysis.violations.length}`,
      variant: analysis.violations.length ? "danger" : "success"
    });

    return analysis;
  } catch (error) {
    useToast().show({
      title: "Ошибка анализа",
      message: error.message,
      variant: "error"
    });
  }
};



const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString('ru-RU')
}

const exportComplaint = async (complaintId, format) => {
  try {
    const blob = await complaintStore.exportComplaint(complaintId, format)
    const complaint = complaints.value.find(c => c.id === complaintId)
    const filename = `Жалоба_${complaint.agency}_${formatDate(complaint.createdAt)}.${format}`
    saveAs(blob, filename)
  } catch (error) {
    console.error('Export error:', error)
    notificationMessage.value = 'Ошибка при экспорте'
    notificationType.value = 'error'
    showNotification.value = true
  }
}

// Lifecycle
onMounted(async () => {
  isLoading.value = true
  try {
    await complaintStore.fetchComplaints()
  } catch (error) {
    console.error('Failed to load complaints:', error)
    notificationMessage.value = 'Ошибка загрузки жалоб'
    notificationType.value = 'error'
    showNotification.value = true
  } finally {
    isLoading.value = false
  }
})
</script>



====================

// Файл: frontend\src\views\ComplaintForm.vue
<!-- src/components/complaints/ComplaintForm.vue -->
<template>
  <div class="complaint-form">
    <div class="header">
      <button @click="goBack" class="back-button">← Назад</button>
      <h1>Создание жалобы</h1>
    </div>

    <div v-if="loading" class="loading">
      <p>Загрузка данных...</p>
    </div>
    
    <div v-else-if="error" class="error">
      <p>Ошибка: {{ error }}</p>
    </div>
    
    <div v-else class="complaint-form-content">
      <div class="document-preview">
        <h2>Документ для жалобы</h2>
        <div class="document-info">
          <div class="info-row">
            <span class="label">Дата поступления:</span>
            <span class="value">{{ formatDate(document.date) }}</span>
          </div>
          <div class="info-row">
            <span class="label">Ведомство:</span>
            <span class="value">{{ document.agency || 'Не указано' }}</span>
          </div>
          <div class="info-row">
            <span class="label">Дата документа:</span>
            <span class="value">{{ document.documentDate || 'Не указана' }}</span>
          </div>
          <div class="info-row">
            <span class="label">Краткая суть:</span>
            <span class="value">{{ document.summary || 'Нет краткой сводки' }}</span>
          </div>
        </div>
      </div>

      <div class="agency-selection">
        <h2>Выберите ведомство</h2>
        <select v-model="selectedAgency" @change="onAgencyChange" class="agency-select">
          <option value="">-- Выберите ведомство --</option>
          <option 
            v-for="agency in agenciesOptions" 
            :key="agency" 
            :value="agency"
          >
            {{ agency }}
          </option>
        </select>
      </div>

      <div class="instructions-section">
        <h2>Дополнительные инструкции</h2>
        <textarea 
          v-model="customInstructions" 
          placeholder="Введите дополнительные инструкции для нейросети (необязательно)"
          class="instructions-input"
          rows="4"
        ></textarea>
      </div>

      <div class="actions">
        <button 
          @click="generateComplaint" 
          :disabled="isGenerating || !selectedAgency"
          class="generate-btn"
        >
          {{ isGenerating ? 'Генерация...' : 'Создать жалобу' }}
        </button>
        <button @click="goBack" class="cancel-btn">Отмена</button>
      </div>

      <div v-if="generatedComplaint" class="complaint-result">
        <h2>Сгенерированная жалоба</h2>
        <div class="complaint-content">
          <pre>{{ generatedComplaint }}</pre>
        </div>
        <div class="result-actions">
          <button @click="copyToClipboard" class="copy-btn">Копировать</button>
          <button @click="saveComplaint" class="save-btn">Сохранить в документ</button>
        </div>
      </div>
    </div>

    <NotificationToast 
      v-if="showNotification"
      :message="notificationMessage"
      :type="notificationType"
      :duration="2000"
      @close="showNotification = false"
    />
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/documentStore'
import { useComplaintStore } from '@/stores/complaintStore'
import NotificationToast from '@/components/ui/NotificationToast.vue'

const route = useRoute()
const router = useRouter()
const documentStore = useDocumentStore()
const complaintStore = useComplaintStore()

// Состояния (все в Pinia store)
const selectedAgency = ref('')
const customInstructions = ref('')
const generatedComplaint = ref(null)

// Геттеры из store
const agenciesOptions = computed(() => complaintStore.agenciesOptions)
const isGenerating = computed(() => complaintStore.isGenerating)
const loading = computed(() => documentStore.loading)
const error = computed(() => documentStore.error)

// Методы из store
const formatDate = (dateString) => {
  return dateString ? new Date(dateString).toLocaleDateString('ru-RU') : 'Дата не указана'
}

const onAgencyChange = () => {
  // Логика при изменении выбора ведомства
}

const generateComplaint = async () => {
  if (!selectedAgency.value) return
  
  try {
    const payload = {
      documentId: route.params.id,
      agency: selectedAgency.value,
      instructions: customInstructions.value
    }
    
    // Используем метод из store
    await complaintStore.generateComplaint(payload)
    generatedComplaint.value = complaintStore.generatedComplaint
    
    // Сбросим состояние после успешной генерации
    selectedAgency.value = ''
    customInstructions.value = ''
  } catch (err) {
    console.error('Ошибка генерации жалобы:', err)
    // Обработка ошибки через store или уведомления
  }
}

const copyToClipboard = () => {
  if (generatedComplaint.value) {
    navigator.clipboard.writeText(generatedComplaint.value)
    // Уведомление через store
  }
}

const saveComplaint = async () => {
  if (!generatedComplaint.value) return
  
  try {
    const complaintData = {
      documentId: route.params.id,
      agency: selectedAgency.value,
      content: generatedComplaint.value,
      status: 'draft'
    }
    
    await complaintStore.saveComplaintToDocument(complaintData)
    
    // После сохранения обновляем документ
    await documentStore.fetchDocumentById(route.params.id)
    router.push(`/documents/${route.params.id}`)
  } catch (err) {
    console.error('Ошибка сохранения жалобы:', err)
  }
}

const goBack = () => {
  router.push(`/documents/${route.params.id}`)
}

// Загрузка данных документа
onMounted(async () => {
  try {
    await documentStore.fetchDocumentById(route.params.id)
  } catch (err) {
    console.error('Ошибка загрузки документа:', err)
  }
})
</script>



====================

// Файл: frontend\src\stores\documentStore.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import axios from "axios";
import { useRouter } from "vue-router";
import { v4 as uuidv4 } from "uuid";
import { useAIStore } from "@/stores/aiStore";

export const useDocumentStore = defineStore("document", () => {
  const router = useRouter();
  const aiStore = useAIStore();
  const API_BASE = "http://localhost:3001";

  // Состояние хранилища

  const documents = ref([]);
  const isLoading = ref(false);
  const error = ref(null);
  const isAnalyzing = ref(false);


  const currentDocument = ref({
    id: uuidv4(),
    date: new Date().toISOString(), // Дата поступления (п.1)
    originalText: "", // Дословный текст (п.2)
    agencyTarget: "", // Ведомство (п.3)
    summary: "", // Краткая суть (п.4)
    keyParagraphs: [], // Существенные параграфы (п.5)
    // Расшифровка документа (п.6)
    documentDate: "",
    senderAgency: "",
    documentSummary: "",
    fullText: "",
    attachments: [],
    complaints: [],
    analysisStatus: "pending",
    lastAnalyzedAt: null,
    violations: [],
  });

  // Геттеры
  const agenciesList = computed(() => {
    const agencies = new Set(["ФССП", "Прокуратура", "Суд", "Омбудсмен"]);
    documents.value.forEach((doc) => {
      if (doc.agency) agencies.add(doc.agency);
      if (doc.senderAgency) agencies.add(doc.senderAgency);
    });
    return Array.from(agencies).sort();
  });

  const hasAttachments = computed(() => {
    return currentDocument.value.attachments?.length > 0;
  });

  const analyzedDocuments = computed(() => {
    return documents.value.filter((doc) => doc.analysisStatus === "completed");
  });

  // Действия
  const fetchDocuments = async () => {
    return handleApiCall(async () => {
      const { data } = await axios.get(`${API_BASE}/api/documents`);
      documents.value = data.items || data;
    });
  };

  const fetchDocumentById = async (id) => {
    return handleApiCall(async () => {
      const { data } = await axios.get(`${API_BASE}/api/documents/${id}`);
      currentDocument.value = normalizeDocumentData(data);
      return data;
    });
  };

  const uploadFiles = async (files) => {
    return handleApiCall(async () => {
      const formData = new FormData();
      if (currentDocument.value.originalText) {
        formData.append("text", currentDocument.value.originalText);
      }

      Array.from(files).forEach((file) => formData.append("files", file));

      const { data } = await axios.post(
        `${API_BASE}/api/documents/upload`,
        formData,
        { headers: { "Content-Type": "multipart/form-data" } }
      );

      currentDocument.value = {
        ...normalizeDocumentData(data),
        originalText: data.originalText || currentDocument.value.originalText,
      };
      return data;
    });
  };

  const saveDocument = async () => {
    return handleApiCall(async () => {
      const docToSave = prepareDocumentForSave(currentDocument.value);
      let savedDocument;

      if (docToSave.id) {
        const { data } = await axios.put(
          `${API_BASE}/api/documents/${docToSave.id}`,
          docToSave
        );
        savedDocument = data;
      } else {
        const { data } = await axios.post(
          `${API_BASE}/api/documents`,
          docToSave
        );
        savedDocument = data;
      }

      updateDocumentsList(savedDocument);
      currentDocument.value = normalizeDocumentData(savedDocument);
      return savedDocument;
    });
  };

  const deleteDocument = async (id) => {
    return handleApiCall(async () => {
      await axios.delete(`${API_BASE}/api/documents/${id}`);
      documents.value = documents.value.filter((doc) => doc.id !== id);

      if (currentDocument.value.id === id) {
        resetCurrentDocument();
      }
    });
  };

  const analyzeDocument = async () => {
    if (!currentDocument.value.originalText?.trim()) {
    error.value = "Нет текста для анализа";
    return;
  }
    isAnalyzing.value = true;
    error.value = null;

    try {
      
      currentDocument.value.analysisStatus = "processing";
      await saveDocument();

      const analysis = await analyzeDocumentContent();
      const attachmentsAnalysis = await analyzeAttachments();

      currentDocument.value = {
        ...currentDocument.value,
        ...analysis,
        attachments: attachmentsAnalysis,
        analysisStatus: "completed",
        lastAnalyzedAt: new Date().toISOString(),
      };

      await saveDocument();
      return analysis;
    } catch (err) {
      currentDocument.value.analysisStatus = "failed";
      await saveDocument();
      throw err;
    } finally {
      isAnalyzing.value = false;
    }
  };

  // Вспомогательные функции

  const normalizeDocumentData = (data) => ({
    id: data.id || null,
    date: data.date || new Date().toISOString().split("T")[0],
    agency: data.agency || "", // старое поле (оставляем для обратной совместимости)
    agencyTarget: data.agencyTarget || "", // новое поле (п.3)
    originalText: data.originalText || "", // п.2
    summary: data.summary || "", // п.4
    keyParagraphs: data.keyParagraphs || [], // п.5
    // Поля для расшифровки документа (п.6)
    documentDate: data.documentDate || "",
    senderAgency: data.senderAgency || "",
    documentSummary: data.documentSummary || data.summary || "", // п.6в (используем summary если нет отдельного поля)
    fullText: data.fullText || data.originalText || "", // п.6г
    attachments:
      data.attachments?.map((att) => ({
        id: att.id || uuidv4(),
        name: att.name,
        type: att.type,
        size: att.size,
        path: att.path,
        text: att.text || "",
        analysis: att.analysis || null,
        // Добавляем поля для анализа вложений (п.6 для вложений)
        documentDate: att.documentDate || "",
        senderAgency: att.senderAgency || "",
        attachmentSummary: att.attachmentSummary || att.documentSummary || "",
        fullText: att.fullText || att.text || "",
        keyParagraphs: att.keyParagraphs || [],
      })) || [],
    complaints: data.complaints || [],
    analysisStatus: data.analysisStatus || "pending",
    lastAnalyzedAt: data.lastAnalyzedAt || null,
    violations: data.violations || [],
  });

  const prepareDocumentForSave = (doc) => ({
    ...doc,
    keyParagraphs: doc.keyParagraphs.filter((p) => p.trim()),
    attachments: doc.attachments.map((att) => ({
      id: att.id || uuidv4(),
      name: att.name,
      type: att.type,
      size: att.size,
      path: att.path,
      text: att.text || "",
      analysis: att.analysis || null,
    })),
  });

  const updateDocumentsList = (savedDocument) => {
    const index = documents.value.findIndex((d) => d.id === savedDocument.id);
    if (index !== -1) {
      documents.value[index] = savedDocument;
    } else {
      documents.value.unshift(savedDocument);
    }
  };

  const handleApiCall = async (apiFunction) => {
    isLoading.value = true;
    error.value = null;
    try {
      return await apiFunction();
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

const analyzeDocumentContent = async () => {
  try {
    const docText = currentDocument.value.originalText;
    const analysis = await aiStore.analyzeDocument(docText);
    
    // Гарантируем, что keyParagraphs будет массивом
    return {
      summary: analysis.summary || "Не удалось сгенерировать краткую суть",
      keyParagraphs: Array.isArray(analysis.keyParagraphs) ? 
        analysis.keyParagraphs : 
        [],
      violations: Array.isArray(analysis.violations) ?
        analysis.violations :
        [],
      documentDate: analysis.documentDate || "",
      senderAgency: analysis.senderAgency || ""
    };
  } catch (error) {
    console.error("Ошибка анализа документа:", error);
    return {
      summary: "Ошибка анализа документа",
      keyParagraphs: [],
      violations: [],
      documentDate: "",
      senderAgency: ""
    };
  }
};


  const determineTargetAgency = (text) => {
    const violations = text.match(/нарушен[ия]|незаконн|жалоб[аы]/gi);
    if (!violations) return "";

    if (text.includes("ФССП") || text.includes("судебн")) return "ФССП";
    if (text.includes("прокурор")) return "Прокуратура";
    if (text.includes("суд")) return "Суд";
    if (text.includes("омбудсмен")) return "Омбудсмен";

    return "ФССП"; // По умолчанию
  };

  const analyzeAttachments = async () => {
  if (!currentDocument.value.attachments?.length) return [];

  isAnalyzing.value = true;
  try {
    const updatedAttachments = await Promise.all(
      currentDocument.value.attachments.map(async (att) => {
        if (!att.text) return att;
        
        const analysis = await aiStore.analyzeAttachment(att.text);
        const attachmentSummary = await aiStore.generateAttachmentSummary(att.text);
        
        return {
          ...att,
          analysis,
          documentDate: extractDate(att.text),
          senderAgency: extractAgency(att.text),
          attachmentSummary: attachmentSummary.summary || "", // Чёткое название
          fullText: att.text,
          keyParagraphs: analysis.keyParagraphs || []
        };
      })
    );

    currentDocument.value.attachments = updatedAttachments;
    return updatedAttachments;
  } catch (err) {
    error.value = 'Ошибка анализа вложений: ' + err.message;
    throw err;
  } finally {
    isAnalyzing.value = false;
  }
};

  const extractDate = (text) => {
    const dateRegex = /(\d{2}\.\d{2}\.\d{4})|(\d{4}-\d{2}-\d{2})/;
    const match = text.match(dateRegex);
    return match ? match[0] : "";
  };

  const extractAgency = (text) => {
    const agencies = ["ФССП", "Прокуратура", "Суд", "Омбудсмен"];
    return agencies.find((agency) => text.includes(agency)) || "";
  };

  const resetCurrentDocument = () => {
    currentDocument.value = createEmptyDocument();
  };

  const viewDocument = async (id) => {
    await fetchDocumentById(id);
    router.push(`/documents/${id}`);
  };

  const regenerateAttachmentAnalysis = async (attachmentId) => {
    const attachment = currentDocument.value.attachments.find(
      (a) => a.id === attachmentId
    );
    if (!attachment) return;

    try {
      const analysis = await aiStore.analyzeAttachment(attachment.text);
      const updatedAttachment = {
        ...attachment,
        analysis,
        documentDate: extractDate(attachment.text),
        senderAgency: extractAgency(attachment.text),
        documentSummary: analysis.summary || "",
        fullText: attachment.text,
        keyParagraphs: analysis.paragraphs || [],
      };

      const index = currentDocument.value.attachments.findIndex(
        (a) => a.id === attachmentId
      );
      currentDocument.value.attachments[index] = updatedAttachment;
      await saveDocument();

      return updatedAttachment;
    } catch (err) {
      error.value = "Ошибка перегенерации анализа вложения: " + err.message;
      throw err;
    }
  };

  const generateComplaint = async (documentId, agency) => {
    return handleApiCall(async () => {
      const doc = documents.value.find((d) => d.id === documentId);
      if (!doc) throw new Error("Документ не найден");

      const relatedDocs = documents.value.filter(
        (d) => d.date <= doc.date && d.id !== documentId
      );

      const { data } = await axios.post(`${API_BASE}/api/complaints`, {
        documentId,
        agency,
        relatedDocuments: relatedDocs.map((d) => d.id),
      });

      if (currentDocument.value.id === documentId) {
        currentDocument.value.complaints = [
          ...(currentDocument.value.complaints || []),
          data,
        ];
        await saveDocument();
      }

      return data;
    });
  };

  const fetchComplaints = async (documentId) => {
      return handleApiCall(async () => {
        const { data } = await axios.get(
          `${API_BASE}/api/documents/${documentId}/complaints`
        );

        if (currentDocument.value.id === documentId) {
          currentDocument.value.complaints = data;
        }

        return data;
      });
    }

  return {
    currentDocument,
    documents,
    isLoading,
    error,
    isAnalyzing,
    agenciesList,
    hasAttachments,
    analyzedDocuments,
    fetchDocuments,
    fetchDocumentById,
    uploadFiles,
    saveDocument,
    deleteDocument,
    analyzeDocument,
    regenerateAttachmentAnalysis,
    generateComplaint,
    fetchComplaints,
    resetCurrentDocument,
    viewDocument,
  }
})



====================

// Файл: frontend\src\stores\complaintStore.js
import { defineStore } from "pinia";
import { ref, computed } from "vue";
import { v4 as uuidv4 } from "uuid";
import { saveAs } from "file-saver";
import { useDocumentStore } from "./documentStore";
import aiService from "../../../backend/services/aiService";
import { Packer } from "docx";
import { Document, Paragraph, TextRun } from "docx";

export const useComplaintStore = defineStore("complaint", () => {
  const documentStore = useDocumentStore();

  // Состояние
  const complaints = ref([]);
  const isLoading = ref(false);
  const error = ref(null);
  const isGenerating = ref(false);
  const isExporting = ref(false);
  const generatedComplaint = ref(null);

  // Геттеры
  const agenciesOptions = computed(() => [
    "Федеральная служба судебных приставов (ФССП)",
    "Прокуратура",
    "Суд (административное исковое заявление)",
    "Уполномоченный по правам человека (омбудсмен)",
  ]);

  const getComplaintsByDocument = computed(() => (documentId) => {
    return complaints.value.filter((c) => c.documentId === documentId);
  });

  // Действия
  const fetchComplaints = async () => {
    isLoading.value = true;
    try {
      // В реальном приложении здесь будет запрос к API
      // Для примера используем локальные данные
      complaints.value = JSON.parse(localStorage.getItem("complaints") || "[]");
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const generateComplaint = async (payload) => {
    isGenerating.value = true;
    error.value = null;

    try {
      const { documentId, agency, instructions } = payload;

      // Получаем документ и связанные документы
      const doc = await documentStore.fetchDocumentById(documentId);
      const relatedDocs = documentStore.documents.filter(
        (d) => d.date <= doc.date && d.id !== documentId
      );

      // Генерируем жалобу через AI сервис
      const result = await aiService.generateComplaint(
        doc.originalText,
        agency,
        relatedDocs.map((d) => d.originalText),
        instructions
      );

      // Формируем объект жалобы
      const newComplaint = {
        id: uuidv4(),
        documentId,
        agency,
        summary: complaintContent.summary, // Краткая суть (п.4)
        verbatimSections: complaintContent.verbatimSections, // Дословные параграфы (п.5)
        relatedDocuments: relatedDocs.map((d) => ({
          id: d.id,
          date: d.date, // Дата отправления (п.6а)
          agency: d.senderAgency, // Ведомство-отправитель (п.6б)
          summary: d.documentSummary, // Краткая суть документа (п.6в)
          text: d.fullText, // Полный текст (п.6г)
          verbatimSections: d.verbatimSections, // Дословные параграфы (п.6д)
        })),
        status: "draft",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Сохраняем в хранилище
      complaints.value.unshift(newComplaint);
      generatedComplaint.value = newComplaint;

      // Сохраняем в локальное хранилище (в реальном приложении - API запрос)
      localStorage.setItem("complaints", JSON.stringify(complaints.value));

      return newComplaint;
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isGenerating.value = false;
    }
  };

  const saveComplaint = async (complaintData) => {
    isLoading.value = true;
    try {
      const index = complaints.value.findIndex(
        (c) => c.id === complaintData.id
      );
      if (index !== -1) {
        complaints.value[index] = {
          ...complaints.value[index],
          ...complaintData,
          updatedAt: new Date().toISOString(),
        };
      } else {
        complaints.value.unshift({
          ...complaintData,
          id: uuidv4(),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        });
      }

      localStorage.setItem("complaints", JSON.stringify(complaints.value));
      return complaints.value[index !== -1 ? index : 0];
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const exportComplaint = async (complaintId, format = "txt") => {
    isExporting.value = true;
    try {
      const complaint = complaints.value.find((c) => c.id === complaintId);
      if (!complaint) throw new Error("Жалоба не найдена");

      if (format === "txt") {
        const blob = new Blob([complaint.content], { type: "text/plain" });
        saveAs(
          blob,
          `Жалоба_${complaint.agency}_${formatDate(complaint.createdAt)}.txt`
        );
        return blob;
      }

      if (format === "doc") {
        const doc = new Document({
          sections: [
            {
              properties: {},
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: complaint.content,
                      size: 24,
                    }),
                  ],
                }),
              ],
            },
          ],
        });

        const buffer = await Packer.toBuffer(doc);
        const blob = new Blob([buffer], {
          type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        });

        saveAs(
          blob,
          `Жалоба_${complaint.agency}_${formatDate(complaint.createdAt)}.docx`
        );
        return blob;
      }

      throw new Error("Неподдерживаемый формат экспорта");
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isExporting.value = false;
    }
  };

  const deleteComplaint = async (id) => {
    isLoading.value = true;
    try {
      complaints.value = complaints.value.filter((c) => c.id !== id);
      localStorage.setItem("complaints", JSON.stringify(complaints.value));
      return true;
    } catch (err) {
      error.value = err.message;
      throw err;
    } finally {
      isLoading.value = false;
    }
  };

  const updateComplaintStatus = async (id, status) => {
    try {
      const index = complaints.value.findIndex((c) => c.id === id);
      if (index !== -1) {
        complaints.value[index].status = status;
        complaints.value[index].updatedAt = new Date().toISOString();
        localStorage.setItem("complaints", JSON.stringify(complaints.value));
      }
      return complaints.value[index];
    } catch (err) {
      error.value = err.message;
      throw err;
    }
  };

  // Вспомогательные функции
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString("ru-RU");
  };

  return {
    // Состояние
    complaints,
    isLoading,
    error,
    isGenerating,
    isExporting,
    generatedComplaint,

    // Геттеры
    agenciesOptions,
    getComplaintsByDocument,

    // Действия
    fetchComplaints,
    generateComplaint,
    saveComplaint,
    exportComplaint,
    deleteComplaint,
    updateComplaintStatus,
  };
});

// import { defineStore } from 'pinia';
// import { ref, computed } from 'vue';
// import axios from 'axios';
// import { saveAs } from 'file-saver';

// export const useComplaintStore = defineStore('complaint', () => {
//   // Состояние
//   const complaints = ref([]);
//   const isLoading = ref(false);
//   const error = ref(null);
//   const isGenerating = ref(false);
//   const isExporting = ref(false);

//   // Геттеры
//   const agenciesOptions = computed(() => [
//     'ФССП',
//     'Прокуратура',
//     'Суд (административное исковое заявление)',
//     'Уполномоченный по правам человека (омбудсмен)'
//   ]);

//   const draftedComplaints = computed(() =>
//     complaints.value.filter(c => c.status === 'draft')
//   );

//   const sentComplaints = computed(() =>
//     complaints.value.filter(c => c.status === 'sent')
//   );

//   // Действия
//   const fetchComplaints = async () => {
//     isLoading.value = true;
//     try {
//       const { data } = await axios.get('/api/complaints');
//       complaints.value = data;
//     } catch (err) {
//       error.value = err.response?.data?.message || err.message;
//       throw err;
//     } finally {
//       isLoading.value = false;
//     }
//   };

//   const generateComplaint = async (payload) => {
//     isGenerating.value = true;
//     try {
//       const { data } = await axios.post('/api/complaints/generate', {
//         documentId: payload.documentId,
//         agency: payload.agency,
//         instructions: payload.instructions,
//         relatedDocumentId: null,
//       });

//       complaints.value.unshift(data);
//       return data;
//     } catch (err) {
//       error.value = err.response?.data?.message || err.message;
//       throw err;
//     } finally {
//       isGenerating.value = false;
//     }
//   };

//   const exportComplaint = async (complaintId, format = 'txt') => {
//     isExporting.value = true;
//     try {
//       const response = await axios.get(
//         `/api/complaints/${complaintId}/export?format=${format}`,
//         { responseType: format === 'doc' ? 'blob' : 'text' }
//       );

//       const complaint = complaints.value.find(c => c.id === complaintId);
//       const fileName = `Жалоба_${complaint.agency}_${new Date(complaint.createdAt).toLocaleDateString('ru-RU')}.${format}`;

//       if (format === 'doc') {
//         saveAs(response.data, fileName);
//       } else {
//         const blob = new Blob([response.data], { type: 'text/plain;charset=utf-8' });
//         saveAs(blob, fileName);
//       }

//       return response.data;
//     } catch (err) {
//       error.value = err.response?.data?.message || err.message;
//       throw err;
//     } finally {
//       isExporting.value = false;
//     }
//   };

//   const deleteComplaint = async (id) => {
//     isLoading.value = true;
//     try {
//       await axios.delete(`/api/complaints/${id}`);
//       complaints.value = complaints.value.filter(c => c.id !== id);
//       return true;
//     } catch (err) {
//       error.value = err.response?.data?.message || err.message;
//       throw err;
//     } finally {
//       isLoading.value = false;
//     }
//   };

//   const updateComplaintStatus = async (id, status) => {
//     try {
//       const { data } = await axios.patch(`/api/complaints/${id}`, { status });
//       const index = complaints.value.findIndex(c => c.id === id);
//       if (index !== -1) {
//         complaints.value[index] = data;
//       }
//       return data;
//     } catch (err) {
//       error.value = err.response?.data?.message || err.message;
//       throw err;
//     }
//   };

//   return {
//     // Состояние
//     complaints,
//     isLoading,
//     error,
//     isGenerating,
//     isExporting,

//     // Геттеры
//     agenciesOptions,
//     draftedComplaints,
//     sentComplaints,

//     // Действия
//     fetchComplaints,
//     generateComplaint,
//     exportComplaint,
//     deleteComplaint,
//     updateComplaintStatus
//   };
// });


====================

// Файл: frontend\src\stores\aiStore.js
import { defineStore } from "pinia";
import axios from "axios";
import AIService from "../../../backend/services/aiService";

export const useAIStore = defineStore("ai", {
  state: () => ({
    isLoading: false,
    error: null,
    apiStatus: "unknown",
    apiUrl: "http://localhost:11434/api/generate",
    model: "llama3.1/18/8192",
    availableModels: [
      {
        name: "llama3.1/18/8192",
        description: "using 18 treads with 8192 num_ctx",
        parameters: {
          temperature: 0.3,
          top_p: 0.9,
          // num_ctx: 16384,
        },
      },
    ],
    agencies: ["ФССП", "Прокуратура", "Суд", "Омбудсмен"],
  }),

  actions: {
    _initAIService() {
      return new AIService(this.apiUrl, this.model);
    },

    async checkServerStatus() {
      try {
        const response = await axios.get("http://localhost:11434/api/tags", {
          timeout: 3000,
        });
        this.apiStatus = response.status === 200 ? "ready" : "error";
        return this.apiStatus;
      } catch (error) {
        this.apiStatus = "offline";
        throw new Error("AI сервер недоступен");
      }
    },

    async generateSummary(text) {
      this.isLoading = true;
      this.error = null;

      try {
        const aiService = this._initAIService();
        const summary = await aiService.queryLocalModel(text, {
          taskType: "summary",
        });
        return summary?.response || "Не удалось сгенерировать краткую суть";
      } catch (error) {
        console.error("Ошибка генерации сводки:", error);
        this.error = error.message;
        return "Ошибка генерации краткой сводки";
      } finally {
        this.isLoading = false;
      }
    },

    async extractKeyParagraphs(text) {
      this.isLoading = true;
      this.error = null;

      try {
        const aiService = this._initAIService();
        const response = await aiService.analyzeLegalText(text);
        return response.keyParagraphs || [];
      } catch (error) {
        console.error("Ошибка extractKeyParagraphs:", error);
        this.error = error.message;
        return ["Не удалось извлечь ключевые параграфы"];
      } finally {
        this.isLoading = false;
      }
    },

    async detectViolations(text) {
      this.isLoading = true;
      this.error = null;

      try {
        const aiService = this._initAIService();
        const response = await aiService.queryLocalModel(text, {
          taskType: "violations",
          temperature: 0.5,
        });
        return response?.response || "Не удалось проанализировать нарушения";
      } catch (error) {
        console.error("Ошибка анализа нарушений:", error);
        this.error = error.message;
        return "Не удалось проанализировать нарушения. Проверьте текст документа.";
      } finally {
        this.isLoading = false;
      }
    },

    async analyzeAttachment(text) {
      this.isLoading = true;
      this.error = null;

      try {
        const aiService = this._initAIService();
        const response = await aiService.queryLocalModel(text, {
          taskType: "attachment",
          temperature: 0.2,
          format: "json",
        });
        return aiService.parseAttachmentAnalysis(response);
      } catch (error) {
        console.error("Ошибка анализа вложения:", error);
        this.error = error.message;
        return {
          documentType: "Неизвестный тип",
          sentDate: "",
          senderAgency: "",
          summary: "Ошибка анализа документа",
          keyParagraphs: [],
        };
      } finally {
        this.isLoading = false;
      }
    },

    async analyzeDocument(text) {
      this.isLoading = true;
      this.error = null;

      try {
        const [summary, paragraphs, violations] = await Promise.all([
          this.generateSummary(text),
          this.extractKeyParagraphs(text),
          this.detectViolations(text),
        ]);

        return {
          summary: summary || "Не удалось сгенерировать сводку",
          paragraphs: Array.isArray(paragraphs)
            ? paragraphs
            : ["Ошибка извлечения цитат"],
          violations: violations || "Ошибка анализа нарушений",
          status: "complete",
        };
      } catch (error) {
        console.error("Ошибка анализа документа:", error);
        this.error = error.message;
        return {
          summary: "Системная ошибка анализа",
          paragraphs: ["Системная ошибка"],
          violations: "Системная ошибка",
          status: "error",
        };
      } finally {
        this.isLoading = false;
      }
    },

    async generateAttachmentSummary(text) {
      const aiService = this._initAIService();
      return aiService.queryLocalModel(text, {
        taskType: "attachment",
        temperature: 0,
        format: "json",
      });
    },

    async generateComplaint(text, agency, violation = "") {
      this.isLoading = true;
      this.error = null;

      if (!this.agencies.includes(agency)) {
        this.error = "Указано недопустимое ведомство";
        throw new Error(this.error);
      }

      try {
        const aiService = this._initAIService();
        const prompt = `Сгенерируй официальную жалобу в ${agency} на основе документа.
                      ${violation ? `Выявленное нарушение:\n${violation}\n` : ""}
                      Текст документа:\n${text.substring(0, 3000)}`;

        const response = await aiService.queryLocalModel(prompt, {
          temperature: 0.5,
          max_tokens: 7000,
        });

        return (
          response?.response || this._generateFallbackComplaint(text, agency)
        );
      } catch (error) {
        console.error("Ошибка генерации жалобы:", error);
        this.error = error.message;
        return this._generateFallbackComplaint(text, agency);
      } finally {
        this.isLoading = false;
      }
    },

    _generateFallbackComplaint(text, agency) {
      return `В ${agency}\n\nЗаявитель: [ФИО]\n\nЖалоба на документ:\n${text.substring(
        0,
        500
      )}\n\nТребования: Провести проверку\n\nДата: ${new Date().toLocaleDateString()}`;
    },
  },

  getters: {
    isServerOnline: (state) => state.apiStatus === "ready",
    activeModelName: (state) => {
      const model = state.availableModels.find(
        (m) => m.name === state.model
      );
      return model ? model.description : "Неизвестная модель";
    },
  },
});









// import { defineStore } from "pinia";
// import axios from "axios";
// import AIService from "../../../backend/services/aiService";

// export const useAIStore = defineStore("ai", {
//   state: () => ({
//     isLoading: false,
//     error: null,
//     apiStatus: "unknown", // 'ready', 'error', 'offline'
//     apiUrl: "http://localhost:11434/api/generate",
//     model: "llama3.1:latest",
//     availableModels: [
//       {
//         name: "llama3.1:latest",
//         description: "Llama 3.1 (latest)",
//         parameters: {
//           temperature: 0.3,
//           top_p: 0.9,
//           num_ctx: 16384,
//         },
//       },
//     ],
//     agencies: ["ФССП", "Прокуратура", "Суд", "Омбудсмен"],
//   }),

//   actions: {
//     /**
//      * Инициализация AI сервиса
//      */
//     _initAIService() {
//       return new AIService(this.apiUrl, this.activeModel);
//     },

//     /**
//      * Фильтр для удаления предложений с латинскими символами (>15)
//      */
//     _filterLatinText(text) {
//       if (!text) return text;

//       return text
//         .split(/(?<=[.!?])\s+/)
//         .filter((sentence) => {
//           const latinChars = (sentence.match(/[a-zA-Z]/g) || []).length;
//           return latinChars <= 15;
//         })
//         .join(" ")
//         .trim();
//     },

//     /**
//      * Проверка доступности AI сервера
//      */
//     async checkServerStatus() {
//       try {
//         const response = await axios.get("http://localhost:11434/api/tags", {
//           timeout: 3000,
//         });
//         this.apiStatus = response.status === 200 ? "ready" : "error";
//         return this.apiStatus;
//       } catch (error) {
//         this.apiStatus = "offline";
//         throw new Error("AI сервер недоступен");
//       }
//     },

//     /**
//      * Генерация краткой сводки
//      */
//     async generateSummary(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const filteredText = this._filterLatinText(text);
//         const summary = await aiService.queryLocalModel(filteredText, {
//           taskType: "summary",
//         });

//         return summary?.response || "Не удалось сгенерировать краткую суть";
//       } catch (error) {
//         console.error("Ошибка генерации сводки:", error);
//         this.error = error.message;
//         return "Ошибка генерации краткой сводки";
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Извлечение ключевых параграфов
//      */
//     async extractKeyParagraphs(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const response = await aiService.analyzeLegalText(text);

//         // Возвращаем нормализованные параграфы
//         return response.keyParagraphs || [];
//       } catch (error) {
//         console.error("Ошибка extractKeyParagraphs:", error);
//         this.error = error.message;
//         return ["Не удалось извлечь ключевые параграфы"];
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Поиск юридических нарушений
//      */
//     async detectViolations(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const filteredText = this._filterLatinText(text);
//         const response = await aiService.queryLocalModel(filteredText, {
//           taskType: "violations",
//           temperature: 0.5,
//         });

//         return response?.response || "Не удалось проанализировать нарушения";
//       } catch (error) {
//         console.error("Ошибка анализа нарушений:", error);
//         this.error = error.message;
//         return "Не удалось проанализировать нарушения. Проверьте текст документа.";
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Анализ вложенного документа
//      */
//     async analyzeAttachment(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const aiService = this._initAIService();
//         const filteredText = this._filterLatinText(text);
//         const response = await aiService.queryLocalModel(filteredText, {
//           taskType: "attachment",
//           temperature: 0.2,
//           format: "json",
//         });

//         return aiService.parseAttachmentAnalysis(response);
//       } catch (error) {
//         console.error("Ошибка анализа вложения:", error);
//         this.error = error.message;
//         return {
//           documentType: "Неизвестный тип",
//           sentDate: "",
//           senderAgency: "",
//           summary: "Ошибка анализа документа",
//           keyParagraphs: [],
//         };
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Полный анализ документа
//      */
//     async analyzeDocument(text) {
//       this.isLoading = true;
//       this.error = null;

//       try {
//         const [summary, paragraphs, violations] = await Promise.all([
//           this.generateSummary(text),
//           this.extractKeyParagraphs(text),
//           this.detectViolations(text),
//         ]);

//         return {
//           summary: summary || "Не удалось сгенерировать сводку",
//           paragraphs: Array.isArray(paragraphs)
//             ? paragraphs
//             : ["Ошибка извлечения цитат"],
//           violations: violations || "Ошибка анализа нарушений",
//           status: "complete",
//         };
//       } catch (error) {
//         console.error("Ошибка анализа документа:", error);
//         this.error = error.message;
//         return {
//           summary: "Системная ошибка анализа",
//           paragraphs: ["Системная ошибка"],
//           violations: "Системная ошибка",
//           status: "error",
//         };
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     async generateAttachmentSummary(text) {
//       return this.queryLocalModel(text, {
//         taskType: "attachment",
//         temperature: 0,
//         format: "json",
//       });
//     },

//     /**
//      * Генерация жалобы
//      */
//     async generateComplaint(text, agency, violation = "") {
//       this.isLoading = true;
//       this.error = null;

//       if (!this.agencies.includes(agency)) {
//         this.error = "Указано недопустимое ведомство";
//         throw new Error(this.error);
//       }

//       try {
//         const aiService = this._initAIService();
//         const prompt = `Сгенерируй официальную жалобу в ${agency} на основе документа.
//                       ${
//                         violation ? `Выявленное нарушение:\n${violation}\n` : ""
//                       }
//                       Текст документа:\n${text.substring(0, 3000)}`;

//         const response = await aiService.queryLocalModel(prompt, {
//           temperature: 0.5,
//           max_tokens: 7000,
//         });

//         return (
//           response?.response || this._generateFallbackComplaint(text, agency)
//         );
//       } catch (error) {
//         console.error("Ошибка генерации жалобы:", error);
//         this.error = error.message;
//         return this._generateFallbackComplaint(text, agency);
//       } finally {
//         this.isLoading = false;
//       }
//     },

//     /**
//      * Обработка параграфов
//      */
//     _postProcessParagraphs(text) {
//       if (!text) return ["Не найдено значимых цитат"];

//       // Обрабатываем как строку, если text не объект
//       const textToProcess =
//         typeof text === "string" ? text : text.response || text.content || "";

//       return textToProcess
//         .split(/(?<=[.!?])\s+/)
//         .map((p) => {
//           let cleaned = p
//             .replace(/<\|.*?\|\>|```/g, "")
//             .replace(/^["']+|["']+$/g, "")
//             .trim();
//           return cleaned.length > 15 ? cleaned : null;
//         })
//         .filter(Boolean)
//         .filter(
//           (item, index, arr) =>
//             index ===
//             arr.findIndex((i) => i.substring(0, 50) === item.substring(0, 50))
//         )
//         .slice(0, 5);
//     },

//     /**
//      * Генерация резервной жалобы при ошибке
//      */
//     _generateFallbackComplaint(text, agency) {
//       return `В ${agency}\n\nЗаявитель: [ФИО]\n\nЖалоба на документ:\n${text.substring(
//         0,
//         500
//       )}\n\nТребования: Провести проверку\n\nДата: ${new Date().toLocaleDateString()}`;
//     },
//   },

//   getters: {
//     isServerOnline: (state) => state.apiStatus === "ready",
//     activeModelName: (state) => {
//       const model = state.availableModels.find(
//         (m) => m.name === state.activeModel
//       );
//       return model ? model.description : "Неизвестная модель";
//     },
//   },
// });

// export default useAIStore;


====================

// Файл: frontend\src\router\index.js
import { createRouter, createWebHistory } from "vue-router";
import HomeView from "@/views/HomeView.vue"; // Импорт напрямую для главной страницы


const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: "/",
      name: "home",
      component: HomeView,
    },
    {
      path: "/review/:id", // Добавляем динамический сегмент
      name: "review",
      component: () => import("@/views/DocumentReview.vue"),
      props: true,
    },
    {
      path: "/documents",
      name: "documents",
      component: () => import("@/views/DocumentsList.vue"), // DocumentsList вместо DocumentsView
    },
    {
      path: "/complaints",
      name: "complaints",
      component: () => import("@/views/ComplaintsList.vue"), // ComplaintsList вместо ComplaintsView
    },
    {
      path: "/documents/:id",
      name: "DocumentDetail",
      component: () => import("@/views/DocumentDetail.vue"),
      props: true,
    },
    {
      path: '/documents/:id/complaint',
      name: 'ComplaintForm',
      component: () => import('@/views/ComplaintForm.vue'),
      props: true
    }

  ],
});

export default router;











====================

// Файл: frontend\src\composables\useDocumentAnalysis.js
import { useDocumentStore } from '@/stores/documentStore';
import { useAIStore } from '@/stores/aiStore';

export const useDocumentAnalysis = () => {
  const documentStore = useDocumentStore();
  const aiStore = useAIStore();

  const analyzeCurrentDocument = async () => {
    return await documentStore.analyzeDocument();
  };

  const analyzeTextWithLLM = async (text) => {
    return await aiStore.analyzeDocument(text);
  };

  return {
    analyzeCurrentDocument,
    analyzeTextWithLLM
  };
};

====================

// Файл: frontend\src\composables\useComplaintGenerator.js
import { ref } from 'vue';
import { useAIStore } from '@/stores/aiStore';

export default function useComplaintGenerator() {
  const aiStore = useAIStore();
  const isGenerating = ref(false);
  const generationError = ref(null);

  const generateComplaint = async (text, agency) => {
    isGenerating.value = true;
    generationError.value = null;
    try {
      return await aiStore.generateComplaint(text, agency);
    } catch (error) {
      generationError.value = error.message;
      throw error;
    } finally {
      isGenerating.value = false;
    }
  };

  return {
    isGenerating,
    generationError,
    generateComplaint
  };
}

====================

// Файл: frontend\src\composables\useAI.js
import { useAIStore } from "@/stores/aiStore";
import AIService from "@/services/aiService";

export function useAI() {
  const aiStore = useAIStore();
  const aiService = new AIService(aiStore.apiUrl, aiStore.activeModel);
  return { aiService };
}

====================

// Файл: frontend\src\components\ui\NotificationToast.vue
<template>
  <transition name="fade">
    <div v-if="show" class="notification-center">
      <div class="notification-content">
        {{ message }}
      </div>
    </div>
  </transition>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const props = defineProps({
  message: String,
  type: {
    type: String,
    default: 'success'
  },
  duration: {
    type: Number,
    default: 3000
  }
})

const show = ref(false)

onMounted(() => {
  show.value = true
  setTimeout(() => {
    show.value = false
  }, props.duration)
})
</script>



====================

// Файл: frontend\src\components\layout\Header.vue


====================

// Файл: frontend\src\components\layout\Footer.vue


====================

// Файл: frontend\src\components\icons\IconTooling.vue
<!-- This icon is from <https://github.com/Templarian/MaterialDesign>, distributed under Apache 2.0 (https://www.apache.org/licenses/LICENSE-2.0) license-->
<template>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    aria-hidden="true"
    role="img"
    class="iconify iconify--mdi"
    width="24"
    height="24"
    preserveAspectRatio="xMidYMid meet"
    viewBox="0 0 24 24"
  >
    <path
      d="M20 18v-4h-3v1h-2v-1H9v1H7v-1H4v4h16M6.33 8l-1.74 4H7v-1h2v1h6v-1h2v1h2.41l-1.74-4H6.33M9 5v1h6V5H9m12.84 7.61c.1.22.16.48.16.8V18c0 .53-.21 1-.6 1.41c-.4.4-.85.59-1.4.59H4c-.55 0-1-.19-1.4-.59C2.21 19 2 18.53 2 18v-4.59c0-.32.06-.58.16-.8L4.5 7.22C4.84 6.41 5.45 6 6.33 6H7V5c0-.55.18-1 .57-1.41C7.96 3.2 8.44 3 9 3h6c.56 0 1.04.2 1.43.59c.39.41.57.86.57 1.41v1h.67c.88 0 1.49.41 1.83 1.22l2.34 5.39z"
      fill="currentColor"
    ></path>
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconSupport.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor">
    <path
      d="M10 3.22l-.61-.6a5.5 5.5 0 0 0-7.666.105 5.5 5.5 0 0 0-.114 7.665L10 18.78l8.39-8.4a5.5 5.5 0 0 0-.114-7.665 5.5 5.5 0 0 0-7.666-.105l-.61.61z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconEcosystem.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="18" height="20" fill="currentColor">
    <path
      d="M11.447 8.894a1 1 0 1 0-.894-1.789l.894 1.789zm-2.894-.789a1 1 0 1 0 .894 1.789l-.894-1.789zm0 1.789a1 1 0 1 0 .894-1.789l-.894 1.789zM7.447 7.106a1 1 0 1 0-.894 1.789l.894-1.789zM10 9a1 1 0 1 0-2 0h2zm-2 2.5a1 1 0 1 0 2 0H8zm9.447-5.606a1 1 0 1 0-.894-1.789l.894 1.789zm-2.894-.789a1 1 0 1 0 .894 1.789l-.894-1.789zm2 .789a1 1 0 1 0 .894-1.789l-.894 1.789zm-1.106-2.789a1 1 0 1 0-.894 1.789l.894-1.789zM18 5a1 1 0 1 0-2 0h2zm-2 2.5a1 1 0 1 0 2 0h-2zm-5.447-4.606a1 1 0 1 0 .894-1.789l-.894 1.789zM9 1l.447-.894a1 1 0 0 0-.894 0L9 1zm-2.447.106a1 1 0 1 0 .894 1.789l-.894-1.789zm-6 3a1 1 0 1 0 .894 1.789L.553 4.106zm2.894.789a1 1 0 1 0-.894-1.789l.894 1.789zm-2-.789a1 1 0 1 0-.894 1.789l.894-1.789zm1.106 2.789a1 1 0 1 0 .894-1.789l-.894 1.789zM2 5a1 1 0 1 0-2 0h2zM0 7.5a1 1 0 1 0 2 0H0zm8.553 12.394a1 1 0 1 0 .894-1.789l-.894 1.789zm-1.106-2.789a1 1 0 1 0-.894 1.789l.894-1.789zm1.106 1a1 1 0 1 0 .894 1.789l-.894-1.789zm2.894.789a1 1 0 1 0-.894-1.789l.894 1.789zM8 19a1 1 0 1 0 2 0H8zm2-2.5a1 1 0 1 0-2 0h2zm-7.447.394a1 1 0 1 0 .894-1.789l-.894 1.789zM1 15H0a1 1 0 0 0 .553.894L1 15zm1-2.5a1 1 0 1 0-2 0h2zm12.553 2.606a1 1 0 1 0 .894 1.789l-.894-1.789zM17 15l.447.894A1 1 0 0 0 18 15h-1zm1-2.5a1 1 0 1 0-2 0h2zm-7.447-5.394l-2 1 .894 1.789 2-1-.894-1.789zm-1.106 1l-2-1-.894 1.789 2 1 .894-1.789zM8 9v2.5h2V9H8zm8.553-4.894l-2 1 .894 1.789 2-1-.894-1.789zm.894 0l-2-1-.894 1.789 2 1 .894-1.789zM16 5v2.5h2V5h-2zm-4.553-3.894l-2-1-.894 1.789 2 1 .894-1.789zm-2.894-1l-2 1 .894 1.789 2-1L8.553.106zM1.447 5.894l2-1-.894-1.789-2 1 .894 1.789zm-.894 0l2 1 .894-1.789-2-1-.894 1.789zM0 5v2.5h2V5H0zm9.447 13.106l-2-1-.894 1.789 2 1 .894-1.789zm0 1.789l2-1-.894-1.789-2 1 .894 1.789zM10 19v-2.5H8V19h2zm-6.553-3.894l-2-1-.894 1.789 2 1 .894-1.789zM2 15v-2.5H0V15h2zm13.447 1.894l2-1-.894-1.789-2 1 .894 1.789zM18 15v-2.5h-2V15h2z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconDocumentation.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="17" fill="currentColor">
    <path
      d="M11 2.253a1 1 0 1 0-2 0h2zm-2 13a1 1 0 1 0 2 0H9zm.447-12.167a1 1 0 1 0 1.107-1.666L9.447 3.086zM1 2.253L.447 1.42A1 1 0 0 0 0 2.253h1zm0 13H0a1 1 0 0 0 1.553.833L1 15.253zm8.447.833a1 1 0 1 0 1.107-1.666l-1.107 1.666zm0-14.666a1 1 0 1 0 1.107 1.666L9.447 1.42zM19 2.253h1a1 1 0 0 0-.447-.833L19 2.253zm0 13l-.553.833A1 1 0 0 0 20 15.253h-1zm-9.553-.833a1 1 0 1 0 1.107 1.666L9.447 14.42zM9 2.253v13h2v-13H9zm1.553-.833C9.203.523 7.42 0 5.5 0v2c1.572 0 2.961.431 3.947 1.086l1.107-1.666zM5.5 0C3.58 0 1.797.523.447 1.42l1.107 1.666C2.539 2.431 3.928 2 5.5 2V0zM0 2.253v13h2v-13H0zm1.553 13.833C2.539 15.431 3.928 15 5.5 15v-2c-1.92 0-3.703.523-5.053 1.42l1.107 1.666zM5.5 15c1.572 0 2.961.431 3.947 1.086l1.107-1.666C9.203 13.523 7.42 13 5.5 13v2zm5.053-11.914C11.539 2.431 12.928 2 14.5 2V0c-1.92 0-3.703.523-5.053 1.42l1.107 1.666zM14.5 2c1.573 0 2.961.431 3.947 1.086l1.107-1.666C18.203.523 16.421 0 14.5 0v2zm3.5.253v13h2v-13h-2zm1.553 12.167C18.203 13.523 16.421 13 14.5 13v2c1.573 0 2.961.431 3.947 1.086l1.107-1.666zM14.5 13c-1.92 0-3.703.523-5.053 1.42l1.107 1.666C11.539 15.431 12.928 15 14.5 15v-2z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\icons\IconCommunity.vue
<template>
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor">
    <path
      d="M15 4a1 1 0 1 0 0 2V4zm0 11v-1a1 1 0 0 0-1 1h1zm0 4l-.707.707A1 1 0 0 0 16 19h-1zm-4-4l.707-.707A1 1 0 0 0 11 14v1zm-4.707-1.293a1 1 0 0 0-1.414 1.414l1.414-1.414zm-.707.707l-.707-.707.707.707zM9 11v-1a1 1 0 0 0-.707.293L9 11zm-4 0h1a1 1 0 0 0-1-1v1zm0 4H4a1 1 0 0 0 1.707.707L5 15zm10-9h2V4h-2v2zm2 0a1 1 0 0 1 1 1h2a3 3 0 0 0-3-3v2zm1 1v6h2V7h-2zm0 6a1 1 0 0 1-1 1v2a3 3 0 0 0 3-3h-2zm-1 1h-2v2h2v-2zm-3 1v4h2v-4h-2zm1.707 3.293l-4-4-1.414 1.414 4 4 1.414-1.414zM11 14H7v2h4v-2zm-4 0c-.276 0-.525-.111-.707-.293l-1.414 1.414C5.42 15.663 6.172 16 7 16v-2zm-.707 1.121l3.414-3.414-1.414-1.414-3.414 3.414 1.414 1.414zM9 12h4v-2H9v2zm4 0a3 3 0 0 0 3-3h-2a1 1 0 0 1-1 1v2zm3-3V3h-2v6h2zm0-6a3 3 0 0 0-3-3v2a1 1 0 0 1 1 1h2zm-3-3H3v2h10V0zM3 0a3 3 0 0 0-3 3h2a1 1 0 0 1 1-1V0zM0 3v6h2V3H0zm0 6a3 3 0 0 0 3 3v-2a1 1 0 0 1-1-1H0zm3 3h2v-2H3v2zm1-1v4h2v-4H4zm1.707 4.707l.586-.586-1.414-1.414-.586.586 1.414 1.414z"
    />
  </svg>
</template>


====================

// Файл: frontend\src\components\common\TextEditor.vue


====================

// Файл: frontend\src\components\common\FileUpload.vue
<template>
  <div class="file-upload">
    <input 
      type="file" 
      id="fileInput"
      ref="fileInput"
      :accept="allowedExtensions"
      @change="handleFileUpload"
      multiple
      hidden
    />
    <label for="fileInput" class="upload-button">
      {{ label }}
    </label>
    <div v-if="files.length > 0" class="file-list">
      <div v-for="(file, index) in files" :key="index" class="file-item">
        <span class="file-name">{{ file.name }}</span>
        <span class="file-size">{{ formatFileSize(file.size) }}</span>
        <button @click="removeFile(index)" class="remove-btn">×</button>
      </div>
    </div>
    <div v-if="error" class="error-message">{{ error }}</div>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const props = defineProps({
  label: {
    type: String,
    default: 'Выберите файлы'
  },
  maxSize: {
    type: Number,
    default: 10 * 1024 * 1024 // 10MB по умолчанию
  }
});

const emit = defineEmits(['files-selected', 'upload-error']);

const fileInput = ref(null);
const files = ref([]);
const error = ref(null);
const allowedExtensions = '.pdf,.txt,.doc,.docx';

const handleFileUpload = (event) => {
  error.value = null;
  const newFiles = Array.from(event.target.files);
  
  // Проверка каждого файла
  for (const file of newFiles) {
    // 1. Проверка расширения
    const extension = file.name.split('.').pop().toLowerCase();
    if (!['pdf', 'txt', 'doc', 'docx'].includes(extension)) {
      error.value = `Файл ${file.name}: недопустимое расширение`;
      emit('upload-error', error.value);
      return;
    }

    // 2. Проверка MIME-типа (клиентская проверка ненадежна, но лучше чем ничего)
    const allowedMimes = [
      'application/pdf',
      'text/plain',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
    
    if (file.type && !allowedMimes.includes(file.type)) {
      error.value = `Файл ${file.name}: недопустимый тип`;
      emit('upload-error', error.value);
      return;
    }

    // 3. Проверка размера
    if (file.size > props.maxSize) {
      error.value = `Файл ${file.name}: превышен максимальный размер (${props.maxSize / 1024 / 1024}MB)`;
      emit('upload-error', error.value);
      return;
    }
  }

  // Если все проверки пройдены
  files.value = [...files.value, ...newFiles];
  updateFileInput();
  emit('files-selected', files.value);
};

const removeFile = (index) => {
  files.value.splice(index, 1);
  updateFileInput();
  emit('files-selected', files.value);
};

const updateFileInput = () => {
  const dataTransfer = new DataTransfer();
  files.value.forEach(file => dataTransfer.items.add(file));
  fileInput.value.files = dataTransfer.files;
};

const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};
</script>



====================

